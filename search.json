[{"title":"ReadMe","url":"/2023/06/14/ReadMe/","content":"\n# 电脑商城系统\n\n<!-- more -->\n\n## 需求分析\n\n​\t商城项目是一个综合性的电商平台，其主要业务流程包括用户注册、选购商品、下单支付、订单管理、商品管理和系统管理等。针对这些业务流程，我们在需求分析阶段，对商城项目进行了详细的分析和规划。\n\n​\t首先，我们对用户注册和登录模块进行了细致的规划，包括用户信息的采集，安全性设计等。\n\n​\t其次，我们对商品模块和订单模块进行了详细的设计，包括商品列表页面、商品详细页面、下单页面、订单管理等。\n\n​\t最后，我们对系统管理模块进行了规划，包括管理员登录、权限管理、系统配置等。除此之外，我们还考虑了界面的简洁程度，以确保顾客和管理员（卖家）对商城项目的顺畅运作。\n\n## 源码名称\n\nJsp+Servlet+MySql 在线电脑商城系统\n\n### 开发框架\n\n无使用任何框架）\n\n### 环境搭建（没有前后端分离）\n\njdk16+idea+tomcat8+mysql8.0\n\n\\- **前端**\n\nhtml + css + jsp\n\n\\- **后端**\n\nservlet  + mysql + mavn\n\n## 项目地址\n\nhttp://8.130.89.138:8080/laptopmall/login.jsp\n\n## github仓库\n\n https://github.com/zhazhazhi7/mavenTest\n\n### 需求实现情况&&系统功能\n\n###   一.顾客模块\n\n \n\n1.用户注册：普通用户进入系统如果没有账号需要进行注册。 \n\n​\t1)对于输入的数据进行判断\n\n​\t2)能判断是否重复注册\n\n2.登录网站：登录成功后可以根据关键字搜索商品，可以将商品加入购物车，下单操作。可以查询自己的订单，可以对自己的个人信息进行完善。\n\n  \t1) 未登录的用户将无法进入商城页面，无法进行加入购物车等操作。\n\n  \t2) 登录状态可维持，刷新网页无需重新登录\n\n3.浏览网站内容：\n\n  1) 在主界面用户可以看到商品图片、名称、价格和简单的介绍；\n\n  2) 商品列表内容：商品列表中每一行展示了一个具体商品，点击查看具体信息，同时支持多页查看，鼠标点击下一页即可查看更多商品。\n\n  3) 浏览器发送查询商品的请求，服务器将从数据库中查询到的商品信息返回给浏览器；\n\n  4) 用户点击商品可以看到商品的详细信息，同时可以选择数量，将商品加入购物车。\n\n  5) 将选中的商品加入购物车，商品卡片中展示了商品的详细信息，包括商品图片、描述、价格、数量选择和加入购物车等功能。用户可以在弹窗中选择商品数量，并点击“加入购物车”按钮将商品加入购物车。用户可以在购物车弹窗中查看购物车中的商品信息，并对购物车中的商品进行删除操作。同时，还展示了购物车中所有商品的总价，并提供了结算按钮，用户可以点击结算按钮进行支付操作。\n\n 6)将选中的商品加入购物车，商品卡片中展示了商品的详细信息，包括商品图片、描当用户在购物车内对所选商品进行购买结算后，可在“我的订单”中进行确认。\n\n 7)将选中的商品加入购物车，商品卡片中展示了商品的详细信息，包括商品图片、描 我的订单：点击’我的订单’，可以查询到所有结算后的订单。\n\n 8)将选中的商品加入购物车，商品卡片中展示了商品的详细信息，包括商品图片、描 用户可以看到订单编号，订单总金额，和订单的数量。\n\n9) 用户退出登录\n\n \n\n### 二.商家&&管理员模块\n\n1. **商家申请开店**：由于我们只设定了一个商家，所以这个商家也就是管理员，并无开店功能。\n\n2. **添加商品**\n\n3. **修改商品信息**\n\n4. **删除商品**\n5. **上传图片**\n\n### **四.遇到的问题**（缺陷）\n\n \n\n#### 前端\n\n \n\n1、多浏览器兼容\t\n\n一开始我们的界面根本不能在多个浏览器中展示相同的效果， 为了解决多浏览器兼容的问题， 我们对CSS文件都进行了调整， 在更改CSS参数以及使用bootstrap框架之后， 达到满足所有浏览器浏览效果相同的目的\n\n2、商品数量判断\n\n​\t对商品的下单数没有限制， 后来在jsp中加入了对当前商品数量的判断（商品数量必须小于当前库存数量， 否则不能下单）， 但是我们的商家管理中有一个致命缺陷——新增商品数量没有限制， 会报505溢出错误（商品单价有做限制）。\n\n3、管理员登入\n\n​\t为了提高管理员的安全性，没有单独设计用户管理员的登录界面， 而是使用if-else语句在逻辑中加入了对管理员的账号判断（只有admin账号才能登入商家管理界面）。\n\n\n\n#### 后端\n\n 1、jar包导入问题\n\n​\t由于使用了mavn来作为项目管理工具， 但是jar包被放在根目录下的lib文件夹中， 所以项目并不能被成功访问， 最后的解决方案是在pom.xml中加入了全部的jar包的源， 数据成功传输， 项目被成功访问。\n\n2、传参问题\n\n​\t对于商品的信息以及订单信息 ， 一开始都不能成功传输， 解决方案是使用了list来存储订单信息，商品信息能够被成功展示 。\n\n3、过滤器问题\n\n​\t  为了防止非注册用户（非vip用户）访问商城界面， 我们使用了过滤器来防止用户没有注册登录就访问商城界面， 但是如果直接使用url来访问商品管理界面， 依然可以访问到（但是功能会有缺陷所以不会修改成功），一开始以为是不允许访问界面url中遗漏了商品修改页面 ， 但是加入后这个问题依然没有解决。\n\n4、id精度问题\n\n​\tid直接使用了long型， 且顺序生成（id仅在数据库中使用）， 没有做过多处理， 所以还是有id精度损失的可能。\n\n5、功能没有实现完全\n\n​\t没有成功添加商家开户功能。\n\n#### 数据库\n\n​\t数据库设计中缺失了商家个人信息部分以及开户信息部分， 导致项目功能并不完整。对于id以及用户密码的安全限制， 导致用户密码会缺失， id精度有缺失。\n\n​    "},{"title":"vscode+django搭建自己的个人网站(五)---使用markdown编辑器添加数据以及URL与视图","url":"/2022/10/01/vscode-django搭建自己的个人网站-五-使用markdown编辑器添加数据以及URL与视图/","content":"\n## 前言\n\n​\t虽然我们可以利用后台来添加数据了，但是像文章这样庞大而且已经通过其他编辑器写好的部分想要添加进去还是比较麻烦的，如何在添加的时候像写文章一样方便呢，这里就可以让我们的后台部分也拥有一个富文本编辑器就好啦，不过由于笔者的博客都是用markdown来写的，所以笔者在这里要添加markdown编辑器\n\n## markdown编辑器下载\n\n​\t这里笔者使用的是python自带的markdon编辑器，下载只需要用下面的命令\n\n```python\npip install django-mdeditor\n```\n\n​\t在settings.py配置文件中INSTALLED_APPS中添加mdeditor,在settings.py文件中添加媒体文件的路径配置：\n\n<!--more-->\n\n```python\nINSTALLED_APPS = [\n    'django.contrib.admin',\n    'django.contrib.auth',\n    ...,\n    'mdeditor'\n]\n\nMEDIA_ROOT = os.path.join(BASE_DIR,'uploads')\nMEDIA_URL = '/media/'\n```\n\n​\t修改models.py中要使用markdown文本编辑器的部分，这里我们只有Article表中的body需要使用markdown文本，所以我们修改body的类型\n\n```python\nbody = models.TextField()\n#修改前\nbody = MDTextField()\n#修改后\n```\n\n​\t重新迁移一次我们设计好的数据库，使用下面面命令\n\n```python\npython manage.py makemigration\n\npython manage.py migrate\n```\n\n​\t进入调试后打开浏览器http://localhost:8000/admin/，打开文章后面的添加，发现我们的文章编辑器已经可以使用了。\n\n![image-20220512103716170](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220512103716170.png)\n\n​\t这里虽然已经可以使用markdown编辑器了，但是我们的图片还不能在编辑部份显示，所以我们还需要进行以下设置\n\n打开urls.py文件，在里面修改如下配置\n\n```python\n#myblog/urls.py\n....\nfrom django.urls import path, include, re_path\n#上面这行多加了一个re_path\nfrom django.views.static import serve\n#导入静态文件模块\nfrom django.conf import settings\n#导入配置文件里的文件上传配置\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    ....\n    re_path('^media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT}),#增加此行\n]\n```\n\n配置好之后我们就可以利用markdown编辑器来添加丰富的文章内容了\n\n## URL与视图\n\nDjango中，我们约定URL是在项目同名目录下的urls.py文件里urlpatterns列表构造的。\n\n```python\nmyblog/myblog/urls.py\n```\n\n![image-20220512111442629](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220512111442629.png)\n\n表现形式如下：\n\n```python\nurlpatterns = [\n    path(正则表达式, views视图函数，参数，别名),\n]\n括号里的参数说明：\n1、一个正则表达式字符串\n2、一个可调用对象，通常为一个视图函数或一个指定视图函数路径的字符串\n3、可选的要传递给视图函数的默认参数（字典形式）\n4、一个可选的name参数(别名)\n```\n\n比如我想构造三个URL，网站首页(http://www.sunnydog.cn/)、文章（http://www.sunnydog.cn/Article/）、推荐(http://www.django.cn/tui/)，我们可以这么做.\n\n```python\nurlpatterns = [\n    path('', views.index), #里面留空，代表首页\n    path('Article/',views.news),#news\n    path('tui/',views.bbs),#bbs\n]\n```\n\n​\tURL就是这么构造的，我们的域名www.django.cn不需要写，完整的URL应该要这么写：path(正则表达式, views视图函数，参数，别名), 里面的正则表达式, views视图函数，是必须要写的，而参数，别名是可选的。我们在有特殊需要的时候才写\n\n​\t通过上面我们可以看到，每个URL都对应一个views视图函数名，视图函数名不能相同，否则会报错。视图函数，Django中约定写在APP应用里的views.py文件里。然后在urls.py文件里通过下面的方式导入：\n\n```python\nfrom APP应用名 import views\nfrom APP应用名.vews import 函数名或类名\n```\n\n​\t视图函数是一个简单的Python 函数，它接受Web请求并且返回Web响应。响应可以是一张网页的HTML内容，一个重定向，一个404错误，一个XML文档，或者一张图片. . . 是任何东西都可以。无论视图本身包含什么逻辑，都要返回响应。这个视图函数代码一般约定是放置在项目或应用程序目录中的名为views.py的文件中。\n\nhttp请求中产生两个核心对象：\n1、http请求---->HttpRequest对象，用户请求相关的所有信息（对象）\n2、http响应---->HttpResponse对象，响应字符串\n\n​\t每一个URL都会对应一个视图函数，当一个用户请求访问Django站点的一个页面时，然后就由Django路由系统（URL配置文件）去决定要执行哪个视图函数使用的算法。\n\n​\t通过URL对应关系匹配 ->找到对应的函数（或者类）->返回字符串(或者读取Html之后返回渲染的字符串）这个过程也就是我们Django请求的生命周期。\n\n​\t视图函数，就是围绕着HttpRequest和HttpResponse这两个对象进行的。\n\n## 模板体验\n\n​\tdjango支持传参可以有多种形式，支持python的多种数据类型如：普通变量、列表、字典。虽然变量类型不一样，但是要想传参，他们的操作都是一样的，这里以变量为例：\n\n· 在文件blogproject/urls.py里设置一个URL：\n\n```python\nblogproject/urls.py\nurlpatterns = [\n    ...\n    path('', views.index), \n    #把原来的views.hello修改成views.index  ''留空，表示为首页\n    ...\n]\n```\n\n· 在文件myblog/views.py里添加一个视图函数：\n\n```python\nmyblog/vews.py\n\n#添加一个函数\ndef index(request):\n    #添加两个变量，并给它们赋值\n    sitename = 'Hello'\n    url = 'www.sunnydog.cn'\n    #把两个变量封装到上下文里\n    context = {\n        'sitename': sitename,\n        'url':url,\n    }\n    #把上下文传递到模板里\n    return render(request,'index.html',contex\n```\n\n· 在项目根目录下templates文件夹里新建一个index.html文件，放入下面代码：\n\n```html\ntemplates/index.html\n\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>MyBlog</title>\n</head>\n<body>\n<h3>网站名：{{ sitename }}</h3>\n<h3>域名：{{ url }}</h3>\n</body>\n</html>\n```\n\n​\t启动调试后，在浏览器中访问http://127.0.0.1:8000 就能查看到我们设置的内容\n\n![image-20220512154513817](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220512154513817.png)\n\n​\t以上只是模板的体验，接下来要为了后面的网页创建做准备:\n\n· 首先要在项目文件夹内创建所需的文件夹templates(用来储存所需的前端页面)，statics(用来储存前端html所需的文件)\n\n· 在statics文件下创建所需的文件夹css(储存前端页面所需的css文件),js(储存前端页面所需的jsp文件)，images(储存前端页面所需的图片文件)，plugins(储存前端页面所需的插件)\n\n![image-20220512160048100](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220512160048100.png)\n\n创建好后我们就可以开始利用模板写前端页面了:smiley:\n\n## 前端页面开发分析与准备\n\n​\t对于前端页面的开发更多的需要各位看官对前端的知识更加的了解，但是DJANGO在前端与数据库的参数变量链接的不同，也不得不使我们的前端页面与DJANGO的模板相适应，所以在进行前端部分开发的时候，我们要仔细分析我们的网站组成，从而设计出更加清晰简洁的网页代码来方便我们参数的传入。\n\n​\t对于一个网站来说，一般有两部分在页面中会一直出现，那就是网页的**头部**和**尾部**，头部主要可以为浏览客户提供这个网站的可以提供的信息还有可能提供可以查询的部分，尾部主要提供网站承办方的信息以及联系方式，这两部分很少会出现变动，相当于是静态的，我们可以在剩下的部分进行动态更新。\n\n​\t我们的博客网站需要四个基础网页：**首页index.html（进入网站第一个页面）**、**列表页list.html（显示所有的文章）**、**内容页（查看文章的网页）show.html**、**单页page.html（显示我们个人信息的网页）**，这里所有的网站页面都需要刚刚我们提到的首部与尾部，所以我们可以先创建一个base.html，接下来四个页面直接在中间部分替换，我们可以在中间部分先用下面代码代替页面内容:\n\n```python\n{% block content%}\n{% endblock %}\n```\n\n​\t同时要想在自己的前端页面使用静态文件，我们还需要在文件顶部加上下面代码：\n\n```python\n{% load static %}\n```\n\n**注：这里的代码都不是浏览器可以识别的，所以建议在写好之后准备放入templates文件夹的时候在做修改**\n\n​\tbase.html写好后我们就可以在每页的第一行加上下面代码来继承base.html上的代码：\n\n```python\n{% extends 'base.html'%}\n```\n\n​\t如果在设计中有需要单独添加的部分我们将这部分单独提出来放入html文件，原来位置用下面代码替代：\n\n```python\n{% include 'right.html'%}\n```\n\n​\t网页中所有的静态路径都需要更改应用形式，以下为修改例子：\n\n```html\n修改前\n<link rel=\"stylesheet\" href=\"../static/css/base.css\">\n修改后\n<link rel=\"stylesheet\" href=\"{% static 'css/base.css'%}\">\n```\n\n​\t*除了前端页面需要注意，我们还需要配置项目里的urls.py与views.py.py文件：\n\n· 第一先在views.py中加入每个页面需要的响应函数\n\n· 第二要在urls.py的urlpatterns中对应的path路径：\n\n```python\nmyblog/views.py\n\n#首页\ndef index(request):\n    pass\n\n#列表页\ndef list(request,lid):\n    pass\n\n#内容页\ndef show(request,sid):\n    pass\n\n#标签页\ndef tag(request, tag):\n    pass\n\n# 搜索页\ndef search(request):\n    pass\n# 关于我们\ndef about(request):\n    pass\n```\n\n```python\nmyblog/urls.py\n\nfrom blog import views\n#导入blogAPP下的views\n\nurlpatterns = [\n    path('admin/', admin.site.urls),#管理后台\n    path('', views.index, name='index'),#网站首页\n    path('list-<int:lid>.html', views.list, name='list'),#列表页\n    path('show-<int:sid>.html', views.show, name='show'),#内容页\n    path('tag/<tag>', views.tag, name='tags'),#标签列表页\n    path('s/', views.search, name='search'),#搜索列表页\n    path('about/', views.about, name='about'),#联系我们单页\n    path('ueditor/', include('DjangoUeditor.urls')),\n    re_path('^media/(?P<path>.*)$', serve, {'document_root': settings.MEDIA_ROOT}),\n]\n```\n\n**注：列表页和内容页、标签页面的视图函数我们都多接收了一个参数，与urls.py里的url的参数对应上**\n\n至此，我们的准备工作基本结束，下面只需要对各个页面进行实现。\n\n下面是作者准备完顺便写好了base.html的效果图\n\n```html\ntemplates/base.html\n{% load static %}\n<DOCTYPE html>\n\n<html>\n    <head>\n        <meta charset=\"UTF-8\" />\n        <link rel=\"stylesheet\" href=\"{% static 'css/base.css'%}\">\n        <link rel=\"stylesheet\" href=\"{% static 'css/root.css'%}\">\n    </head>\n    <body>\n        <ul>\n            <li><a href=\"base.html\" class=\"active\">首页</a></li>\n            <li><a herf=#文章 class = ''>文章</a></li>\n            <li><a herf=#分类 class = ''>分类</a></li>\n            <li><a herf=#友情链接 class = ''>友链</a></li>\n            <li style = 'float: right;'><a herf=#联系方式 class = '' >联系方式</a></li>\n            <li style = 'float:right'><button type = 'submit' class = 'base_askbt'><img style = 'width:15px;height:15px' src=\"{% static 'img/base_ask.png'%}\"></button></li>\n            <li style = 'float:right'><input type=\"text\" class=\"base_ask\" placeholder=\"请输入关键字\"></li>\n        </ul>\n\n        {{添加显现代码}}\n\n        <div class = 'root_head'></div>\n        <div class='root_foot'>\n            <div class = 'me'>\n                <span>欢迎来到SunnyDog的博客</span>\n            </div>\n            <div class = 'me' style = 'padding:10px 10px;'>\n                <img src=\"{% static 'img/me1.png'%}\">\n                <img src=\"{% static 'img/me2.png'%}\">\n            </div>\n            <div class = 'me' style = 'padding:10px 10px;'>\n                <span>欢迎合作</span>\n                <a href=#联系我们>\n                    <img style = 'width:15px;height:15px' src=\"{% static 'img/invent.png'%}\">\n                </a>\n                <span>|</span>\n                <span>联系我们</span>\n                <a href=#联系我们>\n                    <img style = 'width:15px;height:15px' src=\"{% static 'img/root_foot.png'%}\">\n                </a>\n            </div>\n        </div>\n    </body>\n</html>\n```\n\n![image-20220513195232315](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220513195232315.png)\n\n之后大家就可以按照自己的审美与个性对前端页面进行设计啦！！！"},{"title":"vscode+django搭建自己的个人网站(四)---利用ORM创建数据库模型并建立后 台管理","url":"/2022/10/01/vscode-django搭建自己的个人网站-四-利用ORM创建数据库模型并建立后-台管理/","content":"\n## 前言\n\n​\tDJANGO通过model操作数据库，不管数据库的类型是mysql还是sqllite3都可以通过models来建立，models中的封装了对应的SQL语句，所以创建查询等操作都十分的方便，但是利用ORM 有一个很大的弊端，那就是数据库的SQL语句会很少使用，所以笔者在这里只做前期的使用，未来可能会用sql语句来代替。\n\n​\t每一个网站都会有自己的一个或者多个管理后台，网页中可以看到的数据如果使用html全部重新写一遍的话不仅费时间有时候也并没有什么意义，所以我们的博客网站页一定需要后台来方便我们管理网站并添加数据。\n\n## ORM创建数据库\n\nDJANGO中的模型基本原则如下：\n\n· 每个模型在django中存在形式为一个python类\n\n· 每个模型都是django.db.models.Model的一个子类\n\n· 模型里的每一个类都代表数据库中的一个表\n\n· 模型的每个字段（属性）代表数据表中的一个列\n\n· DJANGO会为你自动生成数据库访问的API\n\n接下来我们按照之前对数据结构的分析对数据进行创建，打开blogproject/blogproject/model.py\n\n<!--more-->\n\n#### 分类表\n\n表名:Category、分类名：name\n\n| 表字段 | 字段类型              | 备注                           |\n| ------ | --------------------- | ------------------------------ |\n| id     | INTEGER类型，长度为11 | 主键，表示文章，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 分类名                         |\n\n在model.py文件中写入：\n\n```python\n#文章分类\nclass Category(models.Model):\n    name = models.CharField('博客分类',max_length = 100)\n    index = models.IntegerField(default = 999,verbose_name)\n    \n    class Meta:\n       verbose_name = '博客分类'\n       verbose_name_plural = verbose_name\n\t\n    def __str__(self):\n        return self.name\n```\n\n#### 标签表\n\n表名Tag、分类名：name\n\n| 表字段 | 字段类型              | 备注                 |\n| ------ | --------------------- | -------------------- |\n| id     | INTEGER类型，长度为11 | 主键，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 文章的标签名         |\n\n在model.py文件中写入：\n\n```python\n#文章标签\nclass Tag(models.Model):\n    name = models.CharField('文章标签',max_length = 100)\n    index = models.IntegerField(default = 999, verbose_name = '分类排序')\n    \n    class Meta:\n       verbose_name = '文章标签'\n       verbose_name_plural = verbose_name\n\t\n    def __str__(self):\n        return self.name\n```\n\n#### 推荐表\n\n表名Tui,分类名：name\n\n| 表字段 | 字段类型              | 备注                 |\n| ------ | --------------------- | -------------------- |\n| id     | INTEGER类型，长度为11 | 主键，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 标签名               |\n\n在model.py文件中写入：\n\n```python\nclass Tui(models.Model):\n    name = models.CharField('推荐位',max_length = 100)\n    index = models.IntegerField(default = 999, verbose_name = '分类排序')\n    \n    class Meta:\n       verbose_name = '推荐位'\n       verbose_name_plural = verbose_name\n\t\n    def __str__(self):\n        return self.name\n```\n\n#### 文章表\n\n表名Article，分类名：title\n\n| 表字段       | 字段类型               | 备注                                 |\n| ------------ | ---------------------- | ------------------------------------ |\n| id           | INTEGER类型，长度为11  | 主键，有系统自动生成                 |\n| title        | VARCHAR类型，长度为100 | 文章标题                             |\n| category     | FOREIGNKEY             | 外键，关联文章分类表                 |\n| tags         | MANYTOMANYFIELD        | 多对多，关联标签列表                 |\n| body         | TEXTFIELD              | 文章内容                             |\n| user         | FOREIGNKEY             | 外键，文章作者关联用户模型，系统自带 |\n| views        | POSTIVEINTEGERFIELD    | 文章浏览数，正的整数，不能为负       |\n| tui          | FOREGNKEY              | 外键，关联推荐位表                   |\n| creates_time | DATETIMEFIELD          | 文章发布时间                         |\n\n在model.py文件中写入：\n\n```python\nclass Article(models.Model):\n    title = models.CharField('标题',max_length = 70)\n    excerpt = models.TextField('摘要',max_length = 200,blank = True)\n    category = models.ForeignKey(Category, on_delete = models.DO_NOTHING,verbose_name = '分类',blank = True,null = True)\n    #使用外键关联分类表与分类是一对多关系\n    tags = models.ManyToManyField(Tag,verbose_name = '标签',blank = True)\n    #使用外键关联标签表与标签是多对多关系\n    img = models.ImageField(upload_to='article_img/%Y/%m/%d/',verbose_name = '文章图片',blank = True, null = True)\n    body = MDTextField()\n    user = models.ForeignKey(User,on_delete=models.CASCADE,verbose_name = '作者')\n    '''\n    文章作者，这里User是从django.contrib.auth.models导入的\n    这里通过ForeignKey 把文章与User关联了起来\n    '''\n    views = models.PositiveIntegerField('阅读量',dafult = 0)\n    tui = models.ForeignKey(Tui,on_delete = models.DO_NOTHING,verbose_name = '推荐位',blank = True,null = True)\n\n    created_time = models.DateTimeField('发布时间',auto_now_add = True)\n    modified_time = models.DateTimeField('修改时间',auto_now = True)\n    \n    class Meta:\n       verbose_name = '文章'\n       verbose_name_plural = '文章'\n\t\n    def __str__(self):\n        return self.title\n```\n\n这里的img中的upload_to = 'article_img/'是指向了图片的上传目录，'%Y/%m/%d/'是自动在上传图片时加上上传时间\n\n**注：这里的body的类型是MDTextField，这是因为笔者后面需要markdown来写文章，这样的话会更加方便**\n\n#### 轮播图表\n\n表名Banner，分类名text_info\n\n| 表字段    | 字段类型             | 备注                                  |\n| --------- | -------------------- | ------------------------------------- |\n| id        | INTEGER类型，字长11  | 主键，由系统自动生成                  |\n| text_info | VARCHAR类型，字长100 | 标题，存储图片信息                    |\n| img       | IMAGE类型            | 图片类型，保存传图片的类型            |\n| link_url  | URLFIELD类型         | 图片链接的URL                         |\n| is_active | BOOLEANFIELD         | 有TRUE和FALSE两个类型，意思为是否激活 |\n\n在model.py文件中写入：\n\n```python\nclass Banner(models.Model):\n    text_info = models.CharField('标题',max_length=50,default = '')\n    img = models.ImageField('轮播图',upload_to = 'banner/')\n    link_url = models.URLField('图片链接',max_length = 100)\n    is_active = models.BooleanField('是否是active',default = False)\n\n    def __str__(self):\n        return self.text_info\n    \n    class Meta:\n        verbose_name = '轮播图'\n        verbose_name_plural = '轮播图'\n```\n\n这里的img中的upload_to = 'banner/'是指向了图片的上传目录\n\n#### 友情链接表\n\n表名Link，分类名name\n\n| 表字段  | 字段类型             | 备注                |\n| ------- | -------------------- | ------------------- |\n| id      | INTEGER类型          | 主键,由系统自动生成 |\n| name    | VARCHAR类型,长度为70 | 友情链接的名称      |\n| linkurl | URLFIELD类型         | 友情链接的URL       |\n\n在model.py文件中写入：\n\n```python\nclass Link(models.Model):\n    name = models.CharField('链接名称',max_length = 20)\n    linkurl = models.URLField('网址',max_length = 100)\n\n    def __str__(self):\n        return self.name\n    \n    class Meta:\n        verbose_name = '友情链接'\n        verbose_name_plural = '友情链接'\n```\n\n这里我们只是创建了数据库的模型代码，真正的数据库创建还需要我们来进行数据库迁移\n\n等所有的表都建立完成，接下来只要利用命令将数据库进行迁移即可：\n\n```python\npython manage.py makemigrations\npython manage.py migrate\n```\n\n**注：在运行第一个命令之后，blogproject/migrations目录会自动生成几个000开头的文件，这里是数据库迁移的记录，而且支持手动更改，正真的数据库的创建是第二句命令**\n\n在这里可能会出现一些错误\n\n笔者这里出现以下报错\n\n```python\nSystemCheckError: System check identified some issues:\n\nERRORS:\nmyblog.Article.img: (fields.E210) Cannot use ImageField because Pillow is not installed.\n        HINT: Get Pillow at https://pypi.org/project/Pillow/ or run command \"python -m pip install Pillow\".\n```\n\n原因是图片上传需要Pillow模块的支持，所以可以执行下面语句下载Pillow模块，完成后再执行语句即可成功\n\n```python\npip install Pillow\n```\n\n这是运行第一个命令后的效果\n\n![image-20220511122129783](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220511122129783.png)\n\n这是运行第二个命令后的效果\n\n![image-20220511122333054](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220511122333054.png)\n\n这样我们的数据库终于成功创建啦:smile_cat:，接下来就可以使用后台来操作数据库啦\n\n## 建立后台管理\n\n数据库管理在django有多种方式\n\n一、直接使用mysql语句在mysql终端管理数据\n\n二、使用vscode的扩展插件管理（扩展见文章一）\n\n三、使用django的后台管理数据\n\n由于django有非常强大的后台可以直接配置使用，而且在日常的网站护理中也都会直接使用后台来管理，所以这里我们也要建立后台管理来方便我们以后的网站维护与作品发布。\n\n最基本的前提是要先在settings.py里对其进行注册，就是在INSTALLED_APPS里把APP名添加进去(详见文章3)，实际上admin是已经注册好的\n\n然后我们需要在自己APP文件夹中的admin.py文件中对数据表做注册，代码如下：\n\n```python\nfrom .models import Banner, Category, Tag, Tui, Article, Link \n#导入需要管理的数据库表\n\n@admin.register(Article)\nclass ArticleAdmin(admin.ModelAdmin):\n    list_display = ('id', 'category', 'title', 'tui', 'user', 'views', 'created_time')\n    # 文章列表里显示想要显示的字段\n    list_per_page = 50\n    # 满50条数据就自动分页\n    ordering = ('-created_time',)\n    #后台数据列表排序方式\n    list_display_links = ('id', 'title')\n    # 设置哪些字段可以点击进入编辑界面\n\n\n\n@admin.register(Banner)\nclass BannerAdmin(admin.ModelAdmin):\n    list_display = ('id', 'text_info', 'img', 'link_url', 'is_active')\n\n@admin.register(Category)\nclass CategoryAdmin(admin.ModelAdmin):\n    list_display = ('id', 'name', 'index')\n\n@admin.register(Tag)\nclass TagAdmin(admin.ModelAdmin):\n    list_display = ('id', 'name')\n\n@admin.register(Tui)\nclass TuiAdmin(admin.ModelAdmin):\n    list_display = ('id', 'name')\n\n@admin.register(Link)\nclass LinkAdmin(admin.ModelAdmin):\n    list_display = ('id', 'name','linkurl')\n```\n\n然后我们需要给自己注册管理员账号，激活管理工具\n\n通过下面命令即可设置账号密码\n\n```python\npython manage.py createsuperuser\n```\n\n**注：这里密码太短太简单都会提醒你重设**\n\n打开调试后在浏览器登录网址http://localhost:8000/admin/就能登录进入后台啦\n\n![image-20220511124505182](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220511124505182.png)\n\n![image-20220511124636109](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220511124636109.png)"},{"title":"vscode+django搭建自己的个人网站(三)---创建应用以及基础配置","url":"/2022/10/01/vscode-django搭建自己的个人网站-三-创建应用以及基础配置/","content":"\n## 前言\n\n​\t创建好了数据库之后,接下来就要创建应用来开始创建自己的博客项目啦.\n\n​\t但是创建过程中会需要大量的用到项目中的setting.py文件来进行各种相关配置,所以了解DJANGO的配置文件也是十分必要的.\n\n​\t由于现在大家都在使用mysql数据库来做配置,但是DJANGO却自带了sqllite3数据库,而数据库的转换操作会比较麻烦,所以最后还会利用配置文件来提前修改数据库配置,便于我们后面的数据插入\n\n## 创建应用\n\n​\t之前笔者创建的blogproject项目只是由DJANGO快速搭建的框架,目录下的文件都是可以自定义的配置文件,而正真创建我们自己的项目,就离不开创建自己的应用了\n\n​\t在vscode中我们可以选中blogproject文件夹右键,选择在终端打开,这个时候只要输入下面的命令就能快速创建我们的APP项目了:\n\n<!--more-->\n\n```python\npython manage.py startapp APP项目名称\n```\n\n**注:这里要注意我们是在之前搭的的虚拟终端之中,所以用vscode下部的终端就好(这里笔者将应用起名为myblog)**\n\n![image-20220510163413459](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220510163413459.png)\n\n当然,除了使用终端命令快速搭建以外,我们也可以选择手动来搭建自己需要的结构,应用的部分目录大概如下\n\n```python\n| --blogproject\n|\t| --__init__.py\n|\t| --asgi.py\n|\t| --settings.py\n|\t| --urls.py\n|\t| --wsgi.py\n| --myblog\n|\t| --__init__.py\n|\t| --adimn.py\n|\t| --apps.py\n|\t| --models.py\n|\t| --tests.py\n|\t| --views.py\n| --manage.py\n```\n\n创建成功后我们就可以开始自己博客的搭建之旅啦:smile:\n\n**注:这里的blogproject/myblog与blogproject/blogproject文件是并列的不是包含关系,文件中的venv文件夹是虚拟环境所需文件,与项目无关**\n\n## 基础配置\n\n前面说过我们会大量用到配置文件,并且我们在项目配置好后还需要对配置文件进行配置\n\n打开blogproject/blogproject下的setting.py文件.\n\n一 设置域名的访问权限\n\n```python\nblogproject/blogproject/setting.py\nALLOWED_HOSTS = [] #修改前\nALLOWED_HOSTS = ['*'] #修改后,表示任何域名都能访问\n```\n\n二 设置模板路径\n\n设置TEMPLATES里的\"DIRS\",添加模板目录到templates的路径,后面用得着\n\n```python\nblogproject/blogproject/settings\n\n'DIRS': [], #修改前\n'DIRS': [os.path.join(BASE_DIR,'templates')], #修改后\n#这里使用pycharm的话会自动添加\n```\n\n**注:os模块需要导入,要在setting.py文件顶加入**\n\n```python\nimport os\n```\n\n三 在INSTALLED_APPS添加APP应用名称\n\n```python\nblogproject/blogproject/setting.py\n\nINSTALLED_APPS = [\n\t\t'django.contrib.admin',\n\t\t...\n\t\t'myblog.apps.BlogConfig' #注册APP应用\n]\n```\n\n四 修改项目语言和时区\n\n```python\nblogproject/blogproject/setting.py\n#修改语言\nLANGUAGE_CODE = 'en-us' #修改前为英文\nLANGUAGE_CODE = 'zh-hans' #修改后为中文\n#修改时区\nTIME_ZONE = 'UTC' #修改前\nTIME_ZONE = 'Asia/shanghai' #修改后\n```\n\n点击调试后,利用浏览器登录网址就可以看见部分修改了的配置了,所用的setting.py中的提前配置主要是这些,下面还有比较主要的数据库的配置\n\n## 数据库配置mysql\n\n​\t配置mysql数据库首先需要下载并安装配置mysql数据库,这里不做赘述,最好可以将mysql配置环境变量来方便我们的使用.\n\n​\t在vscode中使用mysql需要使用扩展插件,在vscode左边栏中找到扩展,搜索mysql就有很多插件可以使用,这里笔者使用的是其中一款\n![image-20220510191321578](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220510191321578.png)\n\n使用也很方便,只要下载后重新打开vscode就能在左边栏找到插件,在里面进行连接就可以,这里的操作在插件就有介绍.\n\n​\t提前利用终端创建数据库之后就可以在插件里连接并使用了,所有的数据库操作既可以在数据库,python mysqlclient模块操作,也可以在插件生成的sql文件中操作.\n\n​\t接下来就要配置文件中修改配置了,在settings.py文件中找到\n\nDATABASE,修改如下:\n\n```python\nblogproject/blogproject/settings.py\n\nDATABASES = {\t#修改后\n    'default': {\n        'ENGINE': 'django.db.backends.sqlite3',\n        'NAME': os.path.join(BASE_DIR,'db.sqllite'),\n    }\n}\n\nDATABASES = {\t#修改后\n    'default': {\n        'ENGINE': 'django.db.backends.mysql',\n        'NAME': 'blog',\n        'USER':'root',\n        'PASSWORD':'123456',\n        'HOST':'localhost',\n        'PORT':'3306'\n    }\n}\n```\n\n最后删去文件夹中的db文件\n\n修改之后就可以在项目里面使用mysql了,接下来只要按照前一篇的分析创建数据库就可以了.\n\n**注:这里的数据库可能需要提前在终端创建再连接插件**"},{"title":"vscode+django搭建自己的个人网站(二)---具体需求分析与数据库结构分析","url":"/2022/10/01/vscode-django搭建自己的个人网站-二-具体需求分析与数据库结构分析/","content":"\n## 前言\n\n​\t搭建一个网站需要先对网站的结构进行分析，一遍我们对后面的页面关系创建和数据库关系的创建进行更清晰的分析。\n\n​\t首先我们先对我们博客网站的需求进行分析。blog的功能比较简单，主要以个人的文章为主。\n\n## 需求分析\n\n从**功能需求**来看，这个blog的功能有：网站首页、文章分类、文章内容、幻灯图片、文章推荐、文章排行、热门推荐、文章搜索、友情链接。\n\n·**网站首页**：网站首页是整个网站的主页面，也是网站的入口界面，里面主要是展示blog的动态信息以及blog的功能导航。网站动态信息主要以文章为主，如新文章、幻灯图片、推荐阅读、文章排行、热门推荐、友情链接等。导航栏主要是将文章的分类的链接展示在首页，方便用户浏览。\n\n<!--more-->\n\n·**文章分类**：主要展示文章分类信息以及链接，方便用户按需要查看。文章分类可以在文章的后台删除。\n\n·**文章内容**：主要展示文章索树分类、文章索树标签、文章内容、作者信息、发布的时间信息。可以通过后台增、删改等操作。\n\n·**幻灯图片**：在网站首页，通过图片和文字展示一些重要信息，可以通过后台添加图片、图片描述、图片链接。\n\n·**文章推荐**：推荐一些重要的文章，可以在后台推荐\n\n·**文章排行**：可以根据文章浏览数，按时间段进行查询，然后展示出来。具体还可以根据自己的需求更改。\n\n·**热门推荐**：与文章排行文章推荐相同\n\n·**文章搜索**，通过关键词搜索文章\n\n·**友情链接**：展示相互链接的网站的名称与链接，可以通过后台增加或者删除\n\n·**单页面**：展示网站介绍，作者的联系方式等信息，此类信息不经常变动，可以通过后台实现更改，也可以通过模板实现更改\n\n了解需求之后，就由UI设计师根据网站需求来设计网站页面，然后由前端工程师根据设计好的页面进行切图，实现HTML静态页面，最后由后端根据HTML页面和需求实现数据库构建和网站后台开发，不过自己的博客当然需要自己全部来设计完成。\n\n从**设计的方面**来看，blog主要分为六个页面：网站首页、文章分类列表页、文章内容页、搜索列表页、标签列表页、单页面\n\n## 数据库设计分析\n\n​\t从网站需求分析及网站功能、页面设计可以知道，我们的Blog主要以文章内容为主。所以我们在设计数据库的时候，我们主要以文章信息为核心数据，然后逐步向外扩展相关联的数据信息。\n\n​\t这其中，**文章与分类**的关系是一对多的关系，什么是一对多？就是一篇文章只能有一个分类，而一个分类里可以有多篇文章。**文章与标签**的关系是多对多的关系，多对多简单理解就是，一篇文章可以有多个标签，一个标签里同样可以有多篇文章\n\n​\t首先，我们先分析我们想要的文章页面内包含哪些信息，将文章的表命名为Article，通过前面的分析列出下面的表：\n\n| 表字段       | 字段类型               | 备注                                 |\n| ------------ | ---------------------- | ------------------------------------ |\n| id           | INTEGER类型，长度为11  | 主键，有系统自动生成                 |\n| title        | VARCHAR类型，长度为100 | 文章标题                             |\n| category     | FOREIGNKEY             | 外键，关联文章分类表                 |\n| tags         | MANYTOMANYFIELD        | 多对多，关联标签列表                 |\n| body         | TEXTFIELD              | 文章内容                             |\n| user         | FOREIGNKEY             | 外键，文章作者关联用户模型，系统自带 |\n| views        | POSTIVEINTEGERFIELD    | 文章浏览数，正的整数，不能为负       |\n| tui          | FOREGNKEY              | 外键，关联推荐位表                   |\n| creates_time | DATETIMEFIELD          | 文章发布时间                         |\n\n文章关联了一个分类表，将这个表命名为category,category表的结构如下：\n\n| 表字段 | 字段类型              | 备注                           |\n| ------ | --------------------- | ------------------------------ |\n| id     | INTEGER类型，长度为11 | 主键，表示文章，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 分类名                         |\n\n文章关联了一个标签表，命名这个表为tag，这个表的结构如下：\n\n| 表字段 | 字段类型              | 备注                 |\n| ------ | --------------------- | -------------------- |\n| id     | INTEGER类型，长度为11 | 主键，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 文章的标签名         |\n\n文章关联推荐位表，这里命名为tui，这个表的结构如下：\n\n| 表字段 | 字段类型              | 备注                 |\n| ------ | --------------------- | -------------------- |\n| id     | INTEGER类型，长度为11 | 主键，由系统自动生成 |\n| name   | VARCHAR类型，长度为30 | 标签名               |\n\n除了文章以外，我们还需要两个与之前没有关联的表，第一个是幻灯片图表，命名为banner，数据库结构如下：\n\n| 表字段    | 字段类型             | 备注                                  |\n| --------- | -------------------- | ------------------------------------- |\n| id        | INTEGER类型，字长11  | 主键，由系统自动生成                  |\n| text_info | VARCHAR类型，字长100 | 标题，存储图片信息                    |\n| img       | IMAGE类型            | 图片类型，保存传图片的类型            |\n| link_url  | URLFIELD类型         | 图片链接的URL                         |\n| is_active | BOOLEANFIELD         | 有TRUE和FALSE两个类型，意思为是否激活 |\n\n第二个为友情链接表，命名为link，结构如下：\n\n| 表字段  | 字段类型             | 备注                |\n| ------- | -------------------- | ------------------- |\n| id      | INTEGER类型          | 主键,由系统自动生成 |\n| name    | VARCHAR类型,长度为70 | 友情链接的名称      |\n| linkurl | URLFIELD类型         | 友情链接的URL       |\n\n目前,需要的数据库大概已经完全了解了,但是DJANGO自带了SQLLITE3数据库,可是笔者觉得目前更适合MYSQL数据库使用,所以在了解了配置文件的使用后决定更换数据库"},{"title":"vscode+django搭建自己的个人网站(一)---环境搭建与配置","url":"/2022/10/01/vscode-django搭建自己的个人网站-一-环境搭建与配置/","content":"\n## 前言\n\n​\t相对于pycharm，vscode更加的灵活快速，对于小型的项目来说算是一个很好的选择，所以笔者选择使用vscode来搭建django框架实现的个人博客。\n\n​\tdjango 是python下的框架，虽然在国内大多都在使用其他大家耳熟能详的java或者php框架，但是django框架更加适合一些处理数据为主的网站（不以观赏为主的网站），当然，国外有许多知名网站也在使用django框架来搭建。\n\n## 环境搭建\n\n<!-- more -->\n\n### 安装\n\n·配置django\n\n安装django只需要打开cmd ，运行以下命令 ：\n\n```python\npip install django\n```\n\n·创建项目\n\n选择一个自己喜欢的文件夹来保存自己的项目，并在cmd中用绝对路径打开这个项目\n\n```python\ncd 项目文件的绝对路径\n```\n\n·创建一个django项目\n\n利用以下命令在选择的路径下创建一个django项目\n\n```python\ndjango-admin startproject 项目名称\n```\n\n·为django创建一个虚拟环境\n\n```python\ncd 项目名称\npython -m venv venv\n```\n\n·笔者在这里的项目名称为blogproject\n\n### 配置问题\n\n接下来在vscode中对django 进行配置\n\n·关闭vscode，重新从项目的文件夹打开\n\n·利用快捷键ctrl +shift +P 搜索python解释器，在解释器下面选择自己的虚拟环境，之后便可以在左下角看到自己的运行环境，虚拟环境有('venv')的标志，具体如图所示\n\n·打开vscode的终端（快捷键ctrl+shift+`）,选择cmd运行环境\n\n·完成后再建一个终端就可以运行虚拟环境了\n\n\n\n·因为是虚拟环境，所以之前下载的python模块包都不能使用了，需要重新下载，包括django，需要在vscode的虚拟环境中运行以下命令来下载\n\n```python\npip install django\n```\n\n![image-20220509170912959](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220509170912959.png)\n\n·安装好后就可以尝试运行了，在运行前需要创建vscode必备\n\n的launch.json\n\n![1-2](F:\\Typora\\Typora\\md\\PY\\picture\\1-2.png)\n\n·开始运行后，在浏览器中输入http://127.0.0.1:8000/，或者输入http://localhost:8000/就可以看到运行成功的网页了\n\n下一步我们可以开始搭建自己的网页了\n\n![image-20220509171643224](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220509171643224.png)\n\n![image-20220509171712192](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220509171712192.png)\n\n### 出现的错误\n\n·笔者在配置vscode必备launch.json文件的时候遇到了配置之后无法成功运行的情况，报错为：no such files...(具体包错忘了，大概意思是找不到manage.py文件)，这里咱可以回头查看manage.py文件的位置，由于运行需要的是绝对路径，在launch.json文件中改变program后面的路径即可。\n\n![image-20220509172427264](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220509172427264.png)\n\n·每次想要查看配置好的页面的时候都要在运行调试里面进行运行，同时，每次运行查看完成后一定记得点击vscode中的顶部的红色方框来关闭。"},{"title":"微信小程序开发实例(二)——静态投票小程序","url":"/2022/09/05/微信小程序开发实例-二-——静态投票小程序/","content":"\n# 开发投票程序的首页\n\n## 小程序的初始配置\n\n​\t为了小程序能够运行起来，需要在app.js中加入注册小程序的逻辑。内容如下：\n\n```java\nAPP({\n    onLauch(){\n        // 小程序的生命周期函数onlaunch，小程序启动时会调用它。\n    }\n})\n```\n\n​\t在app.json中需要设置小程序的页面路径。内容如下：\n\n<!-- more -->\n\n```java\n{\n    \"pages\":[\n        \"pages/index/index\"\n    ]\n}\n```\n\n​\t在pages/index/index.js中加入页面的注册逻辑。内容如下：\n\n```java\nPage({\n    onLoad(){\n        //页面生命周期函数onLoad,进入页面时会调用它\n    }\n})\n```\n\n​\t在pages/index/index.json中加入一个空的配置。内容如下：\n\n```java\n{}\n```\n\n​\t加入了以上代码后，小程序就有了一个页面，并且可以在模拟器中正常运行起来了。现在这个小程序还没有任何内容，可以在pages/index/index.wxml中为它先增加一个view组件，作为最外层的视图内容组件。代码如下：\n\n```php+HTML\n<! -- 一般每一个页面的最外层都用一个view组件包装起来-- >\n```\n\n​\t接下来对小程序的页面进行一些配置。在app.json中加入小程序导航栏的设置。修改后内容如下：\n\n```java\n{\n    \"pages\":[\n        \"pages/index/index\" \t//指定小程序首页的页面路径\n    ],\n    \"window\":{\n    \"backgroundTextStyle\":\"light\", // 全局指定下\n    \"navigationBarBackgroundColor\": \"#fff\",\n    \"navigationBarTitleText\": \"投票小程序\",\n    \"navigationBarTextStyle\":\"black\"\n  },\n}\n```\n\n**注：JSON文件中实际上不支持加入注释**\n\n​\t在app.wxss中加入小程序的全局样式，内容如下：\n\n```css\npage{\n    /* 设置page高度为100%*/\n    height:100%;\n}\n.container{\n    /*一般会把每个页面的最外层view组件的class设置为container,\n    \t在这里把高度设置为100%,表示占满整个页面\n    */\n    height:100%;\n}\n```\n\n​\t这个页面暂时什么都没有，但是我们可以修改index.json文件的内容，单独指定首页的导航栏的内容。\n\n```java\n{\n  \"usingComponents\": {},\n  \"navigationBarTitleText\": \"投票小程序-首页\" //导航栏的文字内容\n}\n```\n\n## 开发初始页面布局\n\n​\t接下来要在首页添加内容。首页中加入按钮：\n\n```html\n<view class=\"container\">\n    <view class=\"btn\">单选投票</view>\n    <view class=\"btn\">多选投票</view>\n</view>\n```\n\n​\t一般每个页面的最外层都用一个view组件包装起来，并且这个view组件的class被设置为\n\ncontainer。这样组件就会使用app.wxss中设置好的样式高度设置为100%，占满整个屏幕。\n\n​\t在页面单独的wxss中，如果为container这个class设置样式，那么在页面中class为container的view 组件就会加入页面的特有样式,其他页面的container则不会受到影响。这里在pages/index/index.wxss中添加页面样式，将页面美化。\n\n```css\n.container{\n  display: flex;/*使用flex布局*/\n  flex-direction: column;/*设置布局方向为纵向*/\n  justify-content: center;/*在布局方向上居中*/\n}\n\n.btn{\n  margin: 20rpx;\n  padding: 10rpx;\n  border:1rpx solid #26ab28;\n  border-radius: 20rpx;\n  text-align:center;\n  color: #26ab28;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n```\n\n## 使用image图片组件\n\n​\t我们可以增加image组件插入一些图片来丰富图片内容。image组件通常不包含内容，因此使用单标签的形式，代码如下：\n\n```xml\n<image src=\"...\" />\n```\n\n​\timage组件有三个常用的属性：src、mode和lazy-load。**其中src指定图文件的路径，mode指定图片的显示模式，两个属性都是string类型。lazy-load是boolean类型的属性，默认为false，如果设置为true就会开启懒加载模式**\n\n​\t使用image组件时，一般会在样式文件中指定特定的大小，这样image组件的大小就会和原始的图片不一样，需要进行缩放或者裁剪。mode属性就是用来指定图片如何缩放或者\n\n裁剪的属性。mode属性的显示模式一共13种，其中4种是缩放模式，9种是裁剪模式，它们的取值和效果说明如下：\n\n| 模式类型 | 值          | 说 明                                                        |\n| -------- | ----------- | ------------------------------------------------------------ |\n| 缩放     | scaleToFill | 不保持纵横比放缩图片，使图片的宽高能完全拉伸至填满image元素  |\n| 缩放     | aspectFit   | 保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说可以完整的将图片显示出来 |\n| 缩放     | aspectFill  | 保持纵横比缩放图片，只保证图片的短边能完整显示出来，也就是说图片通常只在水平或者垂直方向是完整的，另一个方向将会将会法神截取 |\n| 缩放     | widthFix    | 宽度不变，高度自动变化，保持原图的宽高比不变                 |\n\n| 模式类型 | 值           | 说 明                                                        |\n| -------- | ------------ | ------------------------------------------------------------ |\n| 裁剪     | top          | 保持原始图片的大小，如果超出image区域，只显示图片的顶部区域  |\n| 裁剪     | bottom       | 保持原始图片的大小，如果超出image区域，只显示图片的底部区域  |\n| 裁剪     | center       | 保持原始图片的大小，如果超出image区域，只显示图片的中间区域  |\n| 裁剪     | left         | 保持原始图片的大小，如果超出image区域，只显示图片的左边区域  |\n| 裁剪     | right        | 保持原始图片的大小，如果超出image区域，只显示图片的右边区域  |\n| 裁剪     | top left     | 保持原始图片的大小，如果超出image区域，只显示图片的左上边区域 |\n| 裁剪     | top right    | 保持原始图片的大小，如果超出image区域，只显示图片的右下边区域 |\n| 裁剪     | bottom left  | 保持原始图片的大小，如果超出image区域，只显示图片的左下边区域 |\n| 裁剪     | bottom right | 保持原始图片的大小，如果超出image区域，只显示图片的右下边区域 |\n\n​\t在项目新建一个imgs目录，用来放置需要的图片文件，\n\n​\t有了图片文件，就可以在WXML文件中加入image组件了。代码如下：\n\n```xml\n<view class = \"btn\" bindtap=\"onTapCreateRadioVote\">\n    <image class=\"btn-img\" src=\"/pages/imgs/单选选中.png\" mode=\"widthFix\"></image>\n    <text class = \"btn-text\">单选投票</text>\n</view>\n```\n\n​\t接下来还需要修改pages/index/index.wxss文件中的内容，为图片组件增加样式。wxss文件中新增的代码如下：\n\n```css\n.btn{\n  margin: 20rpx;\n  padding: 10rpx;\n  border:1rpx solid #26ab28;\n  border-radius: 20rpx;\n  text-align:center;\n  color: #26ab28;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.btn-img{\n  width:50rpx;\n  margin-right: 30rpx;\n}\n```\n\n​\t加入了image组件的首页就比刚才更好了一些。\n\n## 使用text文本文件\n\n​\t在首页的wxml代码中，按钮上面的“单选投票”和“多选投票”文字是直接包含在class为btn的view组件中的。如果想要修改文字样式，这个例子中就可以对btn添加样式设置。当前view组件中有多段文字时，如果只想修改文字的样式，在这个例子中就可以对btn添加样式设置。当前view组件有多段文字时，如果只想修改其中一段文字的样式，那么就需要在这段文字的外面再包含一个组件，通常使用text组件包装文字内容。以“单选投票”按钮为例，代码如下：\n\n```html\n<view class = \"btn\" bindtap=\"onTapCreateRadioVote\">\n    <image class=\"btn-img\" src=\"/pages/imgs/单选选中.png\" mode=\"widthFix\"></image>\n    <text class = \"btn-text\">单选投票</text>\n    <text class = \"btn-desc\">创建一个单选投票</text>\n  </view>\n```\n\n​\t这样就可以在wxss文件中为btn-txt和btn-desc分别添加样式了，加入如下代码：\n\n```css\n.btn-desc{\n  font-size: 10pt;\n  margin-left: 25rpx;\n}\n```\n\n# 开发创建页面\n\n​\t创建的投票页面一共两个：一个是创建单选投票的页面；另一个是创建多选投票的页面。本节中，我们先来实现创建单选投票的页面，然后创建多选投票的页面。\n\n​\t用户在创建投票的页面中填写投票内容，然后单击“提交”按钮将它保存。通常这类让用户填写信息的并提交的页面称为“表单页面”。表单中的主要包括输入框，选择器和开关组件，这类让用户填写内容的组件被称为“表单组件”。\n\n## 创建小程序的第二个页面\n\n​\t开发一个新的页面前需要先在项目中创建相关的文件。首先在app.json文件的pages属性中申明第二个页面。代码如下：\n\n```json\n\"pages\":[\n    \"pages/index/index\",\n    \"pages/createVote/createVote\"\n  ],\n```\n\n​\t保存后，微信开发者工具会自动创建出这个页面的四个文件\n\n​\t修改createVote.json文件，将这个页面的标题设置为“创建单选投票”。代码如下：\n\n```json\n{\n  \"usingComponents\": {},\n  \"navigationBarTitleText\": \"创建投票\"\n}\n```\n\n​\t现在小程序项目中已经有了两个页面，但是两个页面之间还不能互相跳转，所以在模拟器中看不到第二个页面的展示效果。在pages/index/index.js文件中增加一个onTapCreateRadioVote函数，作为小程序中首页中单击“创建单选投票”按钮的事件处理函数。代码如下：\n\n```json\nPage({\n    onLoad(){\n        //页面生命周期的函数onLoad,进入页面时会调用它\n    },\n    onTapCreateRadioVote(){\n        wx.navigateTo({\n            url:'/pages/createVote/createRadioVote'\n        })\n    }\n)\n```\n\n​\t尽管目前还没有将小程序的API，但是这个函数易于理解，它可以让小程序跳转到createRadioVote页面。接下来，在pages/index/index.wxml文件中将这个函数绑定到“创建单选投票按钮上。代码如下：\n\n```html\n<view class = \"btn\" bindtap=\"onTapCreateMultiChoiceVote\">\n    <image class=\"btn-img\" src=\"/pages/imgs/多选.png\" mode=\"widthFix\"></image>\n    <text class = \"btn-text\">多选投票</text>\n    <text class = \"btn-desc\">创建一个多选投票</text>\n </view>\n```\n\n​\t这段代码为view组件增加上了一个bindtap属性。bindtap属性的value对应着页面JS文件中的函数名，它将这个函数作为单击（tap）事件的监听函数绑定（bind）到组件上，当小程序监听到用户单击该组件时，就会立刻调用被绑定的函数。这样一来，只需要单击首页中的\"创建单选投票\"按钮就可以跳转到该页面查看页面效果.\n\n​\t**注:因为页面中的大部分组件都可以被用户单击,因此bindtap是一个很通用的属性,可以应用到几乎所有组件上**\n\n### 修改模拟器中的启动页面\n\n​\t显然,通过页面跳转的方式预览第二个页面的显示效果是非常不便的,微信开发者提供了一个非常方便的功能,可以修改模拟器中的小程序启动页面,通过这个设置可以将小程序的首页临时修改为pages/createVote/createVote页面\n\n​\t在工具栏中有一个编译模式的设置\n\n​\t微信开发者工具默认使用的是\"普通编译\",选择下拉菜单中的\"添加编译模式\"选项,打开编译模式设置窗口.设置窗口中,将启动页面选择为刚刚创建的第二个页面,并为这个模式起一个便于区分的名称,其他保持默认即可.\n\n### 使用form表单组件\n\n​\t创建单选投票页面是一个表单页面,在这个页面中首先需要一个form表单组件作为所有表单组件的父元素.在createVote.wxml文件中加入form组件,代码如下:\n\n```html\n<view>\n    <form bindsubmit=\"formSubmit\" bindreset=\"formReset\">\n        < !-- 这里添加表单组件 -->\n    </form>\n</view>\n```\n\n​\tbiansubmit 和 submitreset是form组件最常用的两个属性,从名字就能看出来它们的功能与bindtap属性类似.它们分别将表单提交(submit)事件和表单重置(reset)事件绑定(bind)到页面JS文件中的两个函数上,当小程序检测到表单提交事件或者表单重置事件时,就会分别调用这两个属性绑定的函数.\n\n​\t显然,组件的单击事件只需要通过用户单击手机屏幕就能触发,而如果想要出发表单的提交事件或重置事件,则需要借助另外一个表单组件button,后面介绍button组件时会讲到出发这两个事件.\n\n​\t由于现在表单内容还不完整,因此暂时先不在JS文件中实现表单提交和重置的事件处理函数.可以先在createVote.js文件中将两个函数申明出来,并创建一条注释,通过TODO关键字提醒自己以后记得处理相关内容.代码如下:\n\n```json\nPage({\n    formSubmit(){\n        // TODO 表单提交事件处理函数\n    },\n    formReset(){\n        // TODO 表单重置事件处理函数\n    }\n)\n```\n\n### 使用input输入框组件\n\n​\t现在form组件中不包含任何内容,因此这个页面的预览效果是空白的,本节就来在页面中增加一个input输入框组件.\n\n​\tinput组件拥有很多属性:\n\n| 属性名            | 类 型       | 默认值            | 描述                                   |\n| ----------------- | ----------- | ----------------- | -------------------------------------- |\n| value             | string      |                   | 输入框的内容                           |\n| type              | string      | text              | input的类型                            |\n| password          | boolean     | false             | 是否是密码类型                         |\n| placeholder       | string      |                   | 输入框为空时的提示文字                 |\n| placeholder-class | string      | input-placeholder | 指定placeholder的样式类                |\n| disabled          | boolean     | false             | 是否禁用输入框                         |\n| maxlength         | number      | 140               | 最大输入长度,如果设置为-1,则不限制长度 |\n| focus             | boolean     | false             | 进入表单页面时自动获得焦点             |\n| bindinput         | eventhandle |                   | 键盘输入时触发事件处理函数             |\n\n| 属性名      | 类 型       | 默认值 | 描述                                       |\n| ----------- | ----------- | ------ | ------------------------------------------ |\n| bindfocus   | eventhandle |        | 输入框聚焦时触发的处理函数                 |\n| bindblur    | eventhandle |        | 输入框失去焦点时出发的事件处理函数         |\n| biandconfim | eventhandle |        | 单击输入法键盘上的完成按钮时出发的处理函数 |\n\n**注:表中的属性不必考虑版本兼容性的问题,eventhandle类型实际上时string类型,这几个属性与bindtap类似,也是用于处理事件函数的,因此它们的value通常时JS文件中某个函数的名字**\n\n​\t以上属性中,value属性可以设置为输入框的初始内容.如果value属性的值对应着页面的某个变量(如value=\"{{somedate} }\"),那么当变量的值改变时,输入框中的内容也会随之改变.\n\n​\ttype属性可以设置输入框的类型，修改该属性后，用户在输入框输入内容时就会使用对应类型的键盘，它支持四种取值：text(使用文本输入键盘)、number(使用数字输入键盘)、idcard(使用身份证输入键盘)和digit(使用带小数点的数字键盘)。\n\n​\tplaceholder属性用于提示用户输入框的作用，当输入框的内容为空白时，它就会显示在输入框中。\n\n​\tpalceholder-class属性的作用与class类似，也是指定组件的样式类，不过给这个样式类添加样式时，只会修改placeholder文字的样式，而不会影响输入文字的样式。\n\n​\tdisabled属性用于禁用输入框，如果设置为true，当用户进入表单的时候，会自动获取输入焦点，并弹出对应的输入键盘，方便用户直接输入内容。\n\n​\tbindinput\\bingfocus\\bindblur和bindconfirm属性分别用于绑定4种事件处理函数，当某个与输入框的事件被触发时，小程序就会调用对应的事件处理函数来处理相关的逻辑。\n\n​\t被绑定的事件处理函数还有一个共同的特征，它们都有一个Object类型的参数，称为event参数，在这个参数种保存着与本次事件相关的全部信息。例如，屏幕单击事件可以获取用户单击屏幕的位置、单击的组件名称。\n\n​\t在上面与input组件相关的四个事件中，可以用event.detail.value获取到输入框中当前的内容。例如：先在input组件中设置属性bindinput=\"onInputChange\",然后再页面JS文件中加入事件处理函数onInputChange(),代码如下：\n\n```javascript\nPage({\n    onInputChange(e){ //函数的第一个参数就是event参数，参数名称可以由开发者决定\n        console.log(e.detail.value) //控制台打印输入框中的内容\n    }\n})\n```\n\n​\t此时，在输入框中一次输入“1”、“2”、“3”、“4”，可以在调试器的console面板中看到，每当输入一个数字的时候，console中都会打印当前的input组件中的内容。这说明每次输入框的内容改变的时候，onInputChange函数都会被调用一次，并且通过e.detail.value可以获得输入框的文字内容。\n\n**注：如果事件处理函数中用不到event参数，也可以忽略，rupages/index/index。wxml文件中的onTapCreateRadioVote函数就省略了event参数。**\n\n​\t下面就用input组件创建投票页面增加一个投票标题的输入框。首先在createRadioVote.wxml文件中增加input组件。代码如下：\n\n```html\n<view class=\"container\">\n\t<form bindsumbit = \"formSubmit\" bindreset = \"formReset\">\n        <input class=\"form-title\" placeholder = \"投票标题\" focusbindinput=\"onTitleInputChange\" />\n    </form>\n</view>\n```\n\n**注：在WXML中，如果希望设置focus属性为true，可以写focus = \"{{true } }\",也可以简写为focus.所有boolean类型的属性都支持这种简写。**\n\n​\t接下来在createRadioVote.wxss文件中增加一些样式。代码如下：\n\n```css\n.container{\n  padding:30rpx;\n  box-sizing: border-box;\n  width: 741rpx; \n  height: 1071rpx; \n  display: flex; \n  box-sizing: border-box;\n}\n\n.form-title{\n  color: #333;\n  font-weight: blod;\n  font-size: 20pt;\n  height: 24pt;\n  border-bottom: 1rpx solid #eee;\n  padding: 10rpx 0;\n  box-sizing: content-box;\n}\n\n.form-title-palceholder{\n  color: #ccc;\n}\n```\n\n​\t最后修改createRadioVote.js文件。代码如下：\n\n```javascript\n// pages/createVote/createVote.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    multiple:false,\n    formTitle:'',\n    formDesc:'',\n    optionList:[],//投票内容\n\n    nowDate:'',//保存今天日期\n    endDate:'',//保存截至日期\n    isAnonymous:false\n  },\n\n    onTitleInputChange(e){\n    \tthis.setdata({\n            \n            formTitle:e.detail.value\n            \n        })    \n    },\n    \n   formSubmit(){\n       //TODO 表单提交事件处理函数\n   },\n   formReset(){\n       //TODO 表单重置事件处理函数\n   }\n})\n```\n\n​\t这段代码中增加了一个data对象，在页面JS文件中一般都要使用data对象保存页面中的数据，开发者可以根据实际情况在data对象中增加属性。在这里，data对象中的formTitle属性用于保存当前投票标题输入框中的内容。\n\n​\t另外，代码中还增加了一个onTitleInputChange函数，这个函数在WXML代码中已经被bindinput属性绑定到了input组件上，作为输入框的输入事件处理函数。每次输入框内容改变时，onTitleInputChange函数都会被调用。\n\n​\tthis.setData函数可以修改data对象中的属性值，它传入一个Object类型的参数，Object的key表示需要修改的属性的名字，key对应的value是e.detail.value中取出的值，也就是当前输入框中的内容。这样一来，每次输入框的内容改变的时候，data对象中的formTitle属性就会同步更新。\n\n### 数据的双向传递\n\n​\t在上面的代码中不难发现，使用事件处理函数可以将数据从视图层传入到逻辑层，通过在组建上绑定事件处理函数，从事件处理函数的event参数中往往可以获取需要的视图层数据。\n\n​\t视图层中的数据是由小程序管理的，开发者无需关心视图层中的数据具体保存在哪里。而逻辑层中的数据通常保存在data对象中，它必须由开发者自己来管理。微信开发者工具的调试器中有一个AppData面板，在该面板中可以实时查看页面逻辑层的数据，也就是说data对象中保存的数据。如果在投票标题输入框中输入一些内容，就可以看到data对象中的formTitle属性的值发生了变化 。\n\n**注：data对象中的__webviewId__属性是由小程序自动添加的系统属性，开发者可以忽略它的存在，不要修改它的值**\n\n​\t但是事件处理函数只建立了单向的数据传递，如果反过来，修改逻辑层中的数据，视图层中的数据无法同步更新的。在AppData面板中修改formTitle属性的值，可以看到模拟器中的文字没有发生改变。\n\n​\t如果是希望建立从逻辑层到视图层的数据传递关系，也非常的简单，只要在input中加入一个属性\"value={{formTitle } }\"即可。修改后的代码如下：\n\n```html\n<view class=\"container\">\n    <form bindsubmit=\"formsubmit\" bindreset=\"formReset\">\n        <input value=\"{{formTitle}}\" class=\"form-title\" placeholder=\"投票标题\"\n               focus\n               \tplaceholder-class=\"form-title-placeholder\"\n               bindinput=\"onTitleInputChange\" />\n    </form>\n</view>\n```\n\n​\t在视图层中，通过双大括号语法可以获得逻辑层data对象中的属性值，并且当逻辑层中的数据改变时，小程序会自动刷新视图层中的数据。这时如果再修改调试器的formTitle的值，模拟器中的文字就会随之改变。\n\n​\t需要说明的是，通常只有表单组件才需要建立双向传递。对于text这类的组件，用户无法修改它的视图层数据，自然不需要将数据从视图层传递到逻辑层。\n\n​\t另外，建立数据的双向传递并非强制要求，但是它是一个很好的习惯。数据双向传递的有点在于无论视图层还是再逻辑层的修改数据，另外一个地方的数据都会随之更新。有时我们会在代码中修改逻辑层的数据，如果忘记将数据从逻辑层传到视图层，可能会导致逻辑层与视图层的不一致，从而产生莫名其妙的问题。\n\n### 使用textarea多行输入框组件\n\n​\t接下来介绍textarea组件，它是一个多行的输入框组件。textarea组件与input组件相似，不同点是input组件只支持单行文本输入，如果文本宽度超过input组件的宽度，就需要左右滑动文字区域查看超出的文字内容。而textarea中的文本宽度如果超过textarea组件的宽度，文本会自动换行处理。下表总结了常用的textarea组件属性：\n\n| 属性名            | 类型        | 默认值               | 描述                                                         |\n| ----------------- | ----------- | -------------------- | ------------------------------------------------------------ |\n| value             | string      |                      | 输入框的内容                                                 |\n| palceholder       | string      |                      | 输入框为空的提示字                                           |\n| placeholder-class | string      | textarea-placeholder | 指定placeholder的样式类                                      |\n| disabled          | boolean     | false                | 是否禁用输入框                                               |\n| maxlength         | number      | 140                  | 最大输入长度，如果设置为-1,则不能限制长度                    |\n| focus             | boolean     | false                | 进入表单页面时自动获取焦点                                   |\n| auto-height       | boolean     | false                | 如果textarea是在一个position:fixed的区域，需要显示指定属性fixed为true |\n| bindinput         | eventhandle |                      | 键盘输入时触发的事件处理函数                                 |\n| bindfocus         | eventhandle |                      | 输入框聚焦时触发的事件处理函数                               |\n\n| 属性名         | 类型        | 默认值 | 描述                                           |\n| -------------- | ----------- | ------ | ---------------------------------------------- |\n| bindblur       | eventhandle |        | 输入框失去焦点时的触发事件处理函数             |\n| bindconfirm    | eventhandle |        | 单击输入法键盘上的完成按钮时触发的事件处理函数 |\n| bindlinechange | eventhandle |        | 输入框行数变化时触发的事件处理函数             |\n\n​\t可以看出，textarea有很多与input组件类似的属性，这里不再重复介绍。值得注意的是textarea没有type和password属性，而相比于input组件又多了一些属性。\n\n​\t因为textarea中可以输入多行文字，所以一般情况下需要在WXSS中为它设置一个固定的高度。如果不希望指定固定的高度，那么也可以数字auto-height属性为true，这样textarea组件就会随内容行数的增加而自动增高了。\n\n​\tfixed属性没有特别的用处，如果textarea组件特有的，它可以为textarea组件绑定一个事件处理函数，当输入框的行数变化时会调用该函数。不过该函数与其他事件处理函数不太一样，它的event参数中获取不到输入框的内容，而通过event.detail.linCount可以获取当前输入的行数。\n\n**注：实际上event参数携带了很多信息,可以通过console.log(event)在调试器console面板中打印出event参数的内容查看。**\n\n​\t这里使用textarea组件为创建投票页面增加一个用于填写补充描述的输入框。在craeteRadioVote.wxml文件中input组件的下方增加以下代码：\n\n```html\n<textarea value=\"{{formdesc}}\" class=\"form-desc\" bindinput=\"onDescChange\" \n    auto-height\n    placeholder=\"补充描述（选填）\" placeholder-class=\"form-text-placeholder\" ></textarea>\n```\n\n​\t在createRadioVote.wxss文件中为它增加如下的代码：\n\n```css\n.form-desc{\n  margin-top: 40rpx;\n  width: 100%;\n  color: #333;\n  font-size: 14pt;\n  border-bottom: 1rpx solid #eee;\n  padding: 20rpx 0;\n  box-sizing: content-box;\n}\n\n.form-text-palceholder{\n  color:#ccc;\n}\n```\n\n​\t最后，修改createRadioVote.js文件，为textarea组件增加逻辑层的数据变量和事件处理函数。代码如下：\n\n```javascript\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    multiple:false,\n    formTitle:'',\n    formDesc:'',\n    optionList:[],//投票内容\n\n    nowDate:'',//保存今天日期\n    endDate:'',//保存截至日期\n    isAnonymous:false\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad(options) {\n    if(options.type === 'radio'){\n      wx.setNavigationBarTitle({\n        title: '创建单选投票'\n      })\n    }else if(options.type === 'multiple'){\n      this.setData({\n        multiple:true\n      })\n      wx.setNavigationBarTitle({\n        title: '创建多选投票'\n      })\n    } else{\n      console.error('wrong page parameter [type]'+options.type)\n    }\n   this.formReset()\n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() {\n    \n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() {\n\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() {\n\n  },\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() {\n\n  },\n\n   formSubmit(){\n     const formData = {\n       multiple:this.data.multiple,\n       voteTitle:this.data.formTitle,\n       voteDesc:this.data.formDesc,\n       optionList:this.data.optionList,\n       endDate: this.data.endDate,\n       isAnonymous: this.data.isAnonymous\n     }\n     //将表单提交到云端\n     const voteID = 'test';//伪造数据作为服务端返回的投票ID\n     wx.redirectTo({\n       url: '/pages/vote/vote?voteID='+voteID,\n     })\n      //TODO表单提交事件处理函数\n   },\n   formReset(){\n      const now = new Date()\n      const nowYear = now.getFullYear()\n      const nowMonth = now.getMonth()+1\n      const nowDay = now.getDate()+1\n      const nowDate = nowYear +'-'+((nowMonth<10)?('0'+nowMonth):nowMonth)+'-'+((nowDay<10)?('0'+nowDay):nowDay)\n\n      this.setData({\n        nowDate,\n        endDate:nowDate,\n        formTitle:'',\n        formDesc:'',\n        optionList:[],\n        isAnonymous :false\n      })\n      //TODO表单重置事件处理函数\n   },\n\n   onTitleInputChange(e){\n      this.setData({\n        formTitle:e.detail.value\n      })\n   },\n   onDescChange(e){\n     this.setData({\n       formDesc:e.detail.value\n     })\n   },\n   onTapAddOption(){\n      const newOptionList = this.data.optionList\n      newOptionList.push('')\n      this.setData({\n        optionList:newOptionList\n      })\n   },\n   onTapDelOption(e){\n     const delIndex = e.currentTarget.dataset.optionIndex\n\n     const newOptionList = this.data.optionList.filter(\n       (v,i) => i !== delIndex\n     )\n     this.setData({\n       optionList:newOptionList\n     })\n   },\n   onChangeEndDate(e){\n     this.setData({\n       endDate:e.detail.value\n     })\n   },\n   onChangeIsAnonymous(e){\n     this.setData({\n       isAnonymous:e.detail.value\n     })\n   },\n\n   onOptionInputChange(e){\n     const newOptionList = this.data.optionList\n     const changedIndex = e.currentTarget.dataset.optionIndex\n     newOptionList[changedIndex] = e.detail.value\n     this.setData({\n       optionList:newOptionList\n     })\n   }\n})\n```\n\n### wx:for列表渲染\n\n​\t接下来为创建的投票页面增加一个“添加选项”的功能。为投票设置选项时，也需要用户输入一些文字，因此一个使用input组件。但是与投票的标题设置不同的是，一个投票的选项数量是不确定的，有可能是2个，也有可能是5个，甚至还有可能是十几个。\n\n​\t遇到这种不确定数量的组件的情况时，在视图层可以使用wx:for属性对组件列表进行渲染。相对应地，在逻辑层需要使用数组类型地变量保存数据。几乎所有地组件都支持wx:for属性，在wx:for属性中可以绑定一个逻辑层地数组，既可以使用数组中各项地数据重复地渲染组件。\n\n​\t举一个例子，加入在逻辑层data对象中有个数组array,数组中地每一项时一个Object类型地变量，每个Objext中包含一个message属性。代码如下：\n\n```javascript\ndata:{\n    array:[{\n        message:'First message'\n    },{\n     message:'Second message'   \n    }]\n}\n```\n\n​\t在对应的WXML文件中，可以使用这个数组对组件进行列表渲染，下面这段代码所示：\n\n```html\n<view wx:for=\"{{array}}\">\n\t{{index}}:{{item.index}}\n</view>\n```\n\n​\t小程序在渲染页面时，发现view组件中包含wx:for属性，就会根据array中元素的个数重复地渲染这一段代码，array中有几个元素，view组件（包括view组件地内容）就会被渲染几次。在列表渲染的时候，可以通过index 变量获取当前元素的数组下标值，还可以通过item变量直接直接的渲染当前元素。\n\n​\t如果在小程序项目中编写以上代码，在调试区域的Wxml面板可以看到经过渲染后的wxml的结构。\n\n​\twx:for属性可以嵌套使用，即在列表渲染的组件内还可以对它的子组件进行列表渲染u.zai嵌套的列表渲染的组件内，不能确定item和index变量时属于父组件的数据还是属于子组件的数据，可以使用wx:for-item属性和wx:for-index属性为它们进行重命名。 例如，微信官方文档还提供了一个九九乘法表的例子：\n\n```html\n<view wx:for=\"{{1,2,3,4,5,6,7,8,9}}\" wx:for-item = \"i\">\n    <view wx:for=\"{{1,2,3,4,5,6,7,8,9}}\" wx:for-item=\"j\">\n    \t<view wx:if=\"{{i <= j}}\">\n            {{i}}*{{j}} = {{i*j}}\n        </view>\n    </view>\n</view>\n```\n\n​\t学习了wx:for属性后，就可以用列表渲染功能为表单增加一些不确定的数量的input组件。\n\n​\t先来准备好逻辑层的数据。在createRadioVote.js文件的data对象中增加一个数组类型的变量optionList，用于保存每一个投票选项的内容。\n\n​\t这个数组变量初始值为空，需要在界面中增加一个“添加选项”的按钮,当单击按钮时，就向数组中插入一个新的元素。可以使用view组件实现这个功能，在WXML文件中的textarea组件就可以增加如下的代码：\n\n```html\n<view class=\"btn-add-option\" bindtap=\"onTapOption\">+ 添加选项</view>\n```\n\n​\t在WXSS文件中为按钮增加样式。\n\n```css\n.btn-add-option{\n    font-size:12pt;\n    color:#26AB28;\n    padding: 40rpx 0;\n}\n```\n\n​\t在JS文件中加入如下的按钮单击处理函数，代码如下：\n\n```javascript\nonTapAddOption(){\n    const newOptionList = this.data.optionList //获取当前的optionList\n    newOptionList.push('') //在list数组中新增一个空字符串，插入数组后面\n    this.setData({\n        optionList:newOptionList // 更新data对象中的optionList\n    })\n}\n```\n\n​\t这样一来，每单击一次“添加选项”按钮时，逻辑层的optionList数组就会增加一个元素，可以从调试器的AppData面板中看到数据逻辑的变化\n\n​\t这样，逻辑层的数据就准备完毕了。接下来，利用逻辑层的optionList变量，在WXML文件中使用列表渲染为页面增加投票选项的input组件，修改后的WXML代码如下：\n\n```html\n<!--pages/createVote/createVote.wxml-->\n<view class = \"container\">\n  <form bindsubmit=\"formSubmit\" bindreset=\"formReset\" style=\"width: 517rpx; height: 1095rpx; display: block; box-sizing: border-box\">\n  <!--这里添加表单组件-->\n    <input value=\"{{formTitle}}\" class = \"from-title\" placeholder=\"投票标题\"\n    focus\n    palceholder-class = \"form-title-placeholder\" \n    bindinput=\"onTitleInputChange\"/>\n    <textarea value=\"{{formdesc}}\" class=\"form-desc\" bindinput=\"onDescChange\" \n    auto-height\n    placeholder=\"补充描述（选填）\" placeholder-class=\"form-text-placeholder\" ></textarea>\n    <view wx:for=\"{{optionList}}\" class=\"form-option\">\n       \n      <view class=\"form-input-wrapper\">\n        <input value=\"{{item}}\" \n          class=\"form-input\"\n          placeholder=\"选项\"\n          placeholder-class=\"form-text-placeholder\"\n          bindinput=\"onOptionInputChange\"\n          data-option-index=\"{{index}}\" />\n        </view>\n        <icon type=\"cancel\" bindtap=\"onTapDelOption\" data-option-index=\"{{index}}\" class=\"del-btn\" />\n      </view>\n    <view class=\"btn-add-option\" bindtap=\"onTapAddOption\">+ 添加选项</view>\n    <view class=\"form-item\">\n      <text class=\"form-item-label\">截止日期</text>\n      <picker class=\"form-item-picker\" mode=\"date\" value=\"{{endDate}}\" start=\"{{nowDate}}\" bindchange=\"onChangeEndDate\">{{endDate}}</picker>\n    </view>\n    <view class=\"form-item\">\n      <text class=\"form-item-label\">匿名投票</text>\n      <switch checked=\"{{isAnonymous}}\" bindchange=\"onChangeIsAnonymous\" />\n    </view>\n    <view class=\"form-btn-group\">\n      <button class=\"form-btn\" type=\"primary\" form-type=\"submit\">完成</button>\n      <button class=\"form-btn\" form-type=\"reset\">重置</button>\n    </view>\n  </form>\n</view>\n```\n\n​\t这里用两个view包裹input组件是为了后面方便实现一些样式，在WXSS代码中为投票选项输入框加入一些样式。\n\n```css\n.form-option{\n    margin-top:20rpx;\n}\n.form-input-wrapper{\n    color: #333;\n    font-size: 12pt;\n    border-bottom:1rpx solid #eee;\n    padding : 20rpx 0;\n}\n```\n\n​\t最后在JS文件中编写投票选项输入框的输入事件处理函数，实现数据在逻辑层与视图的双向传递。代码如下：\n\n```javascript\nonOptionInputChange(e){\n    const newOptionList = this.data.optionList // 获取当前的optionList\n    const changedIndex = e.currentTarget.dataset.optionIndex //获取当前修改的元素的下标\n    newOptionList[changedIndex] = e.detail.value //将视图层的数据更新到逻辑层变量中\n    this.setData({\n        optionList:newOptionList //更新data对象中的optionList\n    })\n}\n```\n\n​\t在事件处理函数中可以通过e.currentTargent.dataset.optionIndex获取当前修改的元素的下标。实际上这个值是在WXML代码的Input组件中由data-option-index属性传入的。如果一个组件上绑定了事件处理函数，就可以通过data-开头的属性向事件处理函数中传递额外的数据，传递的数据会保存在event.currentTarget.dataset对象中，数据的key的名字是data-属性后面的部分，并且会将短横线连接的形式改为形如optionIndex的驼峰式的名称。\n\n### 使用icon图标组件\n\n​\t现在表单中的投票选项可以增加和修改，却不能删除。需要为每一个选项增加一个删除按钮，用户单击按钮可以删除不需要的投票选项。\n\n​\t删除按钮可以通过icon图标组件实现，icon图标组件可以非常方便地在页面中添加一些常用地图标，icon图标组件常用的属性如表所示：\n\n| 属性名 | 类型          | 默认值 | 描述                                           |\n| ------ | ------------- | ------ | ---------------------------------------------- |\n| type   | string        |        | icon的类型                                     |\n| size   | number/string | 23     | icon的大小，如果属性值是number，则以px为单位。 |\n| color  | string        |        | icon的颜色，作用与WXSS的color属性一样          |\n\n​\ticon图标组件的属性都很好理解，这里主要说一下type属性的取值范围。type属性可以传入的有效值主要有sucess、sucess_no_circle 、info、warn、waiting、cancel、download、search、clear\n\n​\t这些图标中，可以使用cancle图标作删除按钮。在WXML代码中加入icon图标组件，修改后form-option中的代码如下：\n\n```html\n<view wx:for=\"{{optionList}}\" class=\"form-option\">\n       \n      <view class=\"form-input-wrapper\">\n        <input value=\"{{item}}\" \n          class=\"form-input\"\n          placeholder=\"选项\"\n          placeholder-class=\"form-text-placeholder\"\n          bindinput=\"onOptionInputChange\"\n          data-option-index=\"{{index}}\" />\n        </view>\n        <icon type=\"cancel\" bindtap=\"onTapDelOption\" data-option-index=\"{{index}}\" class=\"del-btn\" />\n      </view>\n```\n\n​\t在WXSS文件中完善这一区域的样式。代码如下：\n\n```css\n.form-option{\n  margin-top: 20rpx;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.form-input-wrapper{\n  color:#333;\n  font-size: 12pt;\n  border-bottom: 1rpx solid #eee;\n  padding:20rpx 0;\n  flex: 1;\n}\n\n.del-btn{\n  margin-right: 20rpx;\n}\n```\n\n​\t最后在JS文件中加入单击“删除”按钮的事件处理函数。代码如下：\n\n```javascript\n// pages/createVote/createVote.js\n   onTapDelOption(e){\n     const delIndex = e.currentTarget.dataset.optionIndex\n\n     const newOptionList = this.data.optionList.filter(\n       (v,i) => i !== delIndex\n     )\n     this.setData({\n       optionList:newOptionList\n     })\n   }\n```\n\n​\t在上面的代码中使用了一个箭头函数。\n\n```javascript\n(v,i) => i !== delIndex\n```\n\n​\t这个函数实际上是下面这个函数的缩写：\n\n```javascript\n(v,i) => {\n    return i !== delIndex\n}\n```\n\n​\t它也可以写成下面这个写法：\n\n```javascript\nfunction(v,i){\n    return i !== delIndex\n}\n```\n\n​\t这样就可以看出，实际上filter函数中传入了一个匿名函数，这个匿名函数对oiptionList数组中的每一个元素都会执行一次。数组元素的值和下标分别传入函数的低1、2个参数中，取名为v和i，通过返回true和false，决定是否保留optionList数组中的元素。显然，箭头函数的写法是非常简洁的，有时间学习下JS箭头函数的用法。\n\n### 使用picker选择器组件\n\n​\t接下来使用picker选择器组件增加一个设置截止时间的功能。picker是一个从底部弹出的滚动选择器组件。它有三个通用属性，如下表所示：\n\n| 属性名     | 类型        | 默认值   | 描述                         | 最低版本 |\n| ---------- | ----------- | -------- | ---------------------------- | -------- |\n| mode       | string      | selector | 选择器类型                   | 1.0.0    |\n| disabled   | boolean     | false    | 是否禁用                     | 1.0.0    |\n| bindcancel | eventhandle |          | 取消选择时触发的事件处理函数 | 1.9.0    |\n\n​\tPicker选择器组件的mode属性的合法值包括：selector(普通选择器)、multiSelector(多项选择器)、time(时间选择器)、date(日期选择器)和region(省市区选择器)。其中，region的最低版本基础库版本要求为1.4.0，其他可选值均无兼容性要求。\n\n​\t当mode取值为不同的选择器类型时，picker选择器组件会有一些额外的属性。例如，当mode为selector时，picker选择器组件的额外属性如表所示：\n\n| 属性名     | 类型           | 默认值 | 描述                                                         |\n| ---------- | -------------- | ------ | ------------------------------------------------------------ |\n| range      | array/Objext[] | []     | 可选内容，当mode为selector或multiselector时，range有效       |\n| range-key  | string         |        | 当range是一个Object Array时，通过range-key来指定Object中的key的值作为选择器的显示内容 |\n| value      | number         | 0      | 表示选择了range中的第几个（下标从0开始）                     |\n| bindchange | eventhandle    |        | value改变时触发的事件处理函数                                |\n\n​\t当mode为time时，picker选择器组件的额外属性如表所示：\n\n| 属性名     | 类型        | 描述                                |\n| ---------- | ----------- | ----------------------------------- |\n| value      | string      | 选择的时间，格式为hh:mm（如12：30） |\n| start      | string      | 有效时间范围的开始，格式为hh:mm     |\n| end        | string      | 有效时间范围的结束，格式为hh:mm     |\n| bindchange | eventhandle | value改变时触发的事件处理函数       |\n\n​\t当mode为date时，picker选择器组件的额外属性如表所示：\n\n| 属性名     | 类型        | 默认值 | 描述                                       |\n| ---------- | ----------- | ------ | ------------------------------------------ |\n| value      | string      | 0      | 选择的日期，格式为YYYY-MM-DD(如2019-05-09) |\n| start      | string      |        | 有效日期范围的开始，格式为YYYY-MM-DD       |\n| end        | string      |        | 有效日期范围的结束，格式为YYYY-MM-DD       |\n| fields     | string      | day    | 选择器的粒度，有效值year、month、day       |\n| bindchange | eventhandle |        | value改变时触发的事件处理函数              |\n\n​\t当mode为region时，picker选择器组件的额外属性如表所示：\n\n| 属性名      | 类型        | 默认值 | 描述                                                         |\n| ----------- | ----------- | ------ | ------------------------------------------------------------ |\n| value       | array       | []     | 选中省市区,默认选中每一列的第一个值                          |\n| custom-item | string      |        | 可谓每一列的顶部添加一个自定义的项                           |\n| bindchange  | eventhandle |        | value改变时触发的事件处理函数，函数的event参数中还可以拿到区域的邮政编码和统计用区划代码 |\n\n​\t现在可以使用picker选择器组件的日期为投票增加一个设置戒指时间对额功能。首先在JS文件中增加需要的逻辑层数据nowData和endData。代码如下：\n\n```javascript\ndata: {\n    multiple:false,\n    formTitle:'',\n    formDesc:'',\n    optionList:[],//投票内容\n\n    nowDate:'',//保存今天日期\n    endDate:'',//保存截至日期\n    isAnonymous:false\n  },\n```\n\n​\t由于这两个变量的初始值需要动态生成，因此最好在生命周期函数onLoad中初始化它们。onLoad函数的调用时机在显示页面内容之前，因此非常适合用于初始化页面中的一些复杂数据。代码如下：\n\n```javascript\nonLoad(options) {\n    if(options.type === 'radio'){\n      wx.setNavigationBarTitle({\n        title: '创建单选投票'\n      })\n    }else if(options.type === 'multiple'){\n      this.setData({\n        multiple:true\n      })\n      wx.setNavigationBarTitle({\n        title: '创建多选投票'\n      })\n    } else{\n      console.error('wrong page parameter [type]'+options.type)\n    }\n   this.formReset()\n  }\n```\n\n​\t在onLoad函数中，首先通过Date对象获取当前的年月日信息，这三个值都是number类型。在这三个值中，月份比较特殊，用0~11表示1-12月，因此需要将getMonth的返回值加1才能得到真正的月份。接下来将年月日变量与短横线“-”相加，number变量与string变量相加时，会先将number类型的数据转换为string类型（如12转换为'12'）,然后再将两个字符拼接。在拼接年月日时，还需要判断月份与日期是否是单个数字，如果是则需要在前面补一个字符串0，三元运算符还可以很方便地实现这一功能。\n\n```java\n表达式1 ? 表达式2 : 表达式3\n```\n\n​\t这段代码地意思是，当表达式1的值为true时，则使用表达式2的值，否则使用表达式1的值\n\n​\t接下来为picker选择器组件增加一个value改变事件处理函数。代码如下：\n\n```java\nonChangeEndDate(e){\n\tthis.setData({\n\t\tendDate: e.detail.value\n\t})\n}\n```\n\n​\t现在逻辑层的准备工作就做好了。修改WXML文件，在“添加选项”按钮的下方增加如下代码：\n\n```html\n<view class=\"form-item\">\n      <text class=\"form-item-label\">截止日期</text>\n      <picker class=\"form-item-picker\" mode=\"date\" value=\"{{endDate}}\" start=\"{{nowDate}}\" bindchange=\"onChangeEndDate\">{{endDate}}</picker>\n    </view>\n```\n\n​\t最后在WXSS文件中为新加入的组件增加样式，代码如下：\n\n```css\n.form-item{\n    display : flex;\n    justify-content : space-between;\n    align-items:center;\n    border-bottom: 1rpx solid #eee;\n    padding: 20rpx 0;\n    margin-top: 20rpx;\n}\n.form-item-label{\n \tfont-size:12pt;\n    color: #333;\n}\n.form-item-picker{\n    font-size: 12pt;\n    color: #999;\n}\n```\n\n### 使用switch开关组件\n\n​\t接下来用switch开关组件增加一个设置是否匿名投票的功能。switch组件是一个开关选择器\n\n​\t这个组件的常用属性如表所示：\n\n| 属性名     | 类型        | 默认值  | 描述                            | 最低版本 |\n| ---------- | ----------- | ------- | ------------------------------- | -------- |\n| checked    | boolean     | false   | 是否选中                        | 1.0.0    |\n| disabled   | boolean     | false   | 是否禁用                        | 1.0.0    |\n| color      | string      | #04BE02 | switch的颜色                    | 1.0.0    |\n| bindchange | eventhandle |         | checked改变时触发的事件处理函数 | 1.0.0    |\n\n​\t修改JS文件，在data对象中加入一个用于保存匿名投票设置的变量。\n\n```java\nisAnonymous: false\n```\n\n​\t同时增加一个switch开关组件变化时触发的事件处理函数\n\n```java\nonChangeAnonymous(e){\n    this.setData({\n        isAnonymous:e.detail.value\n    })\n}\n```\n\n​\t最后修改WXML文件，在“截至日期”设置的下方增加如下代码：\n\n```html\n<view class=\"form-item\">\n    <text class=\"form-item-label\">匿名投票</text>\n    <switch chaecked=\"{{isAnonymous}}\" bindchange=\"onchangeIsAnonymous\" />\n</view>\n```\n\n​\t这段代码的结构和样式与“截至日期”很相似，因此可以复用之前的class样式，无需重复编写样式代码。\n\n### 使用button按钮组件\n\n​\t接下来用button按钮组件在页面中增加一个完成设置的按钮和一个重复表单的按钮。\n\nbutton按钮组件的常用属性如表所示：\n\n| 属性名           | 类型    | 默认值       | 描述                                                         | 最低版本 |\n| ---------------- | ------- | ------------ | ------------------------------------------------------------ | -------- |\n| size             | string  | default      | 按钮的大小                                                   | 1.0.0    |\n| type             | string  | default      | 按钮的样式类型，可选值：primary(绿色)、default(白色)、warn(红色) | 1.0.0    |\n| plain            | boolean | false        | 是否镂空，背景色透明                                         | 1.0.0    |\n| disabled         | boolean | false        | 是否禁用                                                     | 1.0.0    |\n| loading          | boolean | false        | 文字前是否带loading图标                                      | 1.0.0    |\n| form-type        | string  |              | 用于form表单，可选值：submit\\reset                           | 1.0.0    |\n| hover-class      | string  | button-hover | 指定按钮下去的样式类                                         | 1.0.0    |\n| hover-start-time | number  | 20           | 按住后多久出现单击台，单位：毫秒                             | 1.0.0    |\n| hover-stay-time  | number  | 70           | 手指松开后单击态保留时间，单位：毫秒                         | 1.0.0    |\n| open-type        | string  |              | 微信开放能力                                                 | 1.1.0    |\n\n​\t在表中可以看到button按钮组件有一个form-type属性,这个属性需要与form组件一起使用。当button按钮组件在form组件中时，如果form-type属性设置为submit,则单击button按钮组件时会触发form组件的reset事件。\n\n​\t另外button按钮组件还有一个值得说明的属性open-type属性。这个属性的可选值有很多，包括contact、share、getPhoneNumber、getUserInfo、launchApp、openSetting和feedback等。通过open-type属性，button按钮组件可以很方表地调用小城地微信开放能力，在后面的章节会对其中的一些开发能力进行介绍。\n\n​\t现在就可以在页面中添加button按钮组件，为表单增加“完成”和“重置”这两个按钮。在WXML文件中“匿名投票”设置的下方增加以下代码。\n\n```html\n<view class=\"form-btn-group\">\n    <button class=\"form-btn\" type=\"primary\" form-type=\"submit\">完成</button>\n    <button class=\"form-btn\" form-type=\"reset\">重置</button>\n</view>\n```\n\n​\t接下来在WXSS中为新加入的内容增加样式设置。\n\n```css\n.form-btn-group{\n    padding: 40rpx 0;\n}\n.form-btn{\n    margin-top:20rpx;\n}\n```\n\n​\t最后需要修改formSubmit和formReset两个事件处理函数。代码如下：\n\n```java\nformSubmit(){\n     const formData = {\n       multiple:this.data.multiple,\n       voteTitle:this.data.formTitle,\n       voteDesc:this.data.formDesc,\n       optionList:this.data.optionList,\n       endDate: this.data.endDate,\n       isAnonymous: this.data.isAnonymous\n     }\n     //将表单提交到云端\n     const voteID = 'test';//伪造数据作为服务端返回的投票ID\n     wx.redirectTo({\n       url: '/pages/vote/vote?voteID='+voteID,\n     })\n      //TODO表单提交事件处理函数\n   },\n\n   formReset(){\n      const now = new Date()\n      const nowYear = now.getFullYear()\n      const nowMonth = now.getMonth()+1\n      const nowDay = now.getDate()+1\n      const nowDate = nowYear +'-'+((nowMonth<10)?('0'+nowMonth):nowMonth)+'-'+((nowDay<10)?('0'+nowDay):nowDay)\n\n      this.setData({\n        nowDate,\n        endDate:nowDate,\n        formTitle:'',\n        formDesc:'',\n        optionList:[],\n        isAnonymous :false\n      })\n      //TODO表单重置事件处理函数\n   }\n```\n\n​\t在formSubmit函数中,首先将data中的一部分数据取出，放到了一个新的Object中。这个Object中的内容就是用户填写表单的所有内容，可以看到其中并不包括nowDate，因为nowDate只是一个辅助数据，用于限制哦那个胡填写截至日期的日期范围，而其他数据都是从用户填写的信息中收集来的。\n\n​\t现在收集好用户的数据以后，还不能对它们进行什么处理。投票小程序是一个联网的应用，涉及多个微信用户，数据需要在很多台手机中流转。显然，不能将数据存储在某个人的手机上，否则当用户断网时，其他人就无法获取或者提交数据了。因此，必须得有个地方专门存储这些数据，这个地方就是服务端。\n\n​\t**注：一个典型的互联网应用包含服务器（server）和客户端（client），小程序开发属于是客户端开发。**\n\n​\t服务端可以对数据进行统一的收集、存储和分发，但这也需要开发者去开发相应的程序，服务端开发有被称为后端开发，相对于小程序开发而言，服务端开发需要学习的技术更多，学习门槛更高。为了解决这一问题，微信小程序中可以使用云开发技术，无须掌握太多的服务端开发技术，使用JavaScript语言就可以轻松开发服务端程序。\n\n​\tformReset函数的功能时将数据重置为它们的初始值。在上面的代码中可以看到，formReset函数的大部分内容与onLoad函数是重复的。写重复的代码是很不好的编程习惯，更专业的做法是将重复的部分抽象称为一个新的函数，然后再重复代码的地方分别调用这个新的函数。在这个例子中，由于两个函数几乎完全是重复的，所以可以让onLoad函数直接调用formReset函数来完成数据的初始化。\n\n```javascript\nonLoad(){\n \tthis.formReset()   \n}\n```\n\n​\t尽管onLoad函数不需要初始化formTitle、formDesc、optionList和isAnonymous这几个数据，但是为了让代码更加的简洁，只要逻辑没有错误，这样处理也没有问题。\n\n​\t**能不能将初始化数据的代码写在onLoad函数中，然后再formReset函数中调用onLoad函数呢？ 这样也是可以实现同样的功能的，但是不建议这么做。**\n\n​\t从字面上来理解，onLoad表示页面加载，formReset表示表单重置。显然，说“页面加载”时执行“表单重置”是可以的。但是反过来说“表单重置”时执行“页面加载”，这样说很奇怪。\n\n​\t编程时处理考虑功能上的正确性，还要考虑语义上的准确性。代码首先是要让人阅读的，其次才是让机器来执行。保持语义的准确性可以帮助开发者更快的理解代码，如果写的代码难以理解，和其他人一起合作编写程序时就会造成很多不快，甚至过段时间再重新阅读这段难以理解的代码时，自己都会莫名其妙。\n\n​\t**注：有时为了保证程序的性能，可能会牺牲可读性，但是这种情况比较少**\n\n### 开发创建多选投票页面\n\n​\t现在，创建单选投票页面已经基本开发完了（除了向服务端发送数据的部分以外），接下来看一下如何开发创建多选投票页面。先来想想，创建多选投票页面与创建单选投票页面有什么区别呢？\n\n​\t答案是没有区别。创建多选投票时，一样要填写投票标题、投票描述、投票选项、截止日期和是否匿名等信息。多选投票和单选投票的唯一区别，就是要在向服务器发送数据时，告诉服务器这个投票是什么类型的投票。这个数据用boolean类型、number类型或是string 类型表示都可以，只需要客户端与服务器达成一致。\n\n```java\nmultiple: true // 用multiple = true表示多选\nmultiple: false // 用multiple = false 表示单选\n    \ntype: 1 // 用type = 1 表示多选\ntype: 0 // 用type = 0 表示单选\n    \ntype: 'multiple' //用type = 'multiple' 表示多选\ntype: 'radio' // 用type = 'radio' 表示单选\n```\n\n​\t**注：由于文化差异，multiple choice有时也可以表示“单选”，它可以理解为从多个备注选项中作选择。这里忽略这种差异，以multiple choice表示多选。实际开发中如果遇到这种有歧义的命名时，建议写清楚注释，防止误会的发生。**\n\n​\t既然创建单选投票页面还没完成向服务器发送数据的部分，那么此时创建多选投票页面与创建单选投票页面的代码应该时完全一样的，这里就不再重复展示了。开发创建多选投票页面时，首先需要创建一个新的页面，然后再首页中为它增加跳转，最后完成页面中的各个组件的开发。新创建的页面路径可以使用“pages/createVote/createMultiChoicVote”读者也可以自定义为其他任意路径。\n\n### 使用页面路径参数\n\n​\t在目前的pages/index/index.js文件中，单击创建单选投票按钮与单击创建多选投票按钮打开的是两个不同的页面。代码如下：\n\n```javascript\nPage({\n    onTapCreateRadioVote(){\n        wx.navigateTo({\n            url:'/pages/createVote/createRadioVote'\n        })\n    },\n    onTapCreateMultiChoiceVote(){\n        wx.navigateTo({\n            url:'/pages/createVote/createMultiChoiceVote'\n        })\n    }\n})\n```\n\n​\t前面提到，在同一个程序中写很多重复的代码是非常不好的编程习惯。既然创建多选投票页面与创建单选投票页面的重复度如此大，那么有没有办法将这两个页面合二为一呢\n\n​\t答案是肯定的。通过在页面路径中携带参数，可以用一个页面来完成这两种功能。下面创建的一个新的页面pages/createVote/createVote，然后修改首页index.js中的代码，将单击两个按钮之后跳转的路径修改为新的页面。代码如下：\n\n```javascript\nPage({\n    onTapCreateRadioVote(){\n        wx.nagivateTo({\n            url:'/pages/createVote/createMultiChoiceVote'\n        })\n    },\n    onTapCreateMultiChoiceVote(){\n        wx.nagiviteTo(){\n            url:'/pages/createVote/createVote?type=multiple'\n        }\n    }\n})\n```\n\n​\t可以看到，页面的跳转路径后面多了一些特殊的东西，它就是页面路径的参数。参数可以有多个，参数与参数之间通过与符号\"&\"相连接。\n\n​\t在/pages/createVote/createVote页面中，可以从JS文件的onLoad函数中获取传递过来的参数。修改onLoad函数为以下代码：\n\n```java\nonLoad:function(option){\n\tconsole.log(options)\n}\n```\n\n​\t从首页分别进入创建单选投票和创建多选投票页面，可以从调试器的Console面板看到options的内容\n\n​\t**注意：页面路径参数的值永远为string类型，尽量不要传递true、false或者数字这样的字符串，一面出现意料外的逻辑错误**\n\n​\t只需要将之前的代码做一些简单的修改，就可以适配页面路径参数。\n\n```javascript\n// pages/createVote/createVote.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    multiple:false,\n    formTitle:'',\n    formDesc:'',\n    optionList:[],//投票内容\n\n    nowDate:'',//保存今天日期\n    endDate:'',//保存截至日期\n    isAnonymous:false\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad(options) {\n    if(options.type === 'radio'){\n      wx.setNavigationBarTitle({\n        title: '创建单选投票'\n      })\n    }else if(options.type === 'multiple'){\n      this.setData({\n        multiple:true\n      })\n      wx.setNavigationBarTitle({\n        title: '创建多选投票'\n      })\n    } else{\n      console.error('wrong page parameter [type]'+options.type)\n    }\n   this.formReset()\n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() {\n    \n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() {\n\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() {\n\n  },\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() {\n\n  },\n\n   formSubmit(){\n     const formData = {\n       multiple:this.data.multiple,\n       voteTitle:this.data.formTitle,\n       voteDesc:this.data.formDesc,\n       optionList:this.data.optionList,\n       endDate: this.data.endDate,\n       isAnonymous: this.data.isAnonymous\n     }\n     //将表单提交到云端\n     const voteID = 'test';//伪造数据作为服务端返回的投票ID\n     wx.redirectTo({\n       url: '/pages/vote/vote?voteID='+voteID,\n     })\n      //TODO表单提交事件处理函数\n   },\n   formReset(){\n      const now = new Date()\n      const nowYear = now.getFullYear()\n      const nowMonth = now.getMonth()+1\n      const nowDay = now.getDate()+1\n      const nowDate = nowYear +'-'+((nowMonth<10)?('0'+nowMonth):nowMonth)+'-'+((nowDay<10)?('0'+nowDay):nowDay)\n\n      this.setData({\n        nowDate,\n        endDate:nowDate,\n        formTitle:'',\n        formDesc:'',\n        optionList:[],\n        isAnonymous :false\n      })\n      //TODO表单重置事件处理函数\n   },\n\n   onTitleInputChange(e){\n      this.setData({\n        formTitle:e.detail.value\n      })\n   },\n   onDescChange(e){\n     this.setData({\n       formDesc:e.detail.value\n     })\n   },\n   onTapAddOption(){\n      const newOptionList = this.data.optionList\n      newOptionList.push('')\n      this.setData({\n        optionList:newOptionList\n      })\n   },\n   onTapDelOption(e){\n     const delIndex = e.currentTarget.dataset.optionIndex\n\n     const newOptionList = this.data.optionList.filter(\n       (v,i) => i !== delIndex\n     )\n     this.setData({\n       optionList:newOptionList\n     })\n   },\n   onChangeEndDate(e){\n     this.setData({\n       endDate:e.detail.value\n     })\n   },\n   onChangeIsAnonymous(e){\n     this.setData({\n       isAnonymous:e.detail.value\n     })\n   },\n\n   onOptionInputChange(e){\n     const newOptionList = this.data.optionList\n     const changedIndex = e.currentTarget.dataset.optionIndex\n     newOptionList[changedIndex] = e.detail.value\n     this.setData({\n       optionList:newOptionList\n     })\n   }\n})\n```\n\n​\t可以看到，在onLoad函数中通过type参数，动态改变了盗汗蓝文字内容和data中的multiple变量，在将数据提交到服务端时，也会将这个multiple变量传送过去，这样服务端就知道当前创建的是什么类型的投票。\n\n​\t由于onLoad函数中会自动设置页面导航栏的文字，因此JSON文件中实际上不需要再对导航栏文字进行设置。\n\npages/createVote/createVote.json文件代码如下：\n\n```json\n{\n    \"navigateBarTitleText\":\"创建投票\"\n}\n```\n\n​\tpages/createVote/createVote.wxml文件与之前的创建单选投票页面完全一样。\n\n```html\n<!--pages/createVote/createVote.wxml-->\n<view class = \"container\">\n  <form bindsubmit=\"formSubmit\" bindreset=\"formReset\" style=\"width: 517rpx; height: 1095rpx; display: block; box-sizing: border-box\">\n  <!--这里添加表单组件-->\n    <input value=\"{{formTitle}}\" class = \"from-title\" placeholder=\"投票标题\"\n    focus\n    palceholder-class = \"form-title-placeholder\" \n    bindinput=\"onTitleInputChange\"/>\n    <textarea value=\"{{formdesc}}\" class=\"form-desc\" bindinput=\"onDescChange\" \n    auto-height\n    placeholder=\"补充描述（选填）\" placeholder-class=\"form-text-placeholder\" ></textarea>\n    <view wx:for=\"{{optionList}}\" class=\"form-option\">\n       \n      <view class=\"form-input-wrapper\">\n        <input value=\"{{item}}\" \n          class=\"form-input\"\n          placeholder=\"选项\"\n          placeholder-class=\"form-text-placeholder\"\n          bindinput=\"onOptionInputChange\"\n          data-option-index=\"{{index}}\" />\n        </view>\n        <icon type=\"cancel\" bindtap=\"onTapDelOption\" data-option-index=\"{{index}}\" class=\"del-btn\" />\n      </view>\n    <view class=\"btn-add-option\" bindtap=\"onTapAddOption\">+ 添加选项</view>\n    <view class=\"form-item\">\n      <text class=\"form-item-label\">截止日期</text>\n      <picker class=\"form-item-picker\" mode=\"date\" value=\"{{endDate}}\" start=\"{{nowDate}}\" bindchange=\"onChangeEndDate\">{{endDate}}</picker>\n    </view>\n    <view class=\"form-item\">\n      <text class=\"form-item-label\">匿名投票</text>\n      <switch checked=\"{{isAnonymous}}\" bindchange=\"onChangeIsAnonymous\" />\n    </view>\n    <view class=\"form-btn-group\">\n      <button class=\"form-btn\" type=\"primary\" form-type=\"submit\">完成</button>\n      <button class=\"form-btn\" form-type=\"reset\">重置</button>\n    </view>\n  </form>\n</view>\n```\n\n​\t最后是pages/createVote/createVote.wxss，同样是与创建单选页面一样。完整代码如下：\n\n```css\n/* pages/createVote/createVote.wxss */\n.container{\n  padding:30rpx;\n  box-sizing: border-box;\n  width: 741rpx; \n  height: 1071rpx; \n  display: flex; \n  box-sizing: border-box;\n}\n\n.form-title{\n  color: #333;\n  font-weight: blod;\n  font-size: 20pt;\n  height: 24pt;\n  border-bottom: 1rpx solid #eee;\n  padding: 10rpx 0;\n  box-sizing: content-box;\n}\n\n.form-title-palceholder{\n  color: #ccc;\n}\n\n.form-desc{\n  margin-top: 40rpx;\n  width: 100%;\n  color: #333;\n  font-size: 14pt;\n  border-bottom: 1rpx solid #eee;\n  padding: 20rpx 0;\n  box-sizing: content-box;\n}\n\n.form-text-palceholder{\n  color:#ccc;\n}\n\n.btn-add-option{\n  font-size: 12pt;\n  color: #26AB28;\n  padding:40rpx 0;\n}\n\n.form-option{\n  margin-top: 20rpx;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.form-input-wrapper{\n  color:#333;\n  font-size: 12pt;\n  border-bottom: 1rpx solid #eee;\n  padding:20rpx 0;\n  flex: 1;\n}\n\n.del-btn{\n  margin-right: 20rpx;\n}\n\n.form-item{\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  border-bottom: 1rpx solid #eee;\n  padding: 20rpx 0;\n  margin-top: 20rpx;\n}\n\n.form-item-label{\n  font-size:12pt;\n  color:#333;\n}\n\n.form-item-picker{\n  font-size: 12pt;\n  color: #999;\n}\n\n.form-btn-group{\n  padding: 40rpx 0;\n}\n\n.form-btn{\n  margin-top:20rpx;\n}\n```\n\n## 开发参与投票页面\n\n​\t参与投票页面同样需要收集用户提交的信息，例如哪个用户在哪个投票中选择了什么选项，因此也是一个表单页面。\n\n### 如何获取投票信息\n\n​\t当用户打开参与投票页面时，显然一个先向用户展示投票的标题、描述和选项等信息。为了能在视图层展示这些数据，必须要先在逻辑层获取这些数据。由于是在打开页面时就需要向用户展示数据，因此可以在页面生命周期函数onLoad中获取它们。\n\n​\t在上面的过程中，有三个关键点我们没有介绍过：\n\n- [ ] 如何创建表单数据发送给服务端，让服务器保存数据并获得ID，然后把ID返回给小程序\n\n- [ ] 如何将投票分享到微信群中\n\n- [ ] 如何使用投票ID从服务端获取投票信息\n\n  暂时可以将该过程想象为一种特殊的函数调用，代码如下：\n\n  ```javascript\n  //将数据发送给服务端，并获取ID\n  dataID = postDataToServer(data)\n  //从服务端获取数据\n  data = getDataFromServer(dataID)\n  ```\n\n  ​\t首先通过app.json文件创建一个新的页面pages/vote/vote。接下来修改pages/createVote/createVote.js文件中的formSubmit函数，加入创建投票后自动跳转到新页面的逻辑。代码如下：\n\n  ```javascript\n  formSubmit(){\n      const msg = this.checkFormValid()\n      if(msg){\n        wx.showToast({\n          title: msg,\n          icon:'none'\n        })\n        return\n      }\n      const formData = {\n        multiple:this.data.multiple,\n        voteTitle:this.data.formTitle,\n        voteDesc:this.data.formDesc,\n        optionList:this.data.optionList,\n        endDate:this.data.endDate,\n        isAnonymous:this.data.isAnonymous\n      }\n  \n      const db = wx.cloud.database()\n      db.collection('votes').add({\n        data:formData\n      }).then(res => {\n        console.log(res._id)\n        wx.redirectTo({\n          url: '/pages/vote/vote?voteID='+res._id,\n        })\n      })\n  \n      /*const voteID = 'test';\n      wx.redirectTo({\n        url: '/pages/vote/vote?voteID='+voteID,\n      })*/\n    }\n  })\n  ```\n\n  ​\t上面这段代码中的页面跳转使用了wx.rediectTo，而不是之前在首页中使用的wx.nagivateTo。wx.nagivateTo在跳转时会保留当前的页面，从而单击返回时还可以返回这个页面。而wx.redirectTo在陶砖时则会关闭当前页面，单击返回时就会跳到更上一级的页面（如果不存在这个页面，小程序就会直接退出）。\n\n  ### 借用伪造数据开发功能\n\n  ​\t由于参与投票页面需要展示从服务端获取投票信息，但是现在还没有实现服务端的功能，因此需要在小程序伪造一些数据和功能。\n\n  ​\t为了便于开发，在工具栏中先为参与投票页面新建一个编译模式\n\n  ​\t这个页面携带了一个启动参数voteID = test,用户A跳转到参与投票页面时会携带这个参数，用户B单击小程序卡片打开投票时也会携带这个参数。接下来pages/vote/vote.js文件代码：\n\n  ```javascript\n  // pages/vote/vote.js\n  Page({\n  \n    /**\n     * 页面的初始数据\n     */\n    data: {\n      voteStatus:{\n        alreadyVoted: false,\n        totalVoteCount: 0,\n        optionStatus:[]\n      },\n      voteID:'',\n      multiple:false,\n      voteTitle:'',\n      voteDesc:'',\n      optionList:[],\n      endDate:'',\n      isAnonymous:false,\n      isExpired:false,\n      pickedOption:[]\n    },\n  \n    /**\n     * 生命周期函数--监听页面加载\n     */\n    onLoad(options) {\n      const voteID = options.voteID\n      this.getVoteDataFormServer(voteID)\n      this.getVoteStatusFromServer(voteID)\n    },\n  \n    /**\n     * 生命周期函数--监听页面初次渲染完成\n     */\n    onReady() {\n  \n    },\n  \n    /**\n     * 生命周期函数--监听页面显示\n     */\n    onShow() {\n  \n    },\n  \n    /**\n     * 生命周期函数--监听页面隐藏\n     */\n    onHide() {\n  \n    },\n  \n    /**\n     * 生命周期函数--监听页面卸载\n     */\n    onUnload() {\n  \n    },\n  \n    /**\n     * 页面相关事件处理函数--监听用户下拉动作\n     */\n    onPullDownRefresh() {\n  \n    },\n  \n    /**\n     * 页面上拉触底事件的处理函数\n     */\n    onReachBottom() {\n  \n    },\n  \n    /**\n     * 用户点击右上角分享\n     */\n    onShareAppMessage() {\n  \n    },\n  \n    getVoteDataFormServer(voteID){\n      /*\n      if(voteID === 'test'){\n        const voteData = {\n          multiple:false,\n          voteTitle:'测试数据投票标题',\n          voteDesc:'测试数据投票描述',\n          optionList:[\n            '测试数据选项1',\n            '测试数据选项2',\n            '测试数据选项3'\n          ],\n          endDate:'2020-07-08',\n          isAnonymous:false,\n        }\n      */\n        const db = wx.cloud.database()\n        db.collection('votes').doc(voteID).get().then(res =>  {\n          const voteData = res.data\n          const isExpired = this.checkExpired(voteData.endDate)\n          \n          this.setData({\n            voteID,\n            multiple:voteData.multiple,\n            voteTitle:voteData.voteTitle,\n            voteDesc:voteData.voteDesc,\n            optionList:voteData.optionList,\n            endDate:voteData.endDate,\n            isAnonymous:voteData.isAnonymous,\n            isExpired\n          }).catch(res => {\n            console.error(res)\n            wx.showToast({\n              title: '获取投票失败',\n              icon:'none'\n            })\n          })\n        })\n        /*\n        const isExpired = this.checkExpired(voteData.endDate)\n  \n        this.setData({\n          voteID,\n          multiple:voteData.multiple,\n          voteTitle:voteData.voteTitle,\n          voteDesc:voteData.voteDesc,\n          optionList:voteData.optionList,\n          endDate:voteData.endDate,\n          isAnonymous:voteData.isAnonymous,\n          isExpired\n        })\n      }else{\n        //TODO 从服务端获取投票信息\n      }*/\n  },\n    checkExpired(endDate){\n      const now = new Date()\n      const nowYear = now.getFullYear()\n      const nowMonth = now.getMonth()+1\n      const nowDay = now.getDate()\n      const endDateArray = endDate.split('-')\n      const endYear = Number(endDateArray[0])\n      const endMonth = Number(endDateArray[1])\n      const endDay = Number(endDateArray[2])\n      //年份超了，投票过期\n      if(nowYear>endYear){\n        return true\n      }\n      //如果年份一致，月份超了，投票过期\n      if((nowYear === endYear) && (nowMonth > endMonth)){\n        return true\n      }\n      //如果年份月份都一直，日期超了，投票过期\n      if((nowYear === endYear) && (nowMonth === endMonth) && (nowDay > endDay)){\n        return true\n      }\n      //其他情况投票没有过期\n      return false\n    },\n  \n    onPickOption(){\n      //更新选择的选项\n      if(this.data.multiple){\n        this.setData({\n          pickedOption:e.detail.value\n        })\n      }else{\n        this.setData({\n          pickedOption:[\n            e.detail.value\n          ]\n        })\n      }\n      this.setData({\n        pickedOption:[\n          e.detail.value\n        ]\n      })\n    },\n  \n    onTapVote(){\n      if(this.data.isAnonymous){\n        const postData ={\n          voteID:this.data.voteData,\n          pickedOption:this.data.pickedOption\n        }\n        wx.cloud.callFunction({\n          name:'vote',\n          data:{\n            postData\n          }\n        }).then(res => {\n          console.log(res)\n          this.getVoteStatusFromServer(this.data.voteID)\n        }).catch(res => {\n            console.error(res)\n            wx.showToast({\n              title: '投票失败',\n              icon:'none'\n            })\n        })\n        //TODO 将postData数据上传到服务端\n        //this.getVoteStatusFromServer(this.data.voteID)//从服务器获取投票情况\n      }else{\n        const _this = this\n  \n        wx.getUserInfo({\n          success(res){\n            const postData = {\n              voteID:_this.data.voteData,\n              userInfo:res.userInfo,\n              pickedOption: _this.data.pickedOption\n            }\n            wx.cloud.callFunction({\n              name:'vote',\n              data:{\n                postData\n              }\n            }).then(res => {\n              console.log(res)\n              _this.getVoteStatusFromServer(_this.data.voteID)\n            }).catch(res => {\n              console.error(res)\n              wx.showToast({\n                title: '投票失败',\n                icon:'none'\n              })\n            })\n            //console.log(postData)\n            //TODO 将postData数据上传服务端\n            //_this.getVoteStatusFromServer(_this.data.voteID)\n          }\n        })\n      }\n    },\n    \n    onShareAppMessage(){\n      return{\n        title:'邀请你参与投票',\n        path:'/pages/vote/vote?voteID='+this.data.voteID\n      }\n    },\n  \n    getVoteStatusFromServer(voteID){\n      /*\n      if(voteID === 'test'){\n        const voteStatus ={\n          alreadyVoted:true,\n          totalVoteCount:100,\n          optionStatus:[{\n            count:25,\n            vote:false\n          },{\n            count:35,\n            vote:false\n          },{\n            count:10,\n            vote:true\n          },{\n            count:30,\n            vote:false\n          }]\n        }\n        this.setData({\n          voteStatus\n        })\n      }else{\n        //TODO 从服务端获取投票情况\n      }*/\n      wx.cloud.callFunction({\n        name:'getVoteStatus',\n        data:{\n          voteID\n        }\n      }).then(res => {\n        console.log(res)\n        this.setData({\n          voteStatus:res.result\n        })\n      }).catch(res => {\n        console.error(res)\n        wx.showToast({\n          title: '获取投票数据失败',\n          icon:'none'\n        })\n      })\n    },\n  \n    formSubmit(){\n      const msg = this.checkFormValid()\n      if(msg){\n        wx.showToast({\n          title: msg,\n          icon:'none'\n        })\n        return\n      }\n      const formData = {\n        multiple:this.data.multiple,\n        voteTitle:this.data.formTitle,\n        voteDesc:this.data.formDesc,\n        optionList:this.data.optionList,\n        endDate:this.data.endDate,\n        isAnonymous:this.data.isAnonymous\n      }\n  \n      const db = wx.cloud.database()\n      db.collection('votes').add({\n        data:formData\n      }).then(res => {\n        console.log(res._id)\n        wx.redirectTo({\n          url: '/pages/vote/vote?voteID='+res._id,\n        })\n      })\n  \n      /*const voteID = 'test';\n      wx.redirectTo({\n        url: '/pages/vote/vote?voteID='+voteID,\n      })*/\n    }\n  })\n  ```\n\n\n\n### 使用radio单项选择器组件\n\n​\t逻辑层的数据已经准备完毕，现在看一下如何实现视图层的页面展示。\n\n​\t投票的标题、描述、截至日期、是否匿名等信息通过view组件和text组件就可以展示出来，这个页面中比较特别的时如何展示投票选项的信息，它们不仅要显示出选项的文字内容，还需要让用户单击，从而实现单选或多选的功能。\n\n​\t首先来看一下radio组件和radio-group组件的常用属性，如下表：\n\nradio组件的常用属性\n\n| 属性名   | 类型    | 默认值  | 描述              | 最低版本 |\n| -------- | ------- | ------- | ----------------- | -------- |\n| value    | string  |         | 单个radio组件的值 | 1.0.0    |\n| checked  | boolean | false   | 当前是否选中      | 1.0.0    |\n| disabled | boolean | false   | 是否禁用          | 1.0.0    |\n| color    | string  | #09BB07 | radio的颜色       | 1.0.0    |\n\nradio-group组件的常用属性\n\n| 属性名     | 类型        | 描述                                                         | 最低版本 |\n| ---------- | ----------- | ------------------------------------------------------------ | -------- |\n| bindchange | EventHandle | 内部radio选项改变时触发的事件处理函数，可以通过event.detail.value获取到选中的radio组件的值 | 1.0.0    |\n\n​\t下面使用radio组件实现单选投票的功能。修改pages/vote/voye.wxml文件，加入以下代码：\n\n```html\n<!--pages/vote/vote.wxml-->\n<view class=\"container\">\n  <view class=\"title\">{{voteTitle}}</view>\n  <view class=\"desc\">\n    {{voteDesc}}\n    <text class=\"mutiple-radio\">[{{mutiple ? '多选':'单选'}}]</text>\n    <text class=\"type\">[{{isAnonymous ? '匿名':'实名'}}]</text>\n  </view>\n  <view wx:if=\"{{voteStatus.alreadyVoted}}\" class=\"option-list\">\n    <view class=\"option\" wx:for=\"{{optionList}}\">\n      <text>{{item}}</text>\n      <text class=\"vote-count\">({{voteStatus.optionStatus[index].count}} / {{voteStatus.totalVoteCount}} 票)</text>\n      <text class=\"vote-picked\" wx:if=\"{{voteStatus.optionStatus[index].vote}}\">[已选]</text>\n    </view>\n  </view>\n  <block wx:else>\n    <checkbox-group wx:if=\"{{multiple}}\" class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <checkbox value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </checkbox-group>\n    <radio-group wx:else class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <radio value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </radio-group>\n  </block>\n\n  <view class=\"end-date\">\n    截至日期:{{endDate}}\n    <text class=\"expired\" hidden=\"{{!isExpired}}\">[已过期]</text>\n  </view>\n  <button open-type=\"getUserInfo\" class=\"btn\" type=\"primary\" disabled=\"{{isExpired || pickedOption.length === 0}}\" bindtap=\"onTapVote\" >确认投票</button>\n  <button open-type=\"share\" plain class=\"share\">分享投票</button>\n</view>\n\n```\n\n​\t在这段代码中，有一个class为expired的text组件，它使用了一个新的属性hidden。hidden属性也是所有组件都支持的属性，它的值是一个boolean类型，当hidden属性的值为true时,这个组件在页面中会被隐藏。\n\n​\tradio组件的value使用了数组的角标，这是因为数组是一种有序的集合，因而可以使用角标来代表选择的选项。这样在传输投票数据和存储投票数据时占用的数据量会小很多。\n\n​\t接下来在JS文件中增加两个事件处理函数。代码如下：\n\n```javascript\nonPickOption(){\n    //更新选择的选项\n    if(this.data.multiple){\n      this.setData({\n        pickedOption:e.detail.value\n      })\n    }else{\n      this.setData({\n        pickedOption:[\n          e.detail.value\n        ]\n      })\n    }\n    this.setData({\n      pickedOption:[\n        e.detail.value\n      ]\n    })\n  },\n      onTapVote(){\n    if(this.data.isAnonymous){\n      const postData ={\n        voteID:this.data.voteData,\n        pickedOption:this.data.pickedOption\n      }\n      wx.cloud.callFunction({\n        name:'vote',\n        data:{\n          postData\n        }\n      }).then(res => {\n        console.log(res)\n        this.getVoteStatusFromServer(this.data.voteID)\n      }).catch(res => {\n          console.error(res)\n          wx.showToast({\n            title: '投票失败',\n            icon:'none'\n          })\n      })\n      //TODO 将postData数据上传到服务端\n      //this.getVoteStatusFromServer(this.data.voteID)//从服务器获取投票情况\n    }else{\n      const _this = this\n\n      wx.getUserInfo({\n        success(res){\n          const postData = {\n            voteID:_this.data.voteData,\n            userInfo:res.userInfo,\n            pickedOption: _this.data.pickedOption\n          }\n          wx.cloud.callFunction({\n            name:'vote',\n            data:{\n              postData\n            }\n          }).then(res => {\n            console.log(res)\n            _this.getVoteStatusFromServer(_this.data.voteID)\n          }).catch(res => {\n            console.error(res)\n            wx.showToast({\n              title: '投票失败',\n              icon:'none'\n            })\n          })\n          //console.log(postData)\n          //TODO 将postData数据上传服务端\n          //_this.getVoteStatusFromServer(_this.data.voteID)\n        }\n      })\n    }\n  },\n```\n\n​\t在onTapVote函数中可以看到，表单数据的提交不一定要用到form表单组件和bindsubmit属性指定的事件处理函数，在button按钮组件的单击事件处理函数中也可以向服务器提交数据。\n\n​\t接下来为页面增加一些WXSS样式。代码如下：\n\n```css\n/* pages/vote/vote.wxss */\n.container{\n  padding: 30rpx;\n}\n\n.title{\n  color: #333;\n  font-size: 14pt;\n  font-weight: 20pt;\n}\n\n.desc{\n  font: size 14pt;\n  margin-top: 40rpx;\n}\n\n.mutliple-radio{\n  margin-left: 10rpx;\n  color: #09bb07;\n}\n\n.type{\n  margin-left: 10rpx;\n  color: #ccc;\n}\n\n.option-list{\n  margin-top: 40rpx;\n}\n\n.option{\n  margin-top: 10rpx;\n}\n\n.end-date{\n  margin-top: 40rpx;\n  font-size: 12pt;\n  color: #ccc;\n}\n\n.expired{\n  margin-left: left 10rpx;\n  color: #ce3c39;\n}\n\n.btn{\n  margin-top: 40rpx;\n}\n\n.share{\n  margin-top: 20rpx;\n}\n\n.vote-count{\n  color:#ccc\n}\n\n.vote-picked{\n  color: #09BB07;\n}\n\n```\n\n\n\n### 使用label组件扩大单击区域\n\n​\t完成以上代码后会发现，如果读者在模拟器或者手机中进行测试，会发现radio组件的单击区域很小\n\n​\t实际测试中，单击区域的位置与选项2左侧的方框位置一样，只有单击文字左侧的圆圈才可以选择该选项。而开发者实际上期望选项按钮的单击区域也将文字内容包括进去。\n\n​\t可以通过label组件将单击区域扩大。label组件的使用非常简单，只需要将radio组件和文字包含在内部就可以了。这样单据区域的范围就会从radio组件扩大到label组件。\n\n​\tlabel组件的内部只能包含switch、button、radio和checkbox这几种组件，前三种组件已经介绍过了，checkbox组件是后面会介绍的多项选择器组件。\n\n​\t因此，现在只需要将选项部分的WXML代码改成下面这样，就可以扩大组件的单击区域了。\n\n```html\n<view>\n    <label>\n    \t<radio value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n    </label>\n</view>\n```\n\n### wx:if条件渲染\n\n​\tradio组件只适用于单选投票的情况，而多选投票需要用到另一个组件checkbox。那么如何根据不同的情况在页面上使用不同的组件呢——wx:if。几乎所有的组件都支持它。使用形式如下：\n\n```html\n<view wx:if=\"{{condition}}\">This will be displayed if condition is true</view>\n```\n\n​\t从与hidden属性不同,wx:if属性控制组件是否被渲染，而hidden属性控制组件永远会被渲染，只是简单的显示和隐藏。一般来说，wx:if属性有更高的切换小号，而hidden属性有更高的初始渲染消耗。因此，如果是在需要平凡切换的情景下，用hiden数学较好；如果在运行时条件不大可能改变，则使用wx:if属性较好。\n\n### 使用checkbox多项选择器组件\n\n​\tcheckbox组件与radio组件非常像，他也有一个checkbox-group组件作为父组件。checkbox组件与checkbox-group组件的常用属性如表所示：\n\ncheckbox\n\n| 属性名   | 类型    | 默认值  | 描述                 | 最低版本 |\n| -------- | ------- | ------- | -------------------- | -------- |\n| value    | string  |         | 单个checkbox组件的值 | 1.0.0    |\n| checked  | boolean | false   | 当前是否选中         | 1.0.0    |\n| disabled | boolean | false   | 是否禁用             | 1.0.0    |\n| color    | string  | #09BB07 | checkbox的颜色       | 1.0.0    |\n\ncheckbox-group\n\n| 属性名     | 类型        | 描述                                                         | 最低版本 |\n| ---------- | ----------- | ------------------------------------------------------------ | -------- |\n| bindchange | EventHandle | 内部chackbox选项改变时触发的事件处理函数，可以通过event.detail.value获取选中的所有checkbox组件的值 | 1.0.0    |\n\n​\t修改WXML中投票选项部分的代码，将多选投票的功能加到视图层中。相关代码如下：\n\n```html\n<checkbox-group wx:if=\"{{multiple}}\" class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <checkbox value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </checkbox-group>\n    <radio-group wx:else class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <radio value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </radio-group>\n```\n\n​\t另外，还需要修改JS中的事件处理函数onPickOption，使它也支持多选投票。代码如下：\n\n```javascript\nonPickOption(){\n    //更新选择的选项\n    if(this.data.multiple){\n      this.setData({\n        pickedOption:e.detail.value\n      })\n    }else{\n      this.setData({\n        pickedOption:[\n          e.detail.value\n        ]\n      })\n    }\n    this.setData({\n      pickedOption:[\n        e.detail.value\n      ]\n    })\n  }\n```\n\n​\t完成后，可以修改调试器AppData面板中的multiple变量的值，在模拟器中查看页面效果\n\n### 获取用户信息\n\n​\t如果投票是实名投票，那么用户确认投票时，除了将投票的选项提交到服务端，还需要将用户的昵称等信息一起提交。可以在JS文件中使用API接口wx.getUserInfo获取用户的信息。\n\n​\t使用wx.getUserInfo接口前，需要先对获取用户新这一操作向用户发起授权请求。发起授权请求的方式非常简单，只需要在确认投票的button按钮组件上增加opentype=\"getUserInfo\"属性就可以了。代码如下：\n\n```html\n<button open-type=\"getUserInfo\" class=\"btn\" type=\"primary\" disabled=\"{{isExpired || pickedOption.length === 0}}\" bindtap=\"onTapVote\" >确认投票</button>\n```\n\n​\t这样，单击“确认投票”按钮时，界面上就会显示一个授权确认窗口，这样就可以在onTapVote函数使用wx.getUserInfo获取用户信息。代码如下：\n\n```javascript\nonTapVote(){\n    if(this.data.isAnonymous){\n      const postData ={\n        voteID:this.data.voteData,\n        pickedOption:this.data.pickedOption\n      }\n      wx.cloud.callFunction({\n        name:'vote',\n        data:{\n          postData\n        }\n      }).then(res => {\n        console.log(res)\n        this.getVoteStatusFromServer(this.data.voteID)\n      }).catch(res => {\n          console.error(res)\n          wx.showToast({\n            title: '投票失败',\n            icon:'none'\n          })\n      })\n      //TODO 将postData数据上传到服务端\n      //this.getVoteStatusFromServer(this.data.voteID)//从服务器获取投票情况\n    }else{\n      const _this = this\n\n      wx.getUserInfo({\n        success(res){\n          const postData = {\n            voteID:_this.data.voteData,\n            userInfo:res.userInfo,\n            pickedOption: _this.data.pickedOption\n          }\n          wx.cloud.callFunction({\n            name:'vote',\n            data:{\n              postData\n            }\n          }).then(res => {\n            console.log(res)\n            _this.getVoteStatusFromServer(_this.data.voteID)\n          }).catch(res => {\n            console.error(res)\n            wx.showToast({\n              title: '投票失败',\n              icon:'none'\n            })\n          })\n          //console.log(postData)\n          //TODO 将postData数据上传服务端\n          //_this.getVoteStatusFromServer(_this.data.voteID)\n        }\n      })\n    }\n  }\n```\n\n### 实现分享投票功能\n\n​\t按照设计，参与投票页面需要实现分享投票的功能。默认情况下，小程序的所有页面都是不具备分享功能的。在模拟器中单击右上角导航栏中的菜单按钮（三个点），可以看到底部弹出的菜单提示“当前页面未设置分享”\n\n​\t\t如果希望某个页面可以分享出去，可以在页面的JS文件中加入onShareAppMessage事件处理函数。代码如下：\n\n```js\nonShareAppMessage(){\n    return{\n      title:'邀请你参与投票',\n      path:'/pages/vote/vote?voteID='+this.data.voteID\n    }\n  }\n```\n\n​\t这样页面就具备了分享的功能，分享时可以设置分享卡片的标题、页面路径和参数。实际上开发者可以指定分享的页面路径为项目中的任何一个页面，而不一定是当前页面的路径。再次单击右上角的菜单按钮，弹出的底部菜单中可以看到“转发”选项。在模拟器中单击该按钮可以查看分享卡片的预览图。\n\n​\t菜单栏中的转发选项比较隐蔽，有时用户不一定能够快速找到这个功能。处理通过菜单栏中的按钮分享页面，还可以在页面中加入button按钮组件作为分享按钮。button按钮组件又有个open-type属性，如果将该属性的值设置为share，则按钮就会称为一个分享按钮（兼容性要求基础库的版本为1.2.0以上）\n\n​\t在WXML中“确认投票”按钮的下方加入相关代码。\n\n```html\n<button open-type=\"share\" plain class=\"share\">分享投票</button>\n```\n\n​\t在WXSS中为它加入一些样式。\n\n```css\n.share{\n    margin-top: 20rpx;\n}\n```\n\n​\t这样，从创建投票到分享投票，再到用户打开参与投票页面的整个使用逻辑就用完了。\n\n### 显示投票结果\n\n​\t在实际使用中，一个用户不能对同一个投票进行重复提交。因此在投票时，除了向服务端提交用户选择的选项以外，还需要提交用户的ID。这样一来，服务端可以记录下每一个用户的所有投票信息，显然也可以通过用户ID查询到这个用户的投票信息。\n\n​\t**注：使用云开发技术实现服务端存储时，小程序会自动在请求中携带用户ID，因此暂时无需关心如何去获取用户ID**\n\n​\t显然现在已经实现了参与投票的功能，但是这个页面还可以做的完善些。当用户提交到了投票选项后，页面上应该显示这个投票目前的投票结果。如果用户在打开这个页面时已经完成了这个投票，也应该显示这个投票目前的投票结果，而不是让用户重新投票。\n\n​\t首先在data对象中增加一个voteStatus属性。代码如下：\n\n```javascript\nvoteStatus:{ //当前投票情况\n    alreadyVoted:false, //当前用户是否已经投票\n\ttotalVoteCount:0, //总投票数量\n        optionStatus:[] //每个选项的投票情况\n}\n```\n\n​\t接下来新增一个getVoteStatusFromSever函数，从服务端获取投票情况数据。同时修改onLoad函数和onTapVote函数，在页面加载时和用户投票后对该函数进行调用。代码如下：\n\n```javascript\nonLoad(options) {\n    const voteID = options.voteID\n    this.getVoteDataFormServer(voteID)\n    this.getVoteStatusFromServer(voteID)\n  },\nonTapVote(){\n    if(this.data.isAnonymous){\n      const postData ={\n        voteID:this.data.voteData,\n        pickedOption:this.data.pickedOption\n      }\n      wx.cloud.callFunction({\n        name:'vote',\n        data:{\n          postData\n        }\n      }).then(res => {\n        console.log(res)\n        this.getVoteStatusFromServer(this.data.voteID)\n      }).catch(res => {\n          console.error(res)\n          wx.showToast({\n            title: '投票失败',\n            icon:'none'\n          })\n      })\n      //TODO 将postData数据上传到服务端\n      //this.getVoteStatusFromServer(this.data.voteID)//从服务器获取投票情况\n    }else{\n      const _this = this\n\n      wx.getUserInfo({\n        success(res){\n          const postData = {\n            voteID:_this.data.voteData,\n            userInfo:res.userInfo,\n            pickedOption: _this.data.pickedOption\n          }\n          wx.cloud.callFunction({\n            name:'vote',\n            data:{\n              postData\n            }\n          }).then(res => {\n            console.log(res)\n            _this.getVoteStatusFromServer(_this.data.voteID)\n          }).catch(res => {\n            console.error(res)\n            wx.showToast({\n              title: '投票失败',\n              icon:'none'\n            })\n          })\n          //console.log(postData)\n          //TODO 将postData数据上传服务端\n          //_this.getVoteStatusFromServer(_this.data.voteID)\n        }\n      })\n    }\n  },\ngetVoteStatusFromServer(voteID){\n    /*\n    if(voteID === 'test'){\n      const voteStatus ={\n        alreadyVoted:true,\n        totalVoteCount:100,\n        optionStatus:[{\n          count:25,\n          vote:false\n        },{\n          count:35,\n          vote:false\n        },{\n          count:10,\n          vote:true\n        },{\n          count:30,\n          vote:false\n        }]\n      }\n      this.setData({\n        voteStatus\n      })\n    }else{\n      //TODO 从服务端获取投票情况\n    }*/\n    wx.cloud.callFunction({\n      name:'getVoteStatus',\n      data:{\n        voteID\n      }\n    }).then(res => {\n      console.log(res)\n      this.setData({\n        voteStatus:res.result\n      })\n    }).catch(res => {\n      console.error(res)\n      wx.showToast({\n        title: '获取投票数据失败',\n        icon:'none'\n      })\n    })\n  },\n\n```\n\n​\t然后修改WXML文件，加入显示投票结果的部分。代码如下：\n\n```html\n<!--pages/vote/vote.wxml-->\n<view class=\"container\">\n  <view class=\"title\">{{voteTitle}}</view>\n  <view class=\"desc\">\n    {{voteDesc}}\n    <text class=\"mutiple-radio\">[{{mutiple ? '多选':'单选'}}]</text>\n    <text class=\"type\">[{{isAnonymous ? '匿名':'实名'}}]</text>\n  </view>\n  <view wx:if=\"{{voteStatus.alreadyVoted}}\" class=\"option-list\">\n    <view class=\"option\" wx:for=\"{{optionList}}\">\n      <text>{{item}}</text>\n      <text class=\"vote-count\">({{voteStatus.optionStatus[index].count}} / {{voteStatus.totalVoteCount}} 票)</text>\n      <text class=\"vote-picked\" wx:if=\"{{voteStatus.optionStatus[index].vote}}\">[已选]</text>\n    </view>\n  </view>\n  <block wx:else>\n    <checkbox-group wx:if=\"{{multiple}}\" class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <checkbox value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </checkbox-group>\n    <radio-group wx:else class=\"option-list\" bindchange=\"onPickOption\">\n      <view class=\"option\" wx:for=\"{{optionList}}\">\n        <label>\n          <radio value=\"{{index}}\" disabled=\"{{isExpired}}\" />{{item}}\n        </label>\n      </view>\n    </radio-group>\n  </block>\n\n  <view class=\"end-date\">\n    截至日期:{{endDate}}\n    <text class=\"expired\" hidden=\"{{!isExpired}}\">[已过期]</text>\n  </view>\n  <button open-type=\"getUserInfo\" class=\"btn\" type=\"primary\" disabled=\"{{isExpired || pickedOption.length === 0}}\" bindtap=\"onTapVote\" >确认投票</button>\n  <button open-type=\"share\" plain class=\"share\">分享投票</button>\n</view>\n```\n\n​\t**这段代码使用了特殊的标签block。虽然block很像一个组件，但实际上它并不是一个组件。bolck不会在页面中做任何渲染，它通常只和wx:if、wx:for 属性一起使用，将条件或者列表应用到内部的所有组件上**\n\n​\t可以看到，当需要一次性判断多个组件是否条件渲染时，使用block元素实现会更加简洁。最后为页面加入WXSS样式美化显示效果。\n\n```css\n.vote-count{\n  color:#ccc\n}\n\n.vote-picked{\n  color: #09BB07;\n}\n```\n\n\n\n## 开发我的投票页面与使用tab栏切换页面\n\n​\t首先在app.json文件中新增一个页面pages/myVote/myVote，修改pages/myVote/myVote.json 文件的内容如下：\n\n```json\n{\n  \"usingComponents\": {},\n  \"navigationBarTitleText\": \"我的投票\"\n}\n```\n\n \t然后在pages/myVote/myVote.js文件中加入逻辑层的功能。代码如下：\n\n```javascript\n// pages/setup/setup.js\nPage({\n\n  /**\n   * 页面的初始数据\n   */\n  data: {\n    voteList:[]\n  },\n\n  /**\n   * 生命周期函数--监听页面加载\n   */\n  onLoad(options) {\n    this.getMyVoteListFromServer()\n  },\n\n  /**\n   * 生命周期函数--监听页面初次渲染完成\n   */\n  onReady() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面显示\n   */\n  onShow() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面隐藏\n   */\n  onHide() {\n\n  },\n\n  /**\n   * 生命周期函数--监听页面卸载\n   */\n  onUnload() {\n\n  },\n\n  /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh() {\n\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom() {\n\n  },\n\n  /**\n   * 用户点击右上角分享\n   */\n  onShareAppMessage() {\n\n  },\n\n  getMyVoteListFromServer(){\n    /*const voteList = [{\n      _id:'test',\n      voteTitle:'测试投票1',\n    },{\n      _id:'test',\n      voteTitle:'测试投票2',\n    },{\n      _id:'test',\n      voteTitle:'测试投票3',\n    }]\n    this.setData({\n      voteList\n    })*/\n    wx.cloud.callFunction({\n      name:'myVoteList'\n    }).then(res => {\n      console.log(res)\n      this.setData({\n        voteList:res.result.data\n      })\n    }).catch(res => {\n      console.error(res)\n      wx.showToast({\n        title: '获取数据失败',\n        icon:'none'\n      })\n    })\n  },\n\n  onTapVote(e){\n    const voteID = e.currentTarget.dataset.voteID\n    wx.navigateTo({\n      url:'/pages/vote/vote?voteID='+voteID,\n    })\n  }\n})\n```\n\n​\t在pages/myVote/myVote.wxml文件中加入视图层的结构。代码如下：\n\n```html\n<!--pages/setup/setup.wxml-->\n<view class=\"container\">\n  <block wx:for=\"{{voteList}}\">\n    <view class=\"vote\" bindtap=\"onTapVote\" data-vote-id=\"{{item._id}}\">{{item.voteTitle}}</view>\n  </block>\n</view>\n```\n\n​\t最后在pages/myVote/myVote.wxss文件中为页面新增加一些样式。代码如下：\n\n```css\n/* pages/setup/setup.wxss */\n.vote{\n  margin: 20rpx;\n  padding: 24rpx;\n  background: #eee;\n  border-bottom: 1rpx solid #fff;\n}\n```\n\n### 使用tab栏切换页面\n\n​\t现在，首页与我的投票页面认识两个普通的页面，需要在app.json文件中设置tabBar属性，将它们设置为tab栏中的页面。代码如下：\n\n```json\n\"tabBar\":{\n    \"backgroundColor\": \"#fff\",\n    \"color\": \"#333\",\n    \"selectedColor\": \"#26AB28\",\n    \"position\": \"bottom\",\n    \"list\": [{\n      \"pagePath\":\"pages/index/index\",\n      \"text\": \"新建\",\n      \"iconPath\": \"/pages/imgs/新建.png\",\n      \"selectedIconPath\": \"/pages/imgs/新建-02.png\"\n    },{\n      \"pagePath\": \"pages/setup/setup\",\n      \"text\":\"我的\",\n      \"iconPath\":\"/pages/imgs/设置-fill-01.png\",\n      \"selectedIconPath\": \"/pages/imgs/设置-fill-02.png\"\n    }\n  ]\n},\n```\n\n​\t这样两个页面就可以通过单击tab栏的按钮访问了。"},{"title":"微信小程序开发实例(一)——代码构成","url":"/2022/09/05/微信小程序开发实例-一-——代码构成/","content":"\n# 微信小程序的代码构成\n\n1、.json 后缀的JSON配置文件\n\n2、.wxml 后缀的WXML配置文件\n\n3、.wsxx 后缀的WXSS配置文件\n\n4、.js 后缀的JS脚本文件\n\n## JSON配置\n\n项目根目录中有app.json和project.config.json，在pages/logs目录下还有一个logs.json\n\n### 小程序配置app.json\n\n包括所有的页面路径和界面表现、网络超时时间、底部tab等。\n\n<!-- more -->\n\n解释：\n\n1、pages字段——用于描述页面路径\n\n2、window字段——定义小程序所有页面的顶部背景颜色、文字颜色定义等。\n\n### 工具配置project.config.json\n\n通常大家在使用一个工具的时候，都会针对各自喜好做一些个性化配置，例如界面颜色、编译配置等等，当你换了另外一台电脑重新安装工具的时候，你还要重新配置。\n\n考虑到这点，小程序开发者工具在每个项目的根目录都会生成一个 `project.config.json`，你在工具上做的任何配置都会写入到这个文件，当你重新安装工具或者换电脑工作时，你只要载入同一个项目的代码包，开发者工具就自动会帮你恢复到当时你开发项目时的个性化配置，其中会包括编辑器的颜色、代码上传时自动压缩等等一系列选项。\n\n### 页面配置page.json\n\n这里的 `page.json` 其实用来表示 pages/logs 目录下的 `logs.json` 这类和小程序页面相关的配置。\n\n如果你整个小程序的风格是蓝色调，那么你可以在 `app.json` 里边声明顶部颜色是蓝色即可。实际情况可能不是这样，可能你小程序里边的每个页面都有不一样的色调来区分不同功能模块，因此我们提供了 `page.json`，让开发者可以独立定义每个页面的一些属性，例如刚刚说的顶部颜色、是否允许下拉刷新等等\n\n## JSON语法\n\n这里说一下小程序里 JSON 配置的一些注意事项。\n\nJSON文件都是被包裹在一个大括号中 {}，通过 key-value 的方式来表达数据。JSON的 Key 必须包裹在一个双引号中，在实践中，编写 JSON 的时候，忘了给 Key 值加双引号或者是把双引号写成单引号是常见错误。\n\nJSON的值只能是以下几种数据格式，其他任何格式都会触发报错，例如 JavaScript 中的 undefined。\n\n1. 数字，包含浮点数和整数\n2. 字符串，需要包裹在双引号中\n3. Bool值，true 或者 false\n4. 数组，需要包裹在方括号中 []\n5. 对象，需要包裹在大括号中 {}\n6. Null\n\n还需要注意的是 JSON 文件中无法使用注释，试图添加注释将会引发报错\n\n## WXML模板\n\n从事过网页编程的人知道，网页编程采用的是 HTML + CSS + JS 这样的组合，其中 `HTML` 是用来描述当前这个页面的结构，`CSS` 用来描述页面的样子，`JS` 通常是用来处理这个页面和用户的交互。\n\n同样道理，在小程序中也有同样的角色，其中 `WXML` 充当的就是类似 `HTML` 的角色。打开 `pages/index/index.wxml`，你会看到以下的内容:\n\n```html\n<view class=\"container\">\n  <view class=\"userinfo\">\n    <button wx:if=\"{{!hasUserInfo && canIUse}}\"> 获取头像昵称 </button>\n    <block wx:else>\n      <image src=\"{{userInfo.avatarUrl}}\" background-size=\"cover\"></image>\n      <text class=\"userinfo-nickname\">{{userInfo.nickName}}</text>\n    </block>\n  </view>\n  <view class=\"usermotto\">\n    <text class=\"user-motto\">{{motto}}</text>\n  </view>\n</view>\n```\n\n和 `HTML` 非常相似，`WXML` 由标签、属性等等构成。但是也有很多不一样的地方，我们来一一阐述一下：\n\n1. 标签名字有点不一样\n\n   往往写 HTML 的时候，经常会用到的标签是 `div`, `p`, `span`，开发者在写一个页面的时候可以根据这些基础的标签组合出不一样的组件，例如日历、弹窗等等。换个思路，既然大家都需要这些组件，为什么我们不能把这些常用的组件包装起来，大大提高我们的开发效率。\n\n   从上边的例子可以看到，小程序的 `WXML` 用的标签是 `view`, `button`, `text` 等等，这些标签就是小程序给开发者包装好的基本能力，我们还提供了地图、视频、音频等等组件能力。\n\n   更多详细的组件讲述参考下个章节 [小程序的能力](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html)\n\n2. 多了一些 `wx:if` 这样的属性以及 \\{ \\{  \\} \\} 这样的表达式\n\n   在网页的一般开发流程中，我们通常会通过 `JS` 操作 `DOM` (对应 `HTML` 的描述产生的树)，以引起界面的一些变化响应用户的行为。例如，用户点击某个按钮的时候，`JS` 会记录一些状态到 `JS` 变量里边，同时通过 `DOM` API 操控 `DOM` 的属性或者行为，进而引起界面一些变化。当项目越来越大的时候，你的代码会充斥着非常多的界面交互逻辑和程序的各种状态变量，显然这不是一个很好的开发模式，因此就有了 MVVM 的开发模式（例如 React, Vue），提倡把渲染和逻辑分离。简单来说就是不要再让 `JS` 直接操控 `DOM`，`JS` 只需要管理状态即可，然后再通过一种模板语法来描述状态和界面结构的关系即可。\n\n   小程序的框架也是用到了这个思路，如果你需要把一个 `Hello World` 的字符串显示在界面上。\n\n   WXML 是这么写 :\n\n   ```html\n   <text>{{msg}\\}</text>\n   ```\n\n   JS 只需要管理状态即可:\n\n   ```js\n   this.setData({ msg: \"Hello World\" })\n   ```\n\n   通过\\{ \\{  \\} \\} 的语法把一个变量绑定到界面上，我们称为数据绑定。仅仅通过数据绑定还不够完整的描述状态和界面的关系，还需要 `if`/`else`, `for`等控制能力，在小程序里边，这些控制能力都用 `wx:` 开头的属性来表达。\n\n## WXSS 样式\n\n`WXSS` 具有 `CSS` 大部分的特性，小程序在 `WXSS` 也做了一些扩充和修改。\n\n1. 新增了尺寸单位。在写 `CSS` 样式时，开发者需要考虑到手机设备的屏幕会有不同的宽度和设备像素比，采用一些技巧来换算一些像素单位。`WXSS` 在底层支持新的尺寸单位 `rpx` ，开发者可以免去换算的烦恼，只要交给小程序底层来换算即可，由于换算采用的浮点数运算，所以运算结果会和预期结果有一点点偏差。\n2. 提供了全局的样式和局部样式。和前边 `app.json`, `page.json` 的概念相同，你可以写一个 `app.wxss` 作为全局样式，会作用于当前小程序的所有页面，局部页面样式 `page.wxss` 仅对当前页面生效。\n3. 此外 `WXSS` 仅支持部分 `CSS` 选择器\n\n## JS 逻辑交互\n\n一个服务仅仅只有界面展示是不够的，还需要和用户做交互：响应用户的点击、获取用户的位置等等。在小程序里边，我们就通过编写 `JS` 脚本文件来处理用户的操作。\n\n```html\n<view>{\\{ msg }\\}</view>\n<button bindtap=\"clickMe\">点击我</button>\n```\n\n点击 `button` 按钮的时候，我们希望把界面上 `msg` 显示成 `\"Hello World\"`，于是我们在 `button` 上声明一个属性: `bindtap` ，在 JS 文件里边声明了 `clickMe` 方法来响应这次点击操作：\n\n```js\nPage({\n  clickMe: function() {\n    this.setData({ msg: \"Hello World\" })\n  }\n})\n```\n\n响应用户的操作就是这么简单，更详细的事件可以参考文档 [WXML - 事件](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html) 。\n\n此外你还可以在 JS 中调用小程序提供的丰富的 API，利用这些 API 可以很方便的调起微信提供的能力，例如获取用户信息、本地存储、微信支付等。在前边的 QuickStart 例子中，在 `pages/index/index.js` 就调用了 [wx.getUserInfo](https://developers.weixin.qq.com/miniprogram/dev/api/open-api/user-info/wx.getUserInfo.html) 获取微信用户的头像和昵称，最后通过 `setData` 把获取到的信息显示到界面上。更多 API 可以参考文档 [小程序的API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html) 。\n\n通过这个章节，你了解了小程序涉及到的文件类型以及对应的角色，在[下个章节](https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/framework.html)中，我们把这一章所涉及到的文件通过 “小程序的框架” 给 “串” 起来，让他们都工作起来。"},{"title":"字符串hash","url":"/2022/09/02/字符串hash/","content":"\n# 字符串hash初步\n\n## 散列的定义与整数散列\n\n先看一个简单问题：\n\n给出N个正整数，再给出M个正整数，问这M个数中的每个数分别是否在N个数中出现过，其中N,M<=10^5,且所有正整数均不过10^5.\n\n对于这个问题最直观的思路是：对每个要查询的正整数x，遍历所有N个数，看是否有一个属与x相等。这种做法的时间复杂度是O(NM),当N与M都很大，显然是无法承受的。\n\n不妨让空间来换时间，设置bool型数组hashTable[100010]来判断这个数是否存在，在输入时就令hashtable[i] = true(hashtable数组要提前初始化为false)，在输入M个数时就可以直接做判断 ，复杂度由O(NM)变成了O(N+M)\n\n<!--more-->\n\n示例：\n\n```cpp\n#include<bits/stdc++.h>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define maxn 100010\nbool hashtable[maxn] = {false};\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\thashtable[k] = true;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin>>k;\n\t\tif(hashtable[k]==true){\n\t\t\tcout<<\"YES\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<\"NO\"<<endl;\n\t\t}\n\t}\n\t\n} \n```\n\n如果要求M个要查询的数每个数在N中出现的次数，那么可以把hashtable换成int型,输入n个数时hashtable[i]++表示这个数出现的次数，复杂度O(N+M)\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 100010;\nint hashtable[N] = {0};\n\nint main(){\n\tint n,m,k;\n\tcin>>n>>m;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>k;\n\t\thashtable[k]++;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin>>k;\n\t\tcout<<k<<\" \"<<hashtable[k]<<endl;\n\t}\n}\n```\n\n上面示例都是空间换时间的经典思想——将输入的数作为下标，对这个数的性质进行统计\n\n如果是数的范围在10^5内这个方法是可行的，但是如果这个数本身超过了10^5的范围呢？\n\n这个时候就要就需要**散列(hash)**了。\n\n**散列的定义：将元素通过一个函数转换为整数，使得该整数尽可能唯一的表示一个元素，也就是说一个元素变换前为Key,变换后会变成H(Key)**\n\n散列函数一般有三种：直接定址法，除留余数法，平方取中法\n\n其中最常用的是除留余数法，即对于Key使得H(Key) = Key%mod,但是这样会有许多数\n\n虽然不相等，但是获得的H(Key)是一样的，我们可以选择一个素数来做mod，这样可以尽可能的让不同的Key得到的H(Key)也不同，但是就算是素数做mod也依然会出现两个不同的Key拥有相同的H(Key)的情况，这个时候会出现**冲突**，冲突不能避免，但是可以解决\n\n1）线性探查法（Linear Probing）\n\n如果H(Key)被占用，那么就将H(Key)+1的位置用来存放Key，但是这样会出现数据过多导致数据扎堆的情况，如果连续多个位置都被使用的话，那么存储数据会很费时间\n\n2）平方探查法（Quadratic probing）\n\n如果H(Key)的位置被占的时候，就依次查询H(Key)+1^2,H(Key)-1^2,H(Key)+2^2,H(Key)-2^2....H(Key)+k^2,如果k^2超出范围的话就将H(Key)+k^2取模，如果出现H(Key)-k^2<0的情况，就探查((H(Key)-k^2)%mod+mod)%mod,\n\n3）链地址法（拉链法）\n\n和上面两种方法不同，链地址法不计算新的hash值，而是把所有H(Key)相同的key连接成一条单链表。\n\n还有STL中的map也可以直接帮助我们hash，所以以上可以只做了解\n\n## 字符串hash\n\n**字符串hash是指将一个字符串S映射成一个整数，使得该整数尽可能唯一的代表字符串S.**\n\n假设字符串由A~Z组成他们可以由0-25表示，这样就可以按照26进制转化10进制的思路来hash字符串S，实现代码如下：\n\n```cpp\nint hashFun(char s[],int len){\n\tint id = 0;\n\tfor(int i=0;i<len;i++){\n\t\tid = id*26 + s[i]-'A';\n\t}\n\treturn id;\n} \n```\n\n如果字符串由A~Z与a~z组成，那么问题就从26进制转换10进制变成了52进制转换为10进制的问题，实现代码：\n\n```cpp\nint hashFun(char s[],int len){\n\tint id = 0;\n\tfor(int i=0;i<len;i++){\n\t\tif(s[i]>='A'&&s[i]<='Z')//在ASCII码中，A~Z的码为65-90而a开始为97,所以要分开算\n\t\t\tid = id*52 + s[i]-'A';\n\t\telse if(s[i]>='a'&&s[i]<='z'){\n\t\t\tid = id*52 + s[i]-'a'+26;\n\t\t}\n\t}\n\treturn id;\n} \n```\n\n如果字符串中出现数字的话有两种处理方法：\n\n1）按照小写字母的处理方法，进制数增大至62\n\n2）如果确定数字在字符串末尾，那么可以先算出前几位，最后只要加上最后一位数字即可\n\n```cpp\nint hashFun(char s[],int len){\n\tint id = 0;\n\tfor(int i=0;i<len;i++){\n\t\tif(s[i]>='A'&&s[i]<='Z')\n\t\t\tid = id*62 + s[i]-'A';\n\t\telse if(s[i]>='a'&&s[i]<='z'){\n\t\t\tid = id*62 + s[i]-'a'+26;\n\t\t}\n\t\telse if(s[i]>='0'&&s[i]<='9'){\n\t\t\tid = id*62+s[i]-'0'+52;\n\t\t}\n\t}\n\treturn id;\n} \n```\n\n问题：\n\n给出N个字符串刚好都是由三个大写字母表示的，查询M个字符串，问每个字符串的出现次数\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1000;\nint hashTable[26*26*26+10]={0},n,m;\nchar s[N][5],temp[5];\n\nint hashFun(char s[],int len){\n\tint id = 0;\n\tfor(int i=0;i<len;i++){\n\t\tid = id*52 + s[i]-'A';\n\t}\n\treturn id;\t\n}\n\nint main(){\n\tcin>>n>>m;\n\t\n\tfor(int i=0;i<n;i++){\n\t\tcin>>s[i];\n\t\tint id = hashFun(s[i],3);\n\t\thashTable[id]++;\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tcin>>temp;\n\t\tint id = hashFun(temp,3);\n\t\tcout<<hashTable[id]<<endl;\n\t}\n}\n```\n\n字符串hash进阶\n\n如果对较长的字符串使用上面的hash方式会出现存储溢出的现象，我们可以对这个数进行取模运算。不过在int数据范围内，如果把进制数设置成一个10^7级别的素数p（如：10000019），同时把mod换成10^9的级别的素数（例如：1000000007），那么冲突的概率会变得很小，如下所示：\n\n```cpp\nH[i] = (H[i-1]*p+index(str[i]))%mod\n```\n\n来看问题：\n\n给出N个只有小写字母的字符串，求其中不同的字符串的个数\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MOD = 1000000007;\nconst int P = 10000019;\n#define N 10000\nint a[N];\nchar s[N][N];\n\nint hashFun(char s[]){\n\tint ls = strlen(s),id = 0;\n\tfor(int i=0;i<ls;i++){\n\t\tid = (id*P+s[i]-'a')%MOD;\n\t}\n\treturn id;\n}\n\nint main(){\n\tint n,ans = 0;\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>s[i];\n\t\ta[i] = hashFun(s[i]);\n\t}\n\t\n\tsort(a,a+n);\n\tfor(int i=0;i<n-1;i++){\n\t\tif(i==0||a[i]!=a[i+1]){\n\t\t\tans++;\n\t\t}\n\t}\n\t\n\tcout<<ans;\n}\n```\n\n"},{"title":"简单数学问题","url":"/2022/09/02/简单数学问题/","content":"\n# 数学问题\n\n## 最大公约数与最小公倍数\n\n### 最大公约数\n\n正整数a与b的最大公约数是指a与b的所有公约数中最大的乃个公约数，例如4和6的最大公约数为2，3和9的最大公约数为3。一般用gcd(a,b)来表示a和b的最大公约数，而最大公约数常用到欧几里得算法（辗转相除法）\n\n<!--more-->\n\n欧几里得算法：\n\n设a与b均为正整数，则gcd(a,b) = gcd(a,a%b)。\n\n利用递归可以解决这个问题：\n\n1）递归式：gcd(a,b) = gcd(a,a%b)\n\n2）递归边界：gcd(a,0) = a;\n\n实现代码：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint gcd(int a,int b){//递归实现函数\n\tif(b==0) return a;\n\telse gcd(b,a%b);\n}\n\nint main(){\n\tint a,b;\n\tcin>>a>>b;\n\t\n\tint x = gcd(a,b);\n\tcout<<x;\n}\n```\n\n**这里我还以为a%b是否需要根据a、b大小交换a与b再做gcd()运算，但其实不需要的，如果是小数%大数的话是本身，在gcd函数中相当于用一次运算进行了交换，甚至比一般的交换方法更快**\n\n对于递归的实现函数还有更快速的方法\n\n```c++\nint gcd(int a,int b){\n\treturn !b ? a : gcd(b,a%b);\n}\n```\n\n读者可以自行体会\n\n### 最小公倍数\n\n正整数a与b的最小公倍数是指a和b的所有公倍数中最小的乃个公倍数，例如4和6的最小公倍数是12，3 和9的最小公倍数是9。一般用lcm(a,b)来表示最小公倍数。\n\n最小公倍数可以由最大公约数d得到：\n\n```c++\nd = gcd(a,b);\nlcm(a,b) = a*b/d;\n```\n\n实现代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint gcd(int a,int b){\n\treturn !b ? a : gcd(b,a%b);\n}\n\nint main(){\n\tint a,b;\n\tcin>>a>>b;\n\t\n\tint d = gcd(a,b);\n\tcout<<\"最大公约数为 \"<<d<<endl;\n\t\n\tcout<<\"最小公倍数为 \"<<a/d*b<<endl; \n}\n```\n\n**这里的a*b可能会溢出，所以可以用a/d *b来代替**\n\n## 素数\n\n素数又称质数，是指除了1和本身之外，不能被其他整数整除的一类数。\n\n即对给定的任意正整数n都有正整数a(a<n&&a!=1)--n%a=0成立，那么n就是素数\n\n这里主要解决两个问题\n\n1）如何判断给定的n是不是素数\n\n2）如何在较短时间内得到1-n的素数表\n\n### 素数判断\n\n开根号法——O(sqrt(n))\n\n1）\n\n对于n取根号，只要a在2-floor(sqrt(n))上没有n%a==0,则n是素数\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nbool isPrime(int n){ \n\tint sqr = (int)sqrt(1.0*n);//sqrt函数只有浮点型 \n\tfor(int i=2;i<=sqr;i++){\n\t\tif(n%i==0) return 0;\n\t}\n\treturn 1;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tif(isPrime(n)){\n\t\tcout<<\"Yes\";\n\t}\n\telse cout<<\"No\"; \n    return 0;\n}\n```\n\n**这里的sqrt()函数需要用到math.h头文件，还有一种对于int n更加方便的操作，但是大数有溢出的肯可能**\n\n函数如下：\n\n```c++\nbool isPrime(int n){ \n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0) return 0;\n\t}\n\treturn 1;\n}\n```\n\n### 1-n素数表的获取\n\n对于前面的简单的对于n是否为素数的判断，打印1-n的素数表的方法，就是对1-n的所有数进行枚举，判断每个素数是否都是素数，如果是素数就将其加入素数表。但是这种算法枚举部分的时间复杂度达到了O(n)，判断是否为素数的部分时间复杂度是O(sqrt(n)),这样最后的复杂度高达O(n*sqrt(n))，对于n超过10^5的数据会溢出\n\n代码如下：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nbool isPrime(int n){//判断是否为素数的函数 \n\tfor(int i=2;i*i<=n;i++){\n\t\tif(n%i==0) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tint a[n+1],b[n+1],sum = 0;//sum用来计数，b用来记录素数表 \n\tfor(int i=0;i<n+1;i++) a[i] = 1;//初始化，默认所有的数都是素数 \n\t//这里从1开始计数便于理解 \n\t\n\ta[0] = 0;\n\ta[1] = 0;//直接确定0,1都不是素数防止判断失误 \n\tfor(int i=2;i<n+1;i++){\n\t\tif(isPrime(i)==false){\n\t\t\ta[i] = 0;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i =0;i<n+1;i++){//打印素数表 \n\t\tif(a[i]){\n\t\t\tcout<<i<<\" \";\n\t\t}\n\t}\n}\n```\n\n接下来会对这种方法进行改进\n\n### 埃氏筛法\n\n算法复杂度为O(nloglogn)\n\n筛去每一个素数的所有倍数，剩下的就会都是素数了。这个筛的动作可以由bool型数组来实现,这个方法不必用到前面的素数判断的方法\n\n实现代码：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000\nint prime[N],priNum = 0;//prime存储所有素数，priNum表示素数个数 \nbool pri[N] = {0};//记录是否为素数 \n\nint find_Prime(){\n\tfor(int i=2;i<N;i++){\n\t\tif(pri[i]==false){\n\t\t\tprime[priNum++] = i;//存放素数 \n\t\t\tfor(int j=i+i;j<N;j+=i){\n\t\t\t\tpri[j] = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tfind_Prime(); \n\t\n\tfor(int i = 0;i<=priNum;i++) cout<<prime[i]<<\" \";//打印素数 \n}\n```\n\n## 质因子分解\n\n所谓的质因子分解是将一个正整数n写成一个或者多个质数的乘积的形式，例如6=2**3,8= 2 * *2* *2,180 = 2 * 2 * 3 * 3 * 5。\n\n**1本身不是素数，因此也没有质因子，题目中如果有出现1，将要进行特判处理**\n\n同时因为一个质因数不一定只出现一次，所以可以定义结构体来存放质因子以及出现的次数\n\n```c++\nstruct fator{\n    int x,cnt;//x是质因子，cnt是质因子的个数\n}fac[10]\n```\n\n**这里的质因子分解考虑到是int范围内,而2 * 3 * 5 * 7 * 11 * 13 *17 * 19 * 23 * 29已经超过了int范围，所以fac数组只需开10就差不多了 **\n\n之前素数的判断里质因子的出现都是在sqrt(n)两边对应的，所以在求质因子时我们也可以用到sqrt(n)\n\n代码实现：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000\nint prime[N],pNum=0;\nbool pri[N]={0};\n\nint find_Prime(){//素数表\n\tfor(int i=2;i<N;i++){\n\t\tif(pri[i]==false){\n\t\t\tprime[pNum++] = i;\n\t\t\tfor(int j = i+i;j<N;j+=i){\n\t\t\t\tpri[j] = 1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nstruct factor{\n\tint x,cnt;//x是质因子，cnt是质因子的个数 \n}fac[10];//int范围内最多有十个不同的质因子 \n\nint main(){\n\tfind_Prime();\n\t\n\tint n,num=0;\n\tcin>>n;\n\t\n\tcout<<n<<\"=\";\n\tif(n==1) {cout<<1;return 0;}//特判\n\telse{\n\t\tint sqr = (int)sqrt(1.0*n);\n\t\tfor(int i=0;i<pNum&&prime[i]<=sqr;i++){\n\t\t\tif(n%prime[i]==0){\n\t\t\t\tfac[num].x = prime[i];\n\t\t\t\tfac[num].cnt = 0;\n\t\t\t\twhile(n%prime[i]==0){\n\t\t\t\t\tfac[num].cnt++;\n\t\t\t\t\tn /= prime[i];\n\t\t\t\t}\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tif(n==1) break;//及时止损 \n\t\t}\n\t\tif(n!=1){//出现比根号n更大的质因子 \n\t\t\tfac[num].x = n;//此时的n就是最大质因子 \n\t\t\tfac[num++].cnt = 1;\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<num-1;i++) cout<<fac[i].x<<\"^\"<<fac[i].cnt<<\"*\";\n\tcout<<fac[num-1].x<<\"^\"<<fac[num-1].cnt;\n}\n```\n\n## 快速幂\n\n快速幂问题如下：\n\n给定三个数a,b,m（a<10^9,**b<10^6**,1<m<10^9），求a^b/m\n\n对于这个问题，一般的for循环就可以解决，时间复杂度是O(b)\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tlong long a,b,m;\n\tcin>>a>>b>>m;\n\t\n\tlong long x;\n\tfor(int i=0;i<b;i++){\n\t\tx = x*a%m;\n\t}\n\t\n\tcout<<x;\n\t\n} \n```\n\n如果这个问题更近一步：\n\n给定三个数a,b,m(a<10^9,**b<10^18**,1<m<10^9),求a^b%m（这里的b的范围更大）\n\n对于这里的问题，用刚刚的方法已经不可能了，O(b)的复杂度支持b<10^8都很困难，对于10^18就更不可能了。\n\n这里要用快速幂的方法，它基于二分的思想，因此也常称为二分幂。该幂基于以下事实：\n\n1）如果b是奇数，a^b = a*a^b-1\n\n2）如果b是偶数，a^b = a^(b/2) * a^(b/2)\n\n利用递归思想就可以实现O(logb)复杂度的快速幂了,**要注意的是，任何数对1取模最后的结果都是0，所以可以对m做特判，如果m==1，可以直接输出0结束**\n\n实现代码：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\nLL binaryPow(LL a,LL b,LL m){//快速幂 \n\tif(b==0) return 1;\n\tif(b%2==1) return a*binaryPow(a,b-1,m)%m;\n\telse{\n\t\tint bP = binaryPow(a,b/2,m);\n\t\treturn bP*bP%m;\n\t}\n}\n\nint main(){\n\tLL a,b,m;\n\tcin>>a>>b>>m;\n\t\n\tif(m==1){//特判，任何数对1取模都是0 \n\t\tcout<<0;\n\t\treturn 0;//直接结束，节省时间\n\t}\n\tLL ans = binaryPow(a,b,m);\n\tcout<<ans;\n}\n```\n\n"},{"title":"动态规划初学","url":"/2022/09/02/动态规划初学/","content":"\n#  动态规划专题\n\n动态规划（Dynamic　Programming，DP）是一种用来解决最优化问题的算法思想。简单来说，动态规划将一个复杂问题分解成若干子问题，通过综合子问题的最优解来得到更复杂的原问题放入最优解。\n\n**动态规划一般可以用递推或者递归的方法来使用**\n\n动态规划会将之前求的每一个子问题的最优解记录下来,下次遇到相同的问题可以直接使用结果,避免重复运算\n\n动态规划的核心是**设计状态的状态转移方程**\n\n<!--more-->\n\n## 最大连续子序列的和\n\n最大连续子序列和的问题如下:\n\n​\t给定一个数字序列:A0,A1,A2,...,An,求i,j(1<=i<=j<=n),使得Ai+....+Aj最大.输出这个最大和\n\n样例:\n\n```cpp\n输入\n6\n-2 11 -4 13 -5 -2\n输出\n20\n```\n\n令状态dp[i]为以A[i]为结尾的连续序列最大和\n\n以上为目的求dp[i]会出现两种情况\n\n1)最大和只有一个元素,就是A[i]本身\n\n2)这个最大和的连续序列和是多个元素,则dp[i] = dp[i-1]+A[i];\n\n于是得到状态方程:\n\n```cpp\ndp[i] = max{A[i],dp[i-1]+A[i]}\n```\n\n实现代码:\n\n```cpp\n#include<bits/stdc++.h>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 1000\nint dp[N],a[N];\n\nint main(){\n\tint n;\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++) cin>>a[i];//输入连续序列\n\t \n\tdp[1] = a[1];//初始化dp \n\t\n\tfor(int i=2;i<=n;i++){//创建dp数组 \n\t\tdp[i] = max(a[i],dp[i-1]+a[i]);\n\t}\n\t\n\tint max = 0;\n\tfor(int i=0;i<n;i++){//找出原问题的最优解\n\t\tif(dp[i]>max) max = dp[i];\n\t}\n\t\n\tcout<<max;\n\t\n} \n```\n\n## 最长不下降子序列(LIS)\n\n最长不下降子序列(longest Increasing Sequence,LIS)是这样一个问题:\n\n在一个数字序列中,找到一个最长的子序列(可以不连续),是的这个子序列是不下降(非递减)的\n\n样例\n\n```cpp\n输入\n7\n1 2 3 -1 -2 7 9\n输出\n5\n```\n\n令dp[i]表示以A[i]结尾的最长不下降子序列长度\n\n以上情况会出现两种可能\n\n1)如果存在A[i]之前的元素A[j] (i>j) ,使得A[i]<A[j]且dp[j]+1>dp[i] (即把A[i]跟在A[j]结尾的LIS后面时能比当前以A[i]结尾的LIs长度更长),那么就把A[i]跟在以A[j]结尾的LIS后面,形成一条更长的不下降子序列(dp[i] = dp[j]+1)\n\n2)如果A[i]之前的元素都比A[i]大,则A[i]自己形成一条LIS,长度为1\n\n于是得到状态转移方程\n\n```cpp\ndp[i] = max{dp[j]+1,1}(j=1,2,...,i-1&A[j]<A[i])\n```\n\n实现代码\n\n```cpp\n#include<bits/stdc++.h>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 1000\nint dp[N],a[N];\n\nint main(){\n\tint n;\n\tcin>>n;\n    \n\tfor(int i=1;i<=n;i++) cin>>a[i];//输入连续序列 \n\tint ans = -1;//用来确定最长子序列 \n    \n\tfor(int i=1;i<=n;i++){//分解确定最优解 \n\t\tdp[i] = 1;//先假定每一个数字都自己成为一个序列 \n\t\tfor(int j = 1;j<=i-1;j++){\n\t\t\tif(a[i]>=a[j]&&dp[j]+1>dp[i])\n\t\t\t\tdp[i] = dp[j]+1;\n\t\t}\n\t\tans = (ans,dp[i]);\n\t}\n    \n\tcout<<ans;\n}\n```\n\n\n\n## 最长公共子序列(LCS)\n\n最长公共子序列(Longest Common Subsequence,LCS)的问题描述为:\n\n给定两个字符串(或数字序列)A和B,求一个字符串,使得这个字符串是A和B的最长公共部分\n\n样例\n\n```cpp\n输入\nsadstory\nadminsorry\n输出\n6\n```\n\n令dp[i] [j]表示字符串A的i号位和字符串B的j号位之前的LCS长度,\n\n根据A[i]与B[j]的情况,分为两种决策\n\n1)若A[i]==B[j],则字符串A与字符串B的LCS增加了一位，即有dp[i] [j] = dp[i-1] [j-1]+1\n\n例如\n\n2）若A[i]!=B[j],dp[i] [j] = max{dp[i-1] [j],dp[i] [j-1]}\n\n实现代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000\nint dp[N][N]={0};\nchar a[N],b[N];\n\nint main(){\n\tgets(a+1);\n\tgets(b+1);//获得字符串 \n\tint la = strlen(a+1),lb = strlen(b+1);//获得字符串长度 \n\t\n\tfor(int i=1;i<=la;i++){\n\t\tfor(int j=1;j<=lb;j++){\n\t\t\tif(a[i]==b[i]) dp[i][j] = dp[i-1][j-1]+1;\n\t\t\telse dp[i][j] = max(dp[i-1][j],dp[i][j-1]);\n\t\t}\n\t}\n\t\n\tcout<<dp[la][lb];\n}\n```\n\n\n\n## 最长回文子串\n\n最长回文子串的问题描述：\n\n给出一个字符串S，求S的最长回文子串的长度\n\n样例\n\n```cpp\n输入\nPATZJUJZTACCBCC\n输出\n9\n```\n\n令dp[i] [j] 表示S[i]至S[j] 所表示的字符串是否是回文子串，是则为1不是为0，这样根据S[i]是否等于S[j],这样的情况分为两类\n\n1）若S[i]==S[j],那么只要S[i+1]与S[j-1]是回文子串，那么S[i]与S[j]是回文子串，否则不是回文子串\n\n2）若S[i]!=S[j],那么不是回文子串\n\n**字符的枚举顺序如果是从字符串开头枚举会有重复计算S[i+1]与S[j-1]的可能，所以这里的枚举需要枚举字符串的长度与字符子串的初始位置**\n\n实现代码\n\n```cpp\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 1000\nint dp[N][N]={0};\nchar s[N];\nint main(){\n\tgets(s);\n\tint ls = strlen(s),ans = 1;//获得字符串\n\t\n\tfor(int i=0;i<ls;i++){//初始化 \n\t\tdp[i][i] = 1;\n\t\tif(i<ls-1){\n\t\t\tif(s[i]==s[i+1]){\n\t\t\t\tans = 2;\n\t\t\t\tdp[i][i+1] = 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int L = 3;L<=ls;L++){//遍历字符串长度 \n\t\tfor(int i=0;i+L-1<ls;i++){\n\t\t\tint j = i+L-1;\n\t\t\tif(s[i]==s[j]&&dp[i+1][j-1]==1){\n\t\t\t\tdp[i][j] = 1;\n\t\t\t\tans = L;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<<ans;\n}\n```\n\n\n\n## 数塔DP（动态规划递推算法）\n\n经典的数塔问题：\n\n将一些数字排成数塔状，第一层一个数字，第二层两个数字......第n层有n个数字。现在要从第一层走到最后一层，每次只能走下一层链接的两个数字中的一个，问：最后将路径上的所有数字相加后得到的最大和是多少\n\n![](F:\\Typora\\Typora\\md\\算法\\picture\\1027427-20190322165707282-1276411958.png)\n\n[^]: 图片来自百度\n\n尝试穷举路径所有可能的话最后的复杂度为O(2^n)，产生这莫大的复杂度最根本的原因来自于重复遍历，不妨设dp[i] [j]表示这个i->j的路径上的最大和；\n\n可以得到状态转移方程为：\n\n```cpp\ndp[i][j] = max{dp[i+1][j],dp[i+1][j+1]}+a[i][j]\n```\n\n实现代码：\n\n```cpp\n#include<bits/stdc++.h>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 1000\nint n,a[N][N]={0},dp[N][N] = {0};\n\nint main(){\n\tcin>>n;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j = 1;j<=i;j++){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\t\n\tfor(int j = 1;j<=n;j++){\n\t\tdp[n][j] = a[n][j];\n\t}\n\t\n\tfor(int i = n-1;i>=1;i--){\n\t\tfor(int j = 1;j<=i;j++){\n\t\t\tdp[i][j] = max(dp[i+1][j],dp[i+1][j+1])+a[i][j];\n\t\t}\n\t}\n\t\n\tcout<<dp[1][1];\n\t\n}\n/*\n5\n5\n8 3\n12 7 16\n4 10 11 6\n9 5 3 9 4\n*/\n```\n\n\n\n## ０１背包\n\n01背包问题描述：\n\n有n件物品，每件物品的重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得背包的总价值最大。其中每件物品都只有一件\n\n样例\n\n```cpp\n输入\n5 8//n==5,V==8\n3 5 1 2 2//w[i]\n4 5 2 1 3//c[i]\n输出\n10\n```\n\n令dp[i] [v]表示前i件物品恰好装进容量为v的包里所能获得的最大价值\n\n依然有两种策略\n\n1）不放第i件物品，那么问题转化为前i-1件物品恰好装进容量为v的背包中所能获得的最大价值，也即dp[i-1] [v]\n\n2) 放第i件物品,那么问题转为前i-1件物品恰好装入容量为v-w[i]的背包中所能获得的最大价值，也即dp[i-1] [v-w[i]]+c[i]\n\n因此得到状态转移方程：\n\n```cpp\ndp[i][v] = max{dp[i-1][v],dp[i-1][v-w[i]]+c[i]}\n```\n\n上面的时间复杂度已经无法优化，但是空间复杂度还有优化的空间。\n\n对于dp[i] []的求解，只会用到dp[i-1] []的数据，对于dp[i+1] []的求解，只会用到dp[i] []的数据，所以可以只开一个数组dp[v]，利用逆序来求解\n\n所得的状态方程为\n\n```cpp\ndp[v] = max{dp[v],dp[v-w[i]]+c[i]}\n//枚举方向是：i从1到n，v从V到0\n```\n\n实现代码\n\n```cpp\n#include<bits/stdc++.h>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 1000\nint dp[N],c[N],w[N],n,V;\n\nint main(){\n\tcin>>n>>V;\n\tfor(int i=1;i<=n;i++) cin>>w[i];\n\tfor(int i=1;i<=n;i++) cin>>c[i];\n\t\n\tfor(int v = 0;v<V;v++) dp[v] = 0;//边界 \n\t\n\tfor(int i=1;i<=n;i++){//状态转移方程 \n\t\tfor(int v = V;v>=w[i];v--){\n\t\t\tdp[v] = max(dp[v],dp[v-w[i]]+c[i]);\n\t\t}\n\t}\n\t\n\tint maxn = -1;\n\tfor(int v = 0;v<=V;v++){//遍历后找出最大值 \n\t\tif(dp[v]>maxn) maxn = dp[v];\n\t}\n\tcout<<maxn;\n}\n/*\n5 8\n3 5 1 2 2\n4 5 2 1 3\n*/\n```\n\n\n\n## 完全背包\n\n完全背包问题描述如下\n\n有n种物品，每种物品的单件重量为w[i],价值为c[i]。现有一个容量为V的背包，问如何选取物品放入背包，使得物品的总价值最大。其中每件物品无穷件\n\n令dp[i] [v]表示前i件物品恰好放入容量为v的背包中能获得的最大价值\n\n综上有两种策略：\n\n1）不放第i件物品，那么dp[i] [v] = dp[i-1] [v],这步与01背包相同\n\n2）放第i件物品,那么dp[i] [v] = dp[i] [v-w[i]]+c[i]\n\n状态转移方程为\n\n```cpp\ndp[i][v] = max{dp[i-1][v],dp[i][v-w[i]]+c[i]}\n```\n\n对空间进行优化后\n\n令dp[v]表示v容量下的最大价值\n\n状态方程变成了\n\n```cpp\ndp[v] = max{dp[v],dp[v-w[i]]+c[i]}\n1<=i<=n,w[i]<=v<=V\n```\n\n**这里的状态方程与01背包相同，但是完全背包问题枚举顺序是正序，而01背包问题的枚举顺序是逆序**\n\n实现代码\n\n```cpp\n#include<bits/stdc++.h>\n#include<algorithm>\n\nusing namespace std;\n\n#define N 1000\nint dp[N],c[N],w[N];\n\nint main(){\n\tint n,V;\n\tcin>>n>>V;\n\t\n\tfor(int i=1;i<=n;i++) cin>>w[i];\n\tfor(int i=1;i<=n;i++) cin>>c[i];\n\t\n\tfor(int v=0;v<=V;v++) dp[v] = 0;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int v=w[i];v<=V;v++){\n\t\t\tdp[v] = max(dp[v],dp[v-w[i]]+c[i]);\n\t\t}\n\t}\n\t\n\tint maxn = -1;\n\tfor(int v=0;v<=V;v++){\n\t\tif(maxn<dp[v]) maxn = dp[v];\n\t}\n\tcout<<maxn;\n} \n/*\n5 8\n3 5 1 2 2\n4 5 2 1 3\n*/\n```\n\n"},{"title":"Android开发(五)——广播机制","url":"/2022/09/01/Android开发-五-——广播机制/","content":"\n# 广播机制\n\n## 广播机制简介\n\nAndroid提供了一套完整的API，允许应用程序自由的发送和接收广播。Intent 也可以发送广播。而接收广播的方法则需要引入新的概念——广播接收器（Broadcast Receiver）\n\n- [ ] 标准广播\n\n  一种完全异步执行的广播，广播发出后所有广播接收器几乎同时接收到广播消息，因此没有先后顺序而言，也不会被截断。\n\n- [ ] 有序广播\n\n  一种同步执行的广播，在广播发出后同一时刻只有一个广播接收器可以收到这条广播消息。\n\n  <!--more-->\n\n## 接收系统广播\n\n​\tAndroid内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到系统的状态信息。\n\n### 动态注册监听网络变化\n\n​\t注册广播的方式有两种，在代码中注册和在AndroidMainifest.xml中注册，其中前者被称为动态注册，后者被称为静态注册。\n\n​\t如何创建一个广播接收器呢？其实只需要新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceiver()方法就行。这样当广播来的时候，onReciver()方法就会执行。\n\n```java\npackage com.example.broadcasttest;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.os.Bundle;\nimport android.widget.Toast;\n\npublic class MainActivity extends AppCompatActivity {\n\n    private IntentFilter intentFilter;\n\n    private NetworkChangeReceiver networkChangeReceiver;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        intentFilter = new IntentFilter();\n        intentFilter.addAction(\"android.net.conn.CONNECTIVITY_CHANGE\");\n        networkChangeReceiver = new NetworkChangeReceiver();\n        registerReceiver(networkChangeReceiver,intentFilter);\n    }\n\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unregisterReceiver(networkChangeReceiver);\n    }\n\n    class NetworkChangeReceiver extends BroadcastReceiver{\n\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            Toast.makeText(context, \"network changes\", Toast.LENGTH_SHORT).show();\n        }\n    }\n}\n```\n\n​\t可以看到，我们在MainActivity中定义了一个内部类NetworkChangeReceiver，这个类继承自BroadcastReceiver的，并重写了父类的onReceive()方法。这样每当网络状态发生变化的时候，onReceiver()方法就会执行，这里只是简单使用了Toast提示了一段文本信息。\n\n​\t然后观察onCreate()方法，首先我们创建了IntentFilter的实例，并给它添加了一个值为android.net.conn.CONNECTIVITY_CHANGE的action，为什么要添加这个值呢？因为当网络状态发生变化时，系统发出的正是一条值为android.net.connCONNECTIVITY_CHANGE的广播，也就是说我们的广播想要监听什么广播，就在这里添加action。接下来创建了一个NetworkChangeReceiver的实例，然后调用registerReceiver()方法进行注册，将NetworkChangeReceiver的实例和IntentFilter的实例都传了进去，这样NetworkChangeReceiver就会收到所有值为android.net.CONNNECTIVITY_CHANGE的广播，也就实现了监听网络变化的过程。\n\n​\t**最后记得，动态注册的广播接收器一定要取消注册才行，这里我们是在onDestory()方法中通过调用unregisterReceiver()方法来实现。**整体来说代码简单，只是提醒网络变化不够人性化，最好是能准确地告诉用户当前是有网络还是没有网络，因此还需要对上面代码进一步优化。\n\n​\t"},{"title":"Anroid开发(三)——探究碎片","url":"/2022/09/01/Anroid开发-三-——探究碎片/","content":"\n# 探究碎片\n\n​\t碎片（fragment）是一种可以嵌入在活动当中的UI片段，它能让程序更加合理充分地利用大屏幕空间，因此在平板上使用的十分广泛。\n\n## 碎片的使用方式\n\n​\t碎片一般都是在平板开发中使用的，所以首先我们应该创建一个平板模拟器，并创建一个FragmentTest项目，开始我们的碎片学习。\n\n### 碎片的简单用法\n\n​\t这里先写一个最简单的碎片示例来练练手，在一个活动中添加两个碎片，并让这两个碎片平分活动空间。\n\n<!--more-->\n\n​\t首先先新建一个左边的布局left_fragment.xml，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/button_3\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        />\n</LinearLayout>\n```\n\n​\t这个布局非常的简单，只放置了一个按钮，并让它水平居中显示。然后新建右侧碎片布局right_fragment.xml，代码如下所示：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:background=\"#00ff00\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:layout_gravity=\"center_horizontal\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:textSize=\"20sp\"\n        android:text=\"This is right fragment\"\n        />\n</LinearLayout>\n```\n\n​\t接着新建LeftFragment类，并让其继承自Fragment。代码 如下：\n\n```java\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n\npublic class LeftFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.left_fragment,container,false);\n        return view;\n    }\n}\n```\n\n​\t这里重写了Fragment的onCreateView()方法，然后通过LayoutInflater的inflate()方法将left_fragment布局动态加载进来，整个方法简单明了。用同样方法再建一个RightFragment类，代码如下：\n\n```java\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n\npublic class RightFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.right_layout,container,false);\n        return view;\n    }\n}\n```\n\n​\t最后修改activity_main.xml中的代码：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/button_3\"\n        android:text=\"BUTTON\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        />\n</LinearLayout>\n```\n\n​\t效果如预期一样：\n\n![image-20220805104537461](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220805104537461.png)\n\n### 动态添加碎片\n\n​\t碎片真正的强大在于在程序运行时动态的添加到活动当中，根据具体情况动态添加碎片，就可以将程序界面定制的多样化。\n\n​\t我们在前面的基础上继续完善，新建another_right_fragment.xml，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n\tandroid:background=\"#ffff00\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_gravity=\"center_horizontal\"\n        android:textSize=\"20sp\"\n        android:text=\"another fragment\"\n        />\n</LinearLayout>\n```\n\n​\t新建AnotherRightFragment作为右侧碎片，代码如下：\n\n```java\nimport android.os.Bundle;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.fragment.app.Fragment;\n\npublic class AnotherFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.another_right_fragment,container,false);\n        return view;\n    }\n}\n```\n\n​\t修改activity_main.xml布局来将碎片动态加入到活动当中，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/left_fragment\"\n        android:name=\"com.example.fragmenttest.LeftFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:layout_weight=\"1\"\n        />\n\n    <FrameLayout\n        android:id=\"@+id/right_layout\"\n        android:layout_weight=\"1\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\">\n    </FrameLayout>\n</LinearLayout>\n```\n\n​\t下面我们在代码中向FrameLayout里添加内容，从而实现动态添加碎片的功能。修改MainActivity中的代码，如下所示：\n\n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener{\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button button = (Button) findViewById(R.id.button_3);\n        button.setOnClickListener(this);\n        replaceFragment(new RightFragment());\n    }\n\n    @Override\n    public void onClick(View v) {\n        switch(v.getId()){\n            case R.id.button_3:\n                replaceFragment(new AnotherFragment());\n                break;\n            default:\n                break;\n        }\n    }\n\n    private void replaceFragment(Fragment fragment){\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\n        transaction.replace(R.id.right_layout,fragment);\n        transaction.commit();\n    }\n\n}\n```\n\n​\t可以发现，首先是在左边的按钮注册了点击事件，然后调用replaceFragment()方法将右侧碎片替换成AnotherRightFragment，结合replaceFragment代码可以看出，动态添加碎片主要分为5步\n\n- [ ] 创建待添加的碎片实例\n- [ ] 获取FragmentManager,在活动中可以直接通过调用getSupportFragmentManager()方法得到\n- [ ] 开启事务，通过调用beginTransaction()方法开启\n- [ ] 向容器内添加或替换碎片，一般用replace()方法实现，需要传入容器的id和待添加的碎片实例\n- [ ] 提交事务，调用commit()方法完成\n\n这样就完成了活动中动态添加碎片的功能，重新运行程序，可以看到和之前相同的界面，然后点击下按钮，左边的碎片就发生了变化。\n\n### 在碎片中模拟返回栈\n\n​\t虽然实现了向活动中动态添加碎片的功能，不过按下back按钮后程序就会直接退出。如果这里我们想模仿类似于返回栈的效果，按下back返回到上一个碎片，该怎么实现呢？\n\n​\tFragmentTransaction中提供了一个addToBackStack()方法，可以用于将事务添加到返回栈中，修改MainActivity中的代码，如下：\n\n```java\nprivate void replaceFragment(Fragment fragment){\n        FragmentManager fragmentManager = getSupportFragmentManager();\n        FragmentTransaction transaction = fragmentManager.beginTransaction();\n        transaction.replace(R.id.right_layout,fragment);\n        transaction.addToBackStack(null);\n        transaction.commit();\n    }\n```\n\n​\t**FragmentTransaction中的addToBackStack()方法，可以直接接收一个名字用来描述返回栈的状态，一般传入null即可。**\n\n### 碎片和活动之间进行通信\n\n​\t为了方便碎片和活动之间进行通信，FragmentManager提供了一个类似于findViewById()的方法，专门用于从布局文件中获取碎片的实例，代码如下所示:\n\n```java\nRightFragment rightFragment = (RightFragmen) getSupportFragmentManager().findFragmentById(R.id.right_fragment);\n```\n\n​\t调用FragmentManager的findFragmentById()方法，可以在活动中获得相应的碎片实例，然后就能轻松的调用碎片里的方法了。\n\n​\t掌握了如何在活动中调用碎片里的方法，那碎片中又该怎么样调用活动里的方法呢？其实这就更简单了，在每个碎片中都会通过调用getActivity()方法来得到和当前碎片相关联的活动实例，代码如下：\n\n```java\nMainActivity activity = (MainActivity)getActivity();\n```\n\n​\t有了活动实例后，在碎片中调用活动里的方法就变得轻而易举了。另外当碎片中需要使用Context对象时，也可以使用getActivity()方法，因为获取到的活动本身就是一个Context对象。\n\n​\t这时还有一个问题：既然碎片和活动之间的通信问题已经解决了，那么碎片和碎片之间可不可以通信呢——答案时肯定的。\n\n## 碎片的生命周期\n\n​\t和活动一样，碎片也有自己的生命周期，并且它和活动的生命周期非常的像。\n\n### 碎片的状态和回调\n\n​\t活动在其生命周期会经历运行状态、暂停状态、停止状态和销毁状态4种。类似地，每个碎片在其生命周期也会经历这几个状态，只不过在一些细小地地方会有区别。\n\n1. **运行状态**\n\n   ​\t当碎片可见时处于运行状态\n\n2. **暂停状态**\n\n   ​\t另一个为占满屏幕地碎片被添加到了栈顶，与他关联地碎片会进入到暂停状态。\n\n3. **停止状态**\n\n   ​\t当一个活动进入停止状态时，与它相关联的碎片就会进入到停止状态，或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中移除，但如果在事务提交之前调用addToBackStack()方法，这时的碎片也会进入到停止状态。进入停止状态的碎片对用户来说是完全不可见的，而且又可能会被系统回收。\n\n4. **销毁状态**\n\n   ​\t碎片总是依附于活动存在的，因此活动被销毁的时候，与它相关联的碎片就会进入到销毁状态。或者通过调用FragmentTransaction的remove()、replace()方法将碎片从活动中删除，但是在事务提交之前并没有调用addToBackStack()方法，这时的碎片会进入销毁状态。\n\n   ​\tFragment也提供了一系列的回调方法，以覆盖碎片生命周期的每个环节。其中，活动中有的回调方法，碎片几乎都有。重点是以下几个回调：\n\n   - [ ] onAttach() 当碎片和活动建立关联的时候调用\n   - [ ] onCreateView() 为碎片创建视图（加载布局）时调用\n   - [ ] onActivityCreated() 确保与碎片相关联的活动一定已经创建完毕\n   - [ ] onDestoryView() 当碎片关联的视图被移除时调用\n   - [ ] onDetach() 当碎片和活动解除关联的时候调用\n\n### 碎片完整生命周期示意图\n\n![](F:\\Typora\\Typora\\md\\android\\picture\\4-2.png)\n\n### 体验碎片的生命周期\n\n​\t\n\n## 动态加载布局的技巧\n\n​\t动态添加碎片功能很强大，但是只是在布局文件中进行添加和替换操作，如果程序能够根据设备的分辨率或者屏幕大小在运行时来决定哪个布局，那发挥空间将更大。\n\n### 使用限定符\n\n​\t要怎么才能运行时判断程序是双页还是单页模式呢？这就要借助限定符来实现了。以下用例子来学习用法：\n\n​\t修改FragmentTest项目中的activity_main.xml文件，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/left_fragment\"\n        android:name=\"com.example.activitytest.LeftFragment\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        />\n\n</LinearLayout>\n```\n\n​\t这里将多于代码都删掉，只留下一个左侧碎片，并让他充满整个父布局。接着在res目录下新建layout-large文件夹，在这个文件夹下新建一个布局，也叫作activity_main.xml，代码如下所示：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/left_fragment\"\n        android:name=\"com.example.fragmenttest.LeftFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_weight=\"1\"\n        android:layout_height=\"match_parent\"\n        />\n\n    <fragment\n        android:id=\"@+id/right_fragment\"\n        android:name=\"com.example.fragmenttest.RightFragment\"\n        android:layout_height=\"match_parent\"\n        android:layout_width=\"0dp\"\n        android:layout_weight=\"3\"\n        />\n</LinearLayout>\n```\n\n​\t可以发现，layout/activity_main.xml只包含了一个碎片，即单页模式。而layout-large/activity_main.xml只包含了两个碎片，即双页模式。其中large 就是限定符，那些屏幕被认为是large的设备就会自动加载layout-large文件下的布局，而小屏幕就会加载layout文件下的布局。\n\n​\t然后将MainActivity中的replaceFragment()方法里的代码注释掉，并在平板上重新运行程序，效果如下：\n\n![image-20220805225647321](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220805225647321.png)\n\n![image-20220805225723892](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220805225723892.png)\n\n### Android中常用的限定符\n\nAndroid中常用的限定符如下表：\n\n| 屏幕特征 | 限定符 | 描述                                   |\n| :------- | ------ | -------------------------------------- |\n| 大小     | small  |                                        |\n|          | normal |                                        |\n|          | large  |                                        |\n|          | xlarge |                                        |\n| 分辨率   | ldpi   | 提供给低分辨率的设备资源（120dpi以下） |\n|          | mdpi   | 120~160dpi                             |\n|          | hdpi   | 160~240dpi                             |\n|          | xhdpi  | 240dpi~320dpi                          |\n|          | xxhdpi | 320~480dpi                             |\n\n| 屏幕特征 | 限定符 | 描述                     |\n| -------- | ------ | :----------------------- |\n| 方向     | land   | 提供给**横屏**设备的资源 |\n|          | port   | 提供给**竖屏**设备的资源 |\n\n### 使用最小宽度限定符\n\n​\t前面虽然使用large成功解决了单页和双页的判断问题，不过很快又有一个新的问题出现了，large到底是多大呢？我们希望更加灵活的为不同设备加载布局，不管是不是被系统认定为large，这时就可以使用最小宽度限定符\n\n​\t最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以dp为单位）,然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另外一个布局\n\n​\t在res目录下新建layout-sw600dp文件夹，然后再这个文件夹新建activity_main.xml布局。\n\n## 碎片的最佳实践——一个简易版的新闻应用 \n\n​\t碎片是用来解决屏幕空间利用不足的问题，但是如果在实际开发中所有程序都提供一个手机版一个Pad版，这样的话花费的人力物力就会增加，维护两个版本也意味着新功能会写两遍，bug也会改两遍，这样十分的麻烦。这个实践目的是同时兼容手机和平板的应用程序。\n\n​\t新建一个FragmentBestPractice项目，由于编写新闻列表会用到RecycleView，因此需要在app/build.gradle当中加入依赖库，如下所示：\n\n```java\ndependencies {\n\n    implementation 'androidx.appcompat:appcompat:1.2.0'\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n    implementation 'androidx.recyclerview:recyclerview:1.1.0'\n}\n```\n\n​\t接下来我们准备一个新闻实体类，新建类News，代码如下所示：\n\n```java\npublic class News {\n    private String title;\n\n    private String content;\n\n    public String getTitle(){\n        return title;\n    }\n\n    public String setTitle(String title){\n        return this.title = title;\n    }\n\n    public String getContent(){\n        return content;\n    }\n\n    public String setContent(){\n        return this.content = content;\n    }\n\n}\n```\n\n​\tNews类title表示新闻标题，content字段表示新闻内容。接着新建布局文件news_content_frag.xml，用于新闻内容的布局：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <LinearLayout\n        android:id=\"@+id/visibility_layout\"\n        android:orientation=\"horizontal\"\n        android:visibility=\"invisible\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\">\n\n        <TextView\n            android:id=\"@+id/news_title\"\n            android:layout_height=\"wrap_content\"\n            android:layout_width=\"match_parent\"\n            android:layout_gravity=\"center\"\n            android:padding=\"10dp\"\n            android:textSize=\"20sp\"/>\n\n        <View\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"1dp\"\n            android:background=\"#000\" />\n\n        <TextView\n            android:id=\"@+id/news_content\"\n            android:layout_height=\"0dp\"\n            android:layout_width=\"match_parent\"\n            android:layout_weight=\"1\"\n            android:padding=\"15dp\"\n            android:textSize=\"18sp\" />\n\n    </LinearLayout>\n\n    <View\n        android:layout_width=\"1dp\"\n        android:layout_height=\"match_parent\"\n        android:layout_alignParentLeft=\"true\"\n        android:background=\"#000\" />\n</RelativeLayout>\n```\n\n​\t新闻内容的布局可以分为两个部分，头部部分显示新闻标题，正文部分显示新闻内容，中间使用一条细线分隔开。这里的细线是利用View来实现的，将View的宽高设置为1dp，再通过background属性给细线设置一下颜色即可。\n\n​\t然后再新建一个NewsContentFragment类，继承自Fragment，代码如下所示：\n\n```java\npublic class NewsContentFragment extends Fragment {\n    private View view;\n\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.new_content_frag,container,false);\n        return view;\n    }\n\n    public void refresh(String newsTitle,String newsContent){\n        View visibilityLayout = view.findViewById(R.id.visibility_layout);\n        visibilityLayout.setVisibility(View.VISIBLE);\n        TextView newsTitleText = (TextView) view.findViewById(R.id.news_title);\n        TextView newsContentText = (TextView) view.findViewById(R.id.news_content);\n        newsTitleText.setText(newsTitle);\n        newsContentText.setText(newsContent);\n    }\n}\n```\n\n​\t首先onCreateView()方法里加载了我们刚创建的news_content_frag布局，接下来提供了refresh方法，这个方法就是用于将新闻的标题和内容显示在界面上的。\n\n​\t这样我们就把新闻内容的碎片和布局就创建好了，但是它们都是在双页模式中使用的，如果想在单页模式中使用的话，我们还要再创建一个活动。新建一个NewsContentActivity，并将布局名指定成news_content，然后修改news_content.xml中的代码：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/news_content_fragment\"\n        android:layout_height=\"match_parent\"\n        android:layout_width=\"match_parent\"\n        android:name=\"com.example.fragmenttest.NewsContentFragment\"\n        />\n    \n</LinearLayout>\n```\n\n​\t这里充分使用了代码的复用性，直接在布局中引入了NewsContentFragment，这样也就相当于把news_content_frag布局的内容自动加了进来。\n\n​\t然后修改NewsContentActivity中的代码，如下所示：\n\n```java\npublic class NewsContentActivity extends AppCompatActivity {\n\n    public static void actionStart(Context context,String newsTitle,String newsContent){\n        Intent intent = new Intent(context,NewsContentActivity.class);\n        intent.putExtra(\"news_title\",newsTitle);\n        intent.putExtra(\"news_content\",newsContent);\n        context.startActivity(intent);\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.news_content);\n        String newsTitle = getIntent().getStringExtra(\"news_title\");\n        String newsContent = getIntent().getStringExtra(\"news_content\");\n        NewsContentFragment newsContentFragment = (NewsContentFragment) getSupportFragmentManager().findFragmentById(R.id.news_content_fragment);\n        newsContentFragment.refresh(newsTitle,newsContent);//刷新NewsContentFragment\n    }\n}\n```\n\n​\t接下来还需要创建一个用于显示新闻列表的布局，新建news_title_frag.xml，代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <androidx.recyclerview.widget.RecyclerView\n        android:id=\"@+id/news_title_recyclerView\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        />\n\n</LinearLayout>\n```\n\n​\t这个布局的代码就非常简单了，里面只有一个用于显示新闻列表的RecyclerView。既然要用到RecyclerView那么必定少不了子项的布局。新建news_item.xml作为RecyclerView子项的布局，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<TextView xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/news_title\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    android:maxLines=\"1\"\n    android:ellipsize=\"end\"\n    android:textSize=\"18sp\"\n    android:paddingLeft=\"10dp\"\n    android:paddingRight=\"10dp\"\n    android:paddingTop=\"15dp\"\n    android:paddingBottom=\"15dp\" >\n\n</TextView>\n```\n\n​\t子项布局只有TextView。android:ellipsize用于设定当文本内容超出控件宽度时，文本缩略方式，这里指定成end表示在尾部进行忽略。\n\n​\t接下来就需要一个用于展示新闻列表的地方。这里新建NewsTitleFragment作为展示新闻列表的碎片，代码如下所示：\n\n```java\npublic class NewsTitleFragment extends Fragment {\n    private boolean isTwoPane;\n\n    @Nullable\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.news_title_frag,container,false);\n        return view;\n    }\n\n    @Override\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        if(getActivity().findViewById(R.id.news_content_fragment) != null){\n            isTwoPane = true;\n        } else {\n            isTwoPane = false;\n        }\n    }\n}\n```\n\n​\t可以看到，NewsTitleFragment中并没有很多代码，在onCreateView()方法中加载了news_title_frag布局，这个没什么好说。在onActivityCreated()方法中，这个方法通过在活动中能否找到一个id为news_content_layout的View来判断当前时双页模式还是单页模式，但是我们还需要；利用限定符，在activity_main.xml中的代码：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:id=\"@+id/news_title_layout\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/news_title_fragment\"\n        android:layout_height=\"match_parent\"\n        android:layout_width=\"match_parent\"\n        android:name=\"com.example.fragmenttest.NewsTitleFragment\"\n        />\n</FrameLayout>\n```\n\n​\t然后新建layout_sw600dp文件夹，在这个文件夹下再创建一个activity_main.xml文件，代码如下所示：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"horizontal\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <fragment\n        android:id=\"@+id/news_title_fragment\"\n        android:name=\"com.example.fragmenttest.NewsTitleFragment\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:layout_weight=\"1\"\n        />\n\n    <FrameLayout\n        android:id=\"@+id/news_content_layout\"\n        android:layout_width=\"0dp\"\n        android:layout_height=\"match_parent\"\n        android:layout_weight=\"3\">\n        <fragment\n            android:id=\"@+id/news_content_fragment\"\n            android:layout_width=\"0dp\"\n            android:layout_height=\"match_parent\"\n            android:name=\"com.example.fragmenttest.NewsContentFragment\"\n            />\n    </FrameLayout>\n</LinearLayout>\n```\n\n​\t可以看出，双页模式我们引入了两个碎片，并将新闻内容的碎片放在了一个FrameLayout布局下，而这个布局的id正是news_content_layout，只要能找到这个id就是双页模式，找不到就是单页模式。\n\n​\t现在大部分的工作都已经完成了，只需要通过NewsTitleFragment中通过RecyclerView中通过RecyclerView将新闻列表表示出来。在NewsTitleFragment中新建一个内部类NewsAdapter来作为RecyclerView的适配器，如下：\n\n```java\nclass NewsAdapter extends RecyclerView.Adapter<NewsAdapter.ViewHolder>{\n        private List<News> mNewsList;\n\n        class ViewHolder extends RecyclerView.ViewHolder{\n            TextView newsTitleText;\n\n            public ViewHolder(View view){\n                super(view);\n                newsTitleText = (TextView) view.findViewById(R.id.news_title);\n            }\n        }\n\n        public NewsAdapter(List<News> newsList){\n            mNewsList = newsList;\n        }\n\n        @NonNull\n        @Override\n        public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {\n            View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.news_item,parent,false);\n            final ViewHolder holder = new ViewHolder(view);\n            view.setOnClickListener(new View.OnClickListener(){\n                @Override\n                public void onClick(View v) {\n                    News news = mNewsList.get(holder.getAdapterPosition());\n                    if(isTwoPane){\n                        NewsContentFragment newsContentFragment = (NewsContentFragment) getFragmentManager().findFragmentById(R.id.news_content_fragment);\n                        newsContentFragment.refresh(news.getTitle(),news.getContent());\n                    } else {\n                        NewsContentActivity.actionStart(getActivity(),news.getTitle(),news.getContent());\n                    }\n                }\n            });\n            return holder;\n        }\n\n        @Override\n        public void onBindViewHolder(@NonNull ViewHolder holder, int position, @NonNull List<Object> payloads) {\n            News news = mNewsList.get(position);\n            holder.newsTitleText.setText(news.getTitle());\n        }\n\n        @Override\n        public int getItemCount() {\n            return mNewsList.size();\n        }\n    }\n}\n\n```\n\n​\t最后一步是收尾工作，就是向RecyclerView中填充数据。修改NewsTitleFragment中的代码，如下所示：\n\n```java\npublic View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        View view = inflater.inflate(R.layout.news_title_frag,container,false);\n        RecyclerView newsTitleRecyclerView = (RecyclerView) view.findViewById(R.id.news_title_recyclerView);\n        LinearLayoutManager layoutManager = new LinearLayoutManager(getActivity());\n        newsTitleRecyclerView.setLayoutManager(layoutManager);\n        NewsAdapter adapter = new NewsAdapter(getNews());\n        newsTitleRecyclerView.setAdapter(adapter);\n        return view;\n    }\n\n    private List<News> getNews(){\n        List<News> newsList = new ArrayList<>();\n        for(int i = 1;i<=50;i++){\n            News news = new News();\n            news.setTitle(\"This is news title\"+i);\n            news.setContent(getRandomLengthContent(\"This is news content\"+i+\", \"));\n            newsList.add(news);\n            return newsList;\n        }\n    }\n\n    private String getRandomLengthContent(String content){\n        Random random = new Random();\n        int length = random.nextInt(20)+1;\n        StringBuilder builder = new StringBuilder();\n        for(int i = 0;i<length;i++){\n            builder.append(content);\n        }\n        return builder.toString();\n    }\n\n```\n\n"},{"title":"Android开发(二)——活动","url":"/2022/09/01/Android开发-二-——活动/","content":"\n# 活动\n\n## 活动定义\n\n活动（Activity）是最吸引用户的地方，它包含用户界面的组件，主要用于和用户进行交互\n\n## 活动基本用法\n\n### 创建活动（手动创建）\n\n​\t选择新建一个Android项目，将activityName命名，在Java包中会默认创建一个**com.example.**activityName的文件，我们首先选择Add No Activity。\n\n​\t此时app/src/main/java/com.example.activityName目录是空的，\n\n在此包中右击选择创建Activity，然后命名活动名称并取消Generate Layout File和Laucher Activity两个选项\n\n- Generate Layout File会自动为新建的活动创建对应的布局\n\n- Laucher Activity 会将当前项目活动设置为主活动\n\n<!--more-->\n\n**注意：任何的活动都需要重写Activity的onCreate()方法，Android Studio会帮我们自动完成这个方法，打开Activity.java如下：**\n\n```java\npublic class FirstActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {//onCreate()方法已经被重写\n        super.onCreate(savedInstanceState);\n    }\n}\n```\n\n\n\n### 创建加载布局\n\n​\tAndroid程序的设计讲究逻辑与视图分离，最好每一个活动都能对应一个布局，布局就是用来显示界面内容的，因此我们现在就来手动创建一个布局文件。\n\n​\t**右击app/src/main/res目录 -> New -> Directory， 会弹出一个新的目录窗口，在这里先创建一个名为layout的目录。然后对着layout目录右键 -> New -> Layout resource file，又会弹出一个新建布局资源文件的窗口，我们将这个布局文件命名为first_layout，根元素就默认为LinearLayout**\n\n​\t创建后的效果如下：\n\n<img src=\"C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728213244364.png\" alt=\"image-20220728213244364\" style=\"zoom:150%;\" />\n\n布局编辑有三种方式：code 、 split 、design，上面这一种为design模式，切换为code代码如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n</LinearLayout>\n```\n\n布局中的控件我们都会放在这个布局文件中，下面是放入button的样例:\n\n代码:\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/button_1\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Button 1\"\n        ></Button>\n</LinearLayout>\n```\n\n效果：\n\n![image-20220728214620818](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728214620818.png)\n\n应该注意到，Button元素内部增加了多个属性：\n\nandroid:id是元素的唯一标志符\n\nandroid:layout_width指定了当前的元素的宽度,march_parent表示当前元素与父元素一样的宽\n\nandroid:layout_height指定了当前元素的高度，warp_content表示当前元素刚好可以包含里面的内容。\n\nandroid:text指定了元素中显示的文字内容。\n\n​\t**接下来最重要的就是在活动中加载这个布局:**\n\n重新回到FirstActivity,在onCreate()方法中加入如下的代码：\n\n```java\npackage com.example.activitytest;\n\nimport androidx.appcompat.app.AppCompatActivity;\n\nimport android.os.Bundle;\n\npublic class FirstActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.first_layout);\n    }\n}\n```\n\n这里用setContentView()方法来给当前的活动加载一个布局，而在setContentView()方法中，我们一般都会传入一个布局文件id，只需要调用R.layout.first_layout就可以得到first_layout.xml布局的id，将这个值传入setContentView()方法中即可。\n\n### 在AndroidMainifest文件中注册\n\n​\t上一章中说到，所有的活动都要在AndroidMainifest.xml中注册才能生效，而实际上FirstActicity已经在AndroidMainifest.xml中注册过了，我们打开app/src/main/AndroidMainfest.xml就可以发现，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.activitytest\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.ActivityTest\">\n        <activity\n            android:name=\".FirstActivity\"\n            android:exported=\"true\" />\n    </application>\n\n</manifest>\n```\n\n​\t活动申明是要放在<application\\>标签内的，这里通过<activity\\>标签来对活动进行注册的，可以发现是注册好的——这里要感谢android stduio对活动进行自动的注册。\n\n​\t**这里的<activity\\>标签我们使用了android:name来指定具体的活动，这里的.firstActivity其实是com.example.activitytest.FirstActivity的缩写**,因为在最外层的<mainfest\\>标签中已经通过package属性指定了程序的包名com.example.activitytest，因此注册部分可以省略。\n\n​\t不过仅是注册了活动，我们的程序还是不能运行的，因为还没有配置主活动，也就是说，当程序运行起来的时候，不知道要先启动哪个活动，所以需要配置主活动，步骤如下：\n\n- 在<activity\\>内部加入<intent-filter\\>标签，并在标签中加入<action android:name=\"android.intent.action.MAIN\"/\\>和<category android:name=\"android.intent.category.LAUNCHER\"\\>两句申明即可。\n\n- 还可以用android:label指定活动中标题栏的内容，标题栏是显示在活动最顶部的，**注意的是，活动指定的label不仅会成为标题栏中的内容，还会成为启动器（Laucher）中的应用程序显示的名称**\n\n修改后的AndroidMainifest.xml文件代码如下所示：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"com.example.activitytest\">\n\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.ActivityTest\">\n        <activity\n            android:name=\".FirstActivity\"\n            android:label=\"This is FirstActivity\"\n            android:exported=\"true\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n    </application>\n\n</manifest>\n```\n\n​\t这样的话，FirstActivity就成为我们的程序主活动了，点击应用程序图标打开就是这个活动。\n\n**注意：如果没有申明主程序的话，app依然可以下载安装，但是无法正常看到这个活动或者打开这个活动，这种活动可以做第三方服务供其他应用在内部进行调用的，如支付宝快捷支付服务**\n\n运行程序结果如下：\n\n<img src=\"C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728224636201.png\" alt=\"image-20220728224636201\" style=\"zoom: 33%;\" />\n\n成功掌握了手动创建活动的方法\n\n### 在活动中使用Toast\n\n​\tToast是Android系统提供的一种非常好的提醒方式，在一些短小的信息通知给用户，这些消息在一段时间后会自动消失，并且不会占用任何屏幕空间\n\n​\t首先需要定义Toast出现的触发点，我们就利用前面这个按钮来弹出一个Toast。在OnCreate()方法中添加如下代码：\n\n```java\nprotected void onCreate(Bundle savedInstanceState){\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.first_layout);\n        Button button1 = (Button) findViewById(R.id.button_1);\n        button1.setOnClickListener(new View.OnClickListener(){\n            @Override\n            public void onClick(View v){\n                Toast.makeText(FirstActivity.this,\"You Click Button1\",Toast.LENGTH_SHORT).show();\n            }\n        });\n```\n\n​\t在活动中，通过findViewById()方法获取布局顶定义的元素，这里传入之前确定的R.id.button_1来指定按钮的实例。findViewId()方法返回的是View对象，我们需要向下转型成为Button对象。通过调用setOnClickListener()方法为按钮注册一个监听器，点击按钮的时候会执行监听器中的onclick()方法\n\n​\tToast使用方法，通过静态makeText()创建出一个Toast对象，然后调用show()将Toast显示出来即可。**注意这里的makeText()需要传入三个参数，第一个参数是Context，也就是Toast的上下文，由于活动本身就是一个Context对象，直接传入FirstActivity.this即可，第二个参数是Toast显示的文本内容，第三个参数是Toast显示的时长，有两个内置常量可以选择Toast.LENGTH_SHORT和Toast.LENGTH.LONG**\n\n​\t重新运行程序的结果如下：\n\n![image-20220728230743432](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728230743432.png)\n\n### 活动中使用Menu\n\n​\t手机不同于电脑，屏幕的使用空间非常的有限，如果将含有大量内容的菜单显示，界面的设计就会比较的尴尬，这里提供了一种方式，在菜单显示的同时，也不会占用大量的屏幕空间——Menu\n\n​\t首先在res目录下新建一个menu文件夹,右击res -> New -> Directory,输入文件名menu，再在这个文件夹下新建main的菜单文件，右击menu -> New -> Menu resource file，文件命名为main，在main.xml菜单文件下添加如下代码：\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<menu xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:id=\"@+id/add_item\"\n        android:title=\"Add\" />\n\n    <item\n        android:id=\"@+id/remove_item\"\n        android:title=\"Remove\"/>\n</menu>\n```\n\n在这里创建了两个菜单选项，其中<item\\>标签是用来创建具体的摸一个菜单选项，然后通过android:id给这个菜单项指定唯一的标识符，通过android:title给菜单命名名称\n\n​\t**接着回到FirstActivity中重写onCreateOptionMenu()方法**，重写快捷键Ctrl+O(Mac系统是control+O)\n\n​\t在onCreateOptionsMenu()方法中编写如下代码：\n\n```java\n @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        getMenuInflater().inflate(R.menu.main,menu);\n        return true;\n    }\n```\n\n​\t通过getMenuInflater()方法能够得到MenuInflater对象，再调用它的infalte()方法就可以给当前活动创建菜单了。**infalter()方法接收两个参数，第一个参数用于指定哪一个资源文件来创建菜单，第二个参数用来指定我们的菜单项将添加到哪一个Menu对象中，这里直接用onCreateOptionsMenu()方法中传入menu参数**。然后给这个方法返回true,表示菜单允许显现出来。\n\n​\t显现菜单是远远不够的，菜单的作用不仅是看，还要用来使用，因此还要定义菜单的响应事件。在FirstAcitivty中重写onOptionsItemSelected()方法：\n\n```java\n@Override\n    public boolean onOptionsItemSelected(@NonNull MenuItem item) {\n        switch (item.getItemId()){\n            case R.id.add_item:\n                Toast.makeText(this,\"you clicked Add\",Toast.LENGTH_SHORT).show();\n            case R.id.remove_item:\n                Toast.makeText(this, \"you clicked remove\", Toast.LENGTH_SHORT).show();\n                break;\n            default:\n        }\n        return true;\n    }\n```\n\n​\t在onOptionsItemSelected()方法中，通过调用item.getItemId()来判断我们点击的是哪一个菜单项，然后给每个菜单项加入自己的逻辑处理，这里就活学活用加入Toast来显示效果。\n\n​\t效果如下：\n\n<img src=\"C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728233807927.png\" alt=\"image-20220728233807927\" style=\"zoom: 33%;\" />\n\n![image-20220728233754848](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220728233754848.png)\n\n### 销毁一个活动\n\n销毁一个活动很简单，只需要按下返回键就可以了。如果不希望使用返回键销毁活动的话，Activity提供了一个finish()方法，活动中调用这个方法即可销毁活动\n\n代码如下：\n\n```java\nbutton1.setOnClickListener(new View.OnClickListener(){//位置位于FirstActivity.java/onCreate()/onClick()\n            @Override\n            public void onClick(View v){\n                finish();\n                //Toast.makeText(FirstActivity.this,\"You Click Button1\",Toast.LENGTH_SHORT).show();\n            }\n        });\n}\n```\n\n## 使用Intent在活动之间穿梭\n\n如何才能从主活动跳入到其他的活动去呢\n\n### 使用显式Intent\n\n​\t右击com.example.activitytest包 -> New -> Activity -> Empty Activity，会弹出一个创建活动的对话框，我们将活动命名为SecondActivity ，勾选Generate Layout File，给布局文件起名为second_layout，但是不要勾选Launcher Activity选项。\n\n​\t依然使用LinearLayout 编辑second_layout.xml，代码如下：\n\n```java\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    android:orientation=\"vertical\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\">\n\n    <Button\n        android:id=\"@+id/button_2\"\n        android:layout_height=\"wrap_content\"\n        android:layout_width=\"match_parent\"\n        android:text=\"Button 2\"\n        />\n\n</LinearLayout>\n```\n\n定义一个按钮Button 2，同时在SecondActivity中代码已经生成了一部分，暂时保持默认\n\n最后在AndroidMainifest.xml中注册，不过Android Stduio已经帮我们自动完成了\n\n```java\n<activity\n            android:name=\".SecondActivity\"\n            android:exported=\"true\" />\n```\n\n#### 新概念Intent\n\n​\tIntent是Android程序中各组件之间进行交互的一种重要方式，不仅可以指明当前组件想要的动作，还能在不同组件之间传递数据。\n\n​\tIntent一般可以用在启动活动、启动服务以及发送广播等场景，我们的先来实现启动活动。\n\n​\tIntent分为两种：**显式Intent和隐式Intent**\n\n#### 使用显式Intent\n\n​\tIntent有多个构造函数的重载，其中一个是**Intent（Context packageContext , Class<?>cls）**。这个构造函数两个参数Context要求提供活动的上下文，第二个参数Class则是指定想要启动的目标活动，通过这个构造函数可以构建出Intent的\"意图\"。\n\n​\t可是我们怎么才能使用Intent呢？Activity类提供了一个startActivity()方法，这个方法是专门用于启动活动的，它接收一个Intent参数，这里我们将构建好的Intent传入startActivity()方法就可以启动目标活动了。\n\n​\t修改FirstActivity中的按钮事件，代码如下：\n\n```java\npublic void onClick(View v){\n                Intent intent = new Intent(FirstActivity.this,SecondActivity.class);\n                startActivity(intent);\n                //finish();\n                //Toast.makeText(FirstActivity.this,\"You Click Button1\",Toast.LENGTH_SHORT).show();\n            }\n```\n\n重新运行程序，点击FirstActivity界面的按钮，效果如下：\n\n![](C:\\Users\\渣渣致\\AppData\\Roaming\\Typora\\typora-user-images\\image-20220729154440703.png)\n\n由于用这样的方式启动Intent，意图十分明显，因此将这种方式称为**显式Intent**\n\n#### 使用隐式Intent\n\n​\t相比于显式的Intent，隐式Intent含蓄了很多，它并不明确指出我们想要启动哪一个活动，而是指定了更为抽象的action和category等信息，然后交由系统去分析这个Intent，并帮我们找出合适活动去启动。\n\n​\t在SecondActivity的<activity\\>中配置<intent-filter\\>，可以指定当前活动能够响应的action和category，代码如下：\n\n```java\n<activity\n\tandroid:name=\".SecondActivity\"\n\tandroid:exported=\"true\" >\n\t<intent-filter>\n\t\t<action android:name=\"com.example.activitytest.ACTION_START\" />\n\t\t<category android:name=\"android.intent.category.DEFAULT\" />\n\t</intent-filter>\n</activity>\n```\n\n​\t在<action\\>标签中我们指定了活动可以响应com.example.activitytest.ACTION_START\n\n这个action，而<category\\>标签则包含了附加信息，更加精确的指明了当前活动能够响应的Intent中还能带有category。只有<action\\>和<category\\>中的内容同时能够匹配环境中指定的action和category时，这个活动才能响应这个Intent。\n\n​\t修改FirstActivity中的按钮点击事件，代码如下所示：\n\n```java\nWpublic void onClick(View v){\n                Intent intent = new Intent(\"com.example.activitytest.ACTION_START\");\n                startActivity(intent);\n}\n```\n\n​\t可以发现，我们使用了Intent的另一个构造函数，直接将action的字符串了进去，表明我们想要启动能够响应com.example.activitytest.ACTION_START这个action活动。而这里指定的category是利用android.intent.category.DEFAULT这种默认的，在调用startActivity()方法时会将这个category添加到intent中。\n\n​\t重新运行程序结果依然是成功的，说明配置的action和category已经生效了.\n\n**注意：一个Intent只能指定一个action，但是可以指定多个category**\n\n#### 更多的隐式Intent的用法\n\n​\t隐式还有许多内容了解，使用隐式，我们不仅可以启动自己程序内的活动，还可以启动其他程序的活动，这使得Android多个应用程序之间的功能共享成为了可能，比如直接调用浏览器来打开网页\n\n​\t修改FirstActivity的按钮点击事件的代码：\n\n```java\npublic void onClick(View v){\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(Uri.parse(\"http://www.baidu.com\"));\n                startActivity(intent);\n}\n```\n\n在上述代码中，setData是比较陌生的一部分，这里主要是数据传递，同时我们还可以在<intent-filter\\>标签中再配置一个<data\\>标签，用于更精确的指定活动能够响应什么类型的数据。<data\\>标签中主要有以下内容：\n\n- [ ] android:scheme 用于指定协议\n- [ ] android:host 用于指定主机\n- [ ] android:port 用于指定端口\n- [ ] android:path 用于指定域名\n- [ ] android:mimeType 用于指定可以处理的数据类型\n\n#### 向下一个活动传递数据\n\n​\tIntent还可以在启动活动的时候传递数据。在启动活动的时候传递数据的思路很简单，Intent中提供了一系列putExtra()方法的重载，可以把我们想要传递的数据暂时存在Intent中，启动了另一个活动后，只需要把这些数据再从Intent中取出即可。\n\n​\t如：我们将FirstActivity中的一个字符串传入SecondActivity中，在FirstActivity中：\n\n```java\npublic void onClick(View v){\n                String data = \"Hello World\";\n                Intent intent = new Intent(FirstActivity.this,SecondActivity.class);\n                intent.putExtra(\"extra_data\",data);\n                startActivity(intent);\n}\n```\n\n这里依然选择显式Intent方式来启动SecondActivity，并通过putExtra()方法传递了一个字符串。**注意这里的putExtra()方法接收两个参数，第一个参数是键，用于后面从Intent中取值，第二个参数才是真正想要传递的数据**\n\n```java\nprotected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.second_layout);\n        Intent intent = getIntent();\n        String data = intent.getStringExtra(\"extra_data\");\n        Log.d(\"SecondActivity\",data);\n    }\n```\n\n在按下按钮后可以在logcat中找到我们打印的数据\n\n```java\n2022-07-30 16:23:00.366 13583-13583/com.example.activitytest D/SecondActivity: Hello World\n```\n\n#### 返回数据给上一个活动\n\n​\t既然可以给下一个活动传递数据，那么给上一个活动传递数据也是理算当然的。不过不同的是给上一个活动传递时只需要按下back键即可，并没有可以传递数据的Intent。在Activity中有一个startActivityForResult()方法也是用于启动活动的，并且可以在活动销毁的时候返回一个结果给上一个活动。\n\n​\t修改FirstActivity中的按钮点击事件，代码如下：\n\n```java\nIntent intent = new Intent(FirstActivity.this,SecondActivity.class);\nstartActivityForResult(intent,1);\n```\n\n​\t这里用startActivityForResult()方法启动SecondActivity，两个参数第一个时intent，而第二个是请求码（**只要是唯一值即可**），接下来在SecondActivity中加入按钮点击事件，代码如下：\n\n```java\nButton button2 = (Button) findViewById(R.id.button_2);\nbutton2.setOnClickListener(new View.OnClickListener(){\n\t@Override\n\tpublic void onClick(View v) {\n\t\tIntent intent = new Intent();\n\t\tintent.putExtra(\"data_return\",\"hello world again\");\n\t\tsetResult(RESULT_OK,intent);\n\t\tfinish();\n\t}\n});\n```\n\n​\t由于是使用startActivityForResult()方法来启动SecondActivity的，在SecondActivity被销毁后会回调上一个活动的onActivityResult方法，因此我们需要在FirstActivity中重写这个方法来得到返回的数据：\n\n```java\n2022-07-30 17:46:39.207 15449-15449/com.example.activitytest D/Third: hello world again\n```\n\n​\t**onActivityForResult()方法带三个参数，第一个参数requestCode，在我们启动时传入请求码，第二个参数resultCode，即我们在返回数据时的处理结果，第三个参数data，即带着返回数据的Intent。**\n\n​\t由于在活动中可能有调用startActivityForResult()方法启动很多不同的活动，每一个活动返回的数据都会回调到onActivityResult()这个方法中，因此我们首先要做的就是通过检查requestCode来确定数据来源，然后通过resultCode来确定数据处理是否成功，最后将data数据打印出来。\n\n​\t这里有一点问题，如果不是按下按钮而是直接按下back键返回那数据不是没法返回了嘛，所以我们还要在SecondActivity中写入onBackPressed()来解决这个问题。代码如下：\n\n```java\n    @Override\n    public void onBackPressed() {\n        super.onBackPressed();\n        Intent intent = new Intent();\n        intent.putExtra(\"data_return\",\"hello world again\");\n        setResult(RESULT_OK,intent);\n        finish();\n    }\n```\n\n## 活动的生命周期\n\n​\t掌握了活动的生命周期可以帮助我们设计出更加连贯流畅的程序，并在如何合理管理应用资源方面发挥的游刃有余。\n\n### 返回栈\n\n​\tAndroid是使用任务(Task)来管理活动的，一个任务就是存放在一组栈里的活动的集合，这个栈又被称作返回栈。每次启动一个新活动，都会入栈并处于栈顶位置，finish()销毁时，栈顶活动会入栈。\n\n### 活动状态\n\n​\t活动在其生命周期最多会有四个状态。\n\n1. 运行状态\n\n   当活动位于栈顶时，处于运行状态。系统最不愿意回收运行状态，这会让用户有非常差的体验。\n\n2. 暂停状态\n\n   当一个活动不在栈顶时但是任然可见时，活动进入了暂停状态。只有在内存极低的情况下，系统才会回收这种活动。\n\n3. 停止状态\n\n   不在栈顶且完全不可见的时候即为暂停状态。系统仍然会保存活动的变量以及状态，但并不是完全可靠，其他地方需要内存时这种活动就会被回收。\n\n4. 销毁状态\n\n   从返回栈被移除就是销毁状态。系统倾向于回收这种活动，从而保证手机内存充足。\n\n### 活动的生存期\n\nActivity中定义了7个回调方法，覆盖生命周期的每一个环节。\n\n- [ ] onCreate() \n\n  每一个活动都要重写的方法，专门用来初始化\n\n- [ ] onStart()\n\n  活动由不可见变可见时使用\n\n- [ ] onResume()\n\n  **此活动一定位于栈顶且处于运行状态**，在准备与用户交互时调用。\n\n- [ ] onPause()\n\n  这个方法在系统准备启动或者恢复时调用，通常会用来释放CPU资源或者保存关键数据\n\n- [ ] onStop()\n\n  完全不可见时调用\n\n- [ ] onDestory()\n\n  被销毁前调用\n\n- [ ] onRestart()\n\n  活动由停止变为运行状态时调用\n\n**以上七种方法又被分为三种生存期**\n\n- [ ] **完整生存期**\n- [ ] **可见生存期**\n- [ ] **前台生存期**\n\n![](F:\\Typora\\Typora\\md\\android\\picture\\2-8.png)\n\n### 体验活动的生命周期\n\n​\t\n\n### 活动被回收了怎么办\n\n​\t当一个活动进入到了停止状态，是有可能被系统回收的。想象如下的场景：\n\n应用程序中有一个活动A，用户在活动A的基础上启动了活动B，活动A就进入了停止状态，这个时候由于系统内存不足，将活动A回收了，然后用户按下back键返回活动A。其实A还是会正常显示，只是这里A活动的创建使用的不是onRestart()方法，而是onCreate()方法，因为这种情况下A活动会被重新创建一次。\n\n​\t可是这里就会出现一个问题，如果A活动有临时状态，在使用了onCreate()方法创建的话用户按下back键原来的临时状态就不会存在。如果我们的应用出现了这种情况，有可能会严重的影响用户体验。在Activity中还提供了一个onSaveInstanceState()回调方法，这个方法保证活动在回收之前一定会被调用，因此我们可以通过这个方法来解决数据保存的问题。\n\n​\tonSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如可以使用putString()方法保存字符串，使用putInt()方法保存数据，第一个参数是键，用于后面的Bundle中取值，第二个参数是真正要保存的内容。\n\n​\t在MainActivity中添加如下代码就可以将临时数据进行保存：\n\n```java\n    @Override\n    protected void onSaveInstanceState(@NonNull Bundle outState) {\n        super.onSaveInstanceState(outState);\n        String tempData = \"Something you just typed\";\n        outState.putString(\"data_key\",tempData);\n    }\n```\n\n​\t数据保存下来后，我们一直的onCreate()方法好像其实也有Budle类型的参数。这个参数正常情况下都是null，但是如果在活动被系统回收之前有通过onSaveInstanceState()方法来保存的话，这个参数就会带有之前保存的全部数据，我们只需要再通过相应的取值方法取出即可。\n\n​\t修改MainActivity的onCreate()方法，如下所示：\n\n```java\nif(savedInstanceState != null){\n            String tempData = savedInstanceState.getString(\"data_key\");\n            Log.d(\"Saved\",tempData);\n        }\n```\n\n​\t**这里可以使用Budle和Intent结合的方式来实现活动之间的数据传递，首先将数据存入Budle中，再将Budle存入Intent中，在下一个活动中打开。**\n\n## 活动的启动模式\n\n​\t启动活动需要恰当的模式，启动模式一共四种，分别是：standard，singleTop,singleTask和singleInstance。可以在AndroidMainifest.xml中通过给<activity\\>标签指定android:launchMode属性来选择启动模式。\n\n### standard\n\n​\tstandard是活动默认的启动模式，在不进行显示指定的情况下，所有活动都会自动启用这种模式。对于standard这种模式系统不会在意这个活动是否在栈中已经存在，每次启动都会创建这个活动的新实例。\n\n### singleTop\n\n​\tstandard模式在有些情况下不会很合理，比如明明活动已经在栈顶了，再次启动依然会创建新的活动实例。但是singleTop就不会出现这样的麻烦，当启动活动时发现活动已经在栈顶，则认为可以直接使用它，不会再创建新的活动实例。\n\n​\t只需要在AndroidManifest.xml中修改配置代码：\n\n```java\n<activity\n            android:launchMode=\"singleTop\"\\\\启动模式设为singleTop\n            android:name=\".FirstActivity\"\n            android:exported=\"true\"\n            android:label=\"This is FirstActivity\">\n```\n\n### singleTask\n\n​\tsingleTop虽然可以很好的解决重复创建栈顶活动的问题，但是如果不在栈顶依然会重复创建，有没有一种模式可以让应用程序的上下文只存在一个实例呢，这就需要singleTask来实现了。\n\n### singleInstance\n\n​\tsingleInstance模式是四个启动模式中最特殊也是最复杂的存在了，不同于以上三个模式，该模式活动会启用一个新的返回栈来管理这个活动(其实如果singleTask如果用了不同的taskAffinity，也会启动一个新的返回栈)。\n\n​\t假设我们的程序有一个活动允许其他的活动程序调用，怎么才能实现其他程序和我们程序一起调用这个活动呢，因为前三种模式下，每一个程序都有一个自己的返回栈，同一个活动在不同的返回栈中入栈时必然创建了新的实例。而singleInstance可以利用新的返回栈来共享并单独管理这些活动，不管是哪一个程序来访问这个活动都可以共用同一个返回栈。\n\n## 活动的最佳实践\n\n​\t以下是一些关于活动的实践技巧\n\n### 知晓当前是在哪一个活动\n\n​\t在企业开发中有时并不能确定自己正在阅读或者编写的代码是在哪一个界面，这个时候就需要自己来尝试寻找。\n\n​\t方法：在主活动中重写onCreate()打印getclass().getsimplename()来打印当前页面，然后将其他所有的活动都从继承自AppCompatActivity改为继承自主活动，这样每次启动活动都会打印活动的名称，因为便于我们清楚界面是哪一个活动了。\n\n### 随时随地退出程序\n\n​\t如果这时你要想返回到手机界面需要按三次back键，而按下home键只是将程序挂起，并没有退出程序。所以需要一个能够随时随地退出程序的方案才行。\n\n​\t解决思路需要专门的集合类对所有的活动进行管理\n\n### 启动活动的最佳写法\n\n​\t启动活动的方法我们很熟悉，首先通过构建Intent构建出当前的“意图”，然后调用startActivity()或者startActivityForResult()方法将活动启动起来，如果有数据需要从一个活动传递给另一个活动，也可以借助Intent来完成。\n\n​\t假设SecondActivity中有两个非常重要的参数，在启动这个参数之前必须要传递过来，那么代码可以如下：\n\n```java\nIntent intent = new Intent(SecondActivity.this,FirstActivity.class);\nintent.putExtra(\"param1\",\"data1\");\nintent.putExtra(\"param2\",\"data2\");\nstartActivity(intent);\n```\n\n​\t这样的代码是完全正确的，不论是语法上还是规范上，只是在真正的项目开发中会遇到这样的问题：由于SecondActivity并不是你开发的，但是你需要知道secondActivity传递了什么参数，这个时候就一般有两种方法解决这个问题——可以去问写了secondActivity代码的同时或者自己阅读SecondActivity的代码来确定，这样有时会很麻烦甚至尴尬，作为一个优雅的程序猿，这样的作法自然不够优雅。但只要换一种写法，这种窘境就会被打破。\n\n​\t修改SecondActivity()代码如下：\n\n```java\npublic class SecondActivity extends BaseActivity {\n    public static void actionStart(Context context,String data1,String data2){\n\t\tIntent intent = new Intent(FirstActivity.this,SecongActivity.class);\n\t\tintent.putExtra(\"param1\",\"data1\");\n\t\tintent.putExtra(\"param2\",\"data2\");\n\t\tstartActivity(intent);\n    }\n}\n```\n\n​\t我们在这里加入一个actionStart()方法，这个方法完成了Intent的构建，另外所有SecondActivity所有数据都是通过这个方法传过来的，只需要再把数据存入Intent，最后调用startActivity()方法启动SecongActivity即可。\n\n​\t好处是什么呢，显然这样可以立马清楚SecondActivity数据都有哪些，而且还能简化代码，现在只需一行代码即可启动SecondActivity()，如下所示：\n\n```java\n@Override\npublic void onClick(View v) {\n\tSecondActivity.actionStart(FirstActivity.this,\"data1\",\"data2\");\n}\n```\n\n"},{"title":"Android开发(一)——认识第一个项目","url":"/2022/09/01/Android开发-一-——认识第一个项目/","content":"\n# 认识第一个Android项目\n\nAndroid开发首先需要了解项目的结构\n\n<!--more-->\n\n## 文件组成\n\n1. .gradle和.idea\n\n   这两个目录下是android studio自动生成的一些文件，我们无须关心，也不要手动编辑\n\n2. **app**\n\n   项目中的代码、资源等内容几乎都是放置在这个目录下的，我们后面的开发工作也基本在这个目录下进行的\n\n3. build\n\n   这个目录无需关心，主要包含了一些编译时会自动生成的文件\n\n4. gradle\n\n   目录包含了gradle wrapper的配置文件，使用gradle wrapper的方式不需要提前将gradle下载，如需启用gradle wrapper，可以在File -> Settings -> Build,Execution ,\n\n   Deployment -> Gradle\n\n5. **.gitignore**\n\n   这个文件是用来指定的目录或者文件排除在版本控制之外的\n\n6. **build.gradle**\n\n   这是项目全局的gradle构建脚本，通常这个文件的内容不需要修改。\n\n7. gradle.properties\n\n   这个是全局的gradle配置文件，在这里配置的属性将会影响到项目中的所有gradle编译脚本。\n\n8. gradlew 和 gradlew.bat\n\n   这两个文件是用来命令行界面中执行的gradle命令的，其中gradlew是在linux或者Mac系统中使用的，gradlew.bat是在windows中使用的\n\n9. HelloWorld.iml\n\n   iml文件是所有IDEA项目都会自动生成的文件，不需要修改\n\n10. local.properties\n\n    这个文件用于指定本机的SDK路径，通常都是自动生成的，我们并不需要修改。\n\n11. settings.gradle\n\n    这个文件用于指定项目中的所有引入模块。通常情况的模块引入都是自动完成的，需要我们手动引入的情况较少\n\n## app文件组成\n\n1. build\n\n   这个目录与外层的build类似，主要是包含了一些在编译时自动生成的文件，不过文件内容会更加的复杂\n\n2. libs\n\n   如果项目引入了第三方jar包，就需要把这些jar包都放在libs目录下，放在这个目录下的jar包都会被添加进去\n\n3. androidTest\n\n   此处用来编写Android Test 测试用例，可以对项目进行一些自动化测试\n\n4. **java**\n\n   放置我们所有java代码的地方\n\n5. res\n\n   所有用到的图片、布局、字符串等资源都要放在这个目录下。\n\n6. AndroidMainifest\n\n   整个Android项目的配置文件，程序中定义的四大组件都需要在这个文件里注册，另外还需要在这个文件中添加权限申明。\n\n7. test\n\n   用来编写Unit Test 测试用例，是对项目自动化测试的另一种方式\n\n8. .gitignore\n\n   用于将指定的目录或者文件排除在版本控制之外，作用与外部的.gitignore相似\n\n9. app.iml\n\n   IDEA项目自动生成的文件，我们不关心或者修改这个文件中的内容。\n\n10. build.gradle\n\n    这是项目全局的gradle构建脚本，这个文件有许多的项目相关配置。\n\n11. proguard-rules.pro\n\n    这个文件用于指定项目代码的混淆规则，当代码开发完成后打成包装文件，如果不希望代码被人破解，通常会将代码进行混淆，从而让破解者难以阅读。\n\n## 项目中的资源\n\n展开res文件，有主要几种文件\n\n**drawable**开头的文件夹都是用来放图片的\n\n**mipmap**开头的文件都是用来放应用图标的\n\n**values**开头的文件夹都是用来放字符串、样式、颜色等配置的\n\n**layout**开头的文件夹都是用来存放布局文件的\n\n\n\n引用方式(以res/values/strings.xml中引用app_name为例)：\n\n- 在代码中通过R.string.app_name\n- 在XML中通过@string/app_name\n\n## 详解build.gradle文件\n\n不同于escplise，IDEA是采用Gradle来构建项目的。它基于特定的语言（DSL）来申明项目配置，摒弃了传统的XML（如Ant和Maven）的各种繁琐配置\n\n\n\n- **最外层**的目录下的bulid.gradle文件代码如下：\n\n```java\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n    }\n    dependencies {\n        classpath \"com.android.tools.build:gradle:7.0.2\"\n\n        // NOTE: Do not place your application dependencies here; they belong\n        // in the individual module build.gradle files\n    }\n}\n```\n\ndependencies 闭包中使用classpath申明了一个Gradle插件。Java、C++等很多项目都可以用Gradle来构建，我们需要用它来构建Android项目则需要申明com.android.tools.build:gradle:7.0.2这个插件，后面部分时插件版本号\n\n- **app**目录下的build.gradle文件代码如下：\n\n```java\nplugins {\n    id 'com.android.application'\n}\n\nandroid {\n    compileSdk 30\n\n    defaultConfig {\n        applicationId \"com.example.apptest\"\n        minSdk 21\n        targetSdk 30\n        versionCode 1\n        versionName \"1.0\"\n\n        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'\n        }\n    }\n    compileOptions {\n        sourceCompatibility JavaVersion.VERSION_1_8\n        targetCompatibility JavaVersion.VERSION_1_8\n    }\n}\n\ndependencies {\n\n    implementation 'androidx.appcompat:appcompat:1.2.0'\n    implementation 'com.google.android.material:material:1.3.0'\n    implementation 'androidx.constraintlayout:constraintlayout:2.0.4'\n    testImplementation 'junit:junit:4.+'\n    androidTestImplementation 'androidx.test.ext:junit:1.1.2'\n    androidTestImplementation 'androidx.test.espresso:espresso-core:3.3.0'\n}\n```\n\n\n\n## android的日志工具Log\n\n```java\n日志五种级别：\nLog.v()    Verbose //最琐碎的、意义最小的日志信息。对应级别最低的一种\n    \nLog.d()    Debug //打印调试信息\n    \nLog.i()    Info//打印比较重要的数据\n    \nLog.w()    Warn//用于打印一些警告信息\n    \nLog.e()    Error//用于打印程序中的错误信息\n```\n\n**为什么用Log不用System.out.println**\n\nSystem.out.println()的缺点：\n\n​\t日志打印不可控制、打印时间无法确定、不能添加过滤器、没有日志级别之分...\n\n"},{"title":"线索二叉树","url":"/2022/08/20/线索二叉树/","content":"# 线索二叉树\n\n## 什么是线索二叉树\n\n遍历二叉树的每个结点（除了头结点与尾结点外），每个结点都有且仅有一个直接前驱与直接后继，在遍历搜索结点时只能找到左右孩子的信息，无法找到结点在任意序列中的前驱与后继信息，这种信息只能在动态的遍历过程中才能找到。解决这种问题可以在结点中增加两个指针域来存储，刚好，每n个结点的二叉链表中一定有n+1个空链域。所以线索二叉树改变原来结构，增加了lTag与rTag来表示,其中：\n\nlTag为0时 lchild指向左孩子,为1时lchild指向前驱,rTag为0时rchild指向右孩子,rTag为1时指向后继。\n\n指向前驱与后继的指针叫线索，加上线索的二叉树叫做线索二叉树。\n\n<!--more-->\n\n## 线索二叉树的定义\n\n```c++\ntypedef char ElemType;\ntypedef struct TreeNode{\n\tTreeNode *left;\n\tTreeNode *right;\n\tElemType data;\n\tint LTag,RTag;//前驱线索与后继线索\n}//线索二叉树的定义\n```\n\n线索二叉树的定义与二叉树相比多了两个数值，其相对的储存密度变得更大，空间的使用更加的有效。其中Ltag与RTag便是前驱线索与后继线索。\n\n## 线索二叉树的遍历\n\n中序线索二叉树的结点中隐含了线索二叉树的前驱和后继信息。在对其进行遍历时，只要先找到序列中的第一个结点，然后依次找到结点的后继，直至其后继为空。\n在中序线索二叉树中找结点后继的规律是：若其标志为1，则右链为线索，指示其后继。若其标记为“0”，遍历右子树中第一个访问的结点（右子树中最左下的结点）为其后继。\n具体算法如下：\n\n线索二叉树的中序遍历\n\n```c++\nTree firstNode(Tree &t){\n\twhile(t->LTag==1){//找到线索二叉树的第一个结点 \n\t\tt = t->left;\n\t}\n\tcout<<t->left->data;\n}//遍历线索二叉树 第一个结点 \nTree nextNode(Tree &t){\n\tif(t->RTag==1){\n\t\treturn firstNode(t->right);\n\t}\n\telse{\n\t\tcout<< t->right->data;\n\t}\n}//遍历线索二叉树的后继 \n```\n\n线索二叉树的遍历也同样有先序遍历、中序遍历和后序遍历，这些遍历的实际原理与遍历二叉树的遍历相同，都使用了递归的方法，只是线索二叉树的遍历需要对线索进行判断，而且线索二叉树遍历的终点是根结点。\n\n## 主函数\n\n```c++\nint main(){\n\tTree t;\n\tCreateTree(t);//创建树 \n\tpreOrderTreaves(t);//先序遍历确认树 \n\tTree pre=NULL;\n\tinTreaved(t,pre);//线索化二叉树 \n\tnextNOde(t);//遍历线索化之后的二叉树 \n\treturn 0;\n}\n```\n\n## 完整代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXIN 20\n\ntypedef char ElemType;\ntypedef struct TreeNode{\n\tTreeNode *left;\n\tTreeNode *right;\n\tElemType data;\n\tint LTag,RTag;\n}TreeNode,*Tree;//定义线索二叉树 \n\nvoid inTreaved(Tree &t,Tree &pre){\n\tif(t){\n\t\tinTreaved(t->left,pre);//递归左子树 \n\t\tif(t->left==NULL){//线索化前驱线索 \n\t\t\tt->LTag = 1;\n\t\t\tt->left = pre;\n\t\t}\n\t\telse{\n\t\t\tt->RTag = 0;\n\t\t}\n\t\tif(t->right==NULL){//线索化后继线索 \n\t\t\tt->RTag = 1;\n\t\t\tt->right = pre;\n\t\t}\n\t\tpre = t;\n\t\tinTreaved(t->right,pre);//递归右子树 \n\t}\n}//线索化二叉树 \n\nTree firstNode(Tree &t){\n\twhile(t->LTag==1){//找到线索二叉树的第一个结点 \n\t\tt = t->left;\n\t}\n\tcout<<t->left->data;\n}//遍历线索二叉树 第一个结点 \nTree nextNode(Tree &t){\n\tif(t->RTag==1){\n\t\treturn firstNode(t->right);\n\t}\n\telse{\n\t\tcout<< t->right->data;\n\t}\n}//遍历线索二叉树的后继 \n\nint CreateTree(Tree &t){\n\tchar ch;\n\tcin>>ch;\n\tif(ch=='#') t=NULL;\n\telse{\n\t\tt = new TreeNode;\n\t\tt->data = ch;\n\t\tCreateTree(t->left);\n\t\tCreateTree(t->right);\n\t}\n//\tcout<<\"创建成功\";\n}//先序创建树 \n\nvoid preOrderTreaves(Tree &t){\n\tif(t){\n\t\tpreOrderTreaves(t->left);\n\t\tcout<<t->data; \n\t\tpreOrderTreaves(t->right);\n\t}\n}//先序遍历二叉树 \n\nint main(){\n\tTree t;\n\tCreateTree(t);//创建树 \n\tpreOrderTreaves(t);//先序遍历确认树 \n\tTree pre=NULL;\n\tinTreaved(t,pre);//线索化二叉树 \n\tnextNOde(t);//遍历线索化之后的二叉树 \n\treturn 0;\n} \n/*\nabdh##i##ej##k##cfl###g##//先序创建二叉树实例\n*/\n```\n\n------\n\n谢谢阅读！\n<!--more-->"},{"title":"位运算","url":"/2022/08/20/位运算/","content":"\n\n# 位运算\n\n## 左右移\n\n计算机中数的储存一般都是用补码来存储的，而补码：其中正数是和原码一样的，而负数的补码先有其原码取反，再加一得来。\n\n左右移是位运算的常见操作\n\n<!--more-->\n\n### 右移\n\n右移有两种：有符号右移与无符号右移\n\n无符号的右移，是数字二进制码的最高位是符号位，1代表为负数，0代表为正数，在进行移位操作的时候，最高位补位（负数补1，正数补0），最低位舍弃，其余的位置都向右移动n（n代表要移动的位数）位\n\n右移可以看作将原数除了n个2得到的结果，如：8右移两位得到2，8除以两次2得到的也是2；\n\n例：将数字8右移2位\n\n8的原码是0000 1000 ->  8的补码是0000 1000 -> 右移两位后的补码 0000 0010 代表的数字是2；\n\n-8的原码是1000 1000 -> -8的补码是1111 1000 -> 右移两位后的补码是1111 1110代表的数字是-2；\n\n用C++来验证结果： \n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint a = 8 , b = -8;\n\ta=a>>2;\n\tb=b>>2;\n\tcout<<\"a=\"<<a<<endl<<\"b=\"<<b<<endl;\n}\n```\n\n### 左移\n\n左移是高位舍弃，低位补0，其余的位置都左移两位\n\n左移之后，得到的结果是原数连乘多次得到的结果一样，如：将8左移两位，得到的数是32，而将8连乘两次2，得到的数是32.\n\n用C++来验证结果：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint a = 8 , b = -8;\n\ta=a<<2;\n\tb=b<<2;\n\tcout<<\"a=\"<<a<<endl<<\"b=\"<<b<<endl;\n}\n```\n\n## 异或\n\n异或也是算法中常用的操作，异或运算时，所有相同的位值相同则为0，不同为1。如：\n\n1与2 异或运算  1的补码为0001 2的补码为0010 异或之后得到的数为0011——3\n\n异或的符号为”^“(不是高中数学见过的圆圈加括号)\n\n异或可以用来在没有第三个变量的时候交换两个变量的值\n\n代码如下：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint a = 3 , b = -3;\n\tif(a!=b){\n\t\ta^=b;//这里的代码用了简写，完整：a=a^b;\n\t\tb^=a;//简写同上\n\t\ta^=b;\n\t}\n\tcout<<\"a=\"<<a<<endl<<\"b=\"<<b<<endl;\n}\n```\n\n## 与运算\n\n### 运算规则:\n\n两个操作数对应的二进制位，都为1则为1，否则为0。如：1&1=1； 1&0=0； 0&1=0； 0&0=0\n\n## 或运算\n\n### 运算规则:\n\n两个操作数对应的二进制位，有1则为1，否则为0。如：1|1=1； 1|0=1； 0|1=1； 0|0=0\n\n## 按位非（按位取反）~\n\n### 运算规则:\n\n两个操作数对应的二进制位，取反操作。如：1->0； 0->1\n\n验证代码如下：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint a,b;\n\ta = 2;\n\tb = ~(a);\n\tcout<<a<<endl<<b<<endl; //a是原来的数，b是取反的数\n}\n```\n\n\n<!--more-->"},{"title":"图的存储","url":"/2022/08/20/图的存储/","content":"\n\n# 邻接矩阵及邻接表储存图的信息\n\n## 图的存储方式\n\n一般的图的基本存储方式有三种，邻接矩阵法、邻接表法和十字链表法，其中邻接矩阵与邻接表是最简单的图的储存结构。\n\n<!--more-->\n\n## 邻接矩阵的介绍\n\n顶点数据存储\n\n- 一位数组\n\n边（弧）信息的存储\n\n- 邻接矩阵：图中n个顶点之间相邻关系的n阶方阵（即二维数组a[n] [n]）\n- 邻接矩阵中元素值的情况（规定自身无边、无弧）\n- 二维数组中的元素值为1表示存在关系、值为0表示不存在关系\n\n表示无向图时的特点：\n\n- 矩阵对角线对称\n- 行方向或列防向的非零元素个数为该顶点的度\n\n表示有向图时的特点：\n\n- 矩阵不对称\n- 行方向非零元素的个数表示顶点元素的出度\n- 列方向非零元素的个数表示顶点元素的入度\n\n邻接矩阵本身的特点：\n\n优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边（弧）、栈顶点的邻接点等。\n\n缺点：n个顶点需要n*n个单元存储边（弧）；空间效率为O(n^2)。\n\n## 邻接矩阵的实现\n\n### 定义邻接矩阵\n\n```c++\ntypedef int ElemType;\ntypedef struct MGraph{\n\tint vn,en;\n\tElemType vex[MAXIN];\n\tElemType arc[MAXIN][MAXIN];\n}MGraph;//定义无向图\n```\n\n### 创建邻接矩阵\n\n```c++\nint CreateGraph(MGraph &g){\n\tcout<<\"请输入图的顶点数与边数\"<<endl;\n\tcin>>g.vn>>g.en;\n\tcout<<\"请输入顶点信息\"<<endl;\n\tfor(int i=0;i<g.vn;i++){\n\t\tcin>>g.vex[i];\n\t}\n\tfor(int i=0;i<g.vn;i++){\n\t\tfor(int j=0;j<g.vn;j++){\n\t\t\tg.arc[i][j] = 0;\n\t\t}\n\t}//初始化邻接矩阵\n\tcout<<\"请输入图的关系\"<<endl;\n\tint f,l;\n\tfor(int i=0;i<g.en;i++){\n\t\tcin>>f>>l;\n\t\tg.arc[f][l] = 1;\n\t\tg.arc[l][f] = g.arc[f][l];\n\t}\n\tcout<<\"创建成功\"<<endl;\n}//创建无向图 \n```\n\n### 打印邻接矩阵\n\n```c++\nvoid Print(MGraph g){\n\tfor(int i=0;i<g.vn;i++){\n\t\tfor(int j=0;j<g.vn;j++){\n\t\t\tcout<<g.arc[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}//打印邻接矩阵 \n```\n\n### 完整代码\n\n```c++\n#include<bits/stdc++.h>\n//利用邻接矩阵存储无向图 \nusing namespace std;\n\n#define MAXIN 20\n\ntypedef int ElemType;\ntypedef struct MGraph{\n\tint vn,en;\n\tElemType vex[MAXIN];\n\tElemType arc[MAXIN][MAXIN];\n}MGraph;//定义无向图\n\nint CreateGraph(MGraph &g){\n\tcout<<\"请输入图的顶点数与边数\"<<endl;\n\tcin>>g.vn>>g.en;\n\tcout<<\"请输入顶点信息\"<<endl;\n\tfor(int i=0;i<g.vn;i++){\n\t\tcin>>g.vex[i];\n\t}\n\tfor(int i=0;i<g.vn;i++){\n\t\tfor(int j=0;j<g.vn;j++){\n\t\t\tg.arc[i][j] = 0;\n\t\t}\n\t}//初始化邻接矩阵\n\tcout<<\"请输入图的关系\"<<endl;\n\tint f,l;\n\tfor(int i=0;i<g.en;i++){\n\t\tcin>>f>>l;\n\t\tg.arc[f][l] = 1;\n\t\tg.arc[l][f] = g.arc[f][l];\n\t}\n\tcout<<\"创建成功\"<<endl;\n}//创建无向图 \n\nvoid Print(MGraph g){\n\tfor(int i=0;i<g.vn;i++){\n\t\tfor(int j=0;j<g.vn;j++){\n\t\t\tcout<<g.arc[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n}//打印邻接矩阵 \n\nint main(){\n\tMGraph g;\n\tCreateGraph(g);\n\tPrint(g);\n}\n```\n\n## 邻接表的介绍\n\n是顺序与链接相结合的图的存储方式\n\n所有顶点组成一个数组，每个顶点建立一个单链表\n\n有两部分组成：\n\n- 表头——顶点数组（存放顶点信息）\n- 表体——单链表（存放与顶点相关的边或者弧的关系）\n\n表示无向图时的特点：\n\n- 顶点的度——与结点相连的单链表的个数\n\n表示有向图时的特点：\n\n- 顶点的出度——与结点相连的单链表的个数\n- 顶点的入度——遍历所有结点，统计得到\n\n邻接表本身的特点：\n\n有点：空间效率高，容易找到顶点的邻接点\n\n缺点：判断两个顶点是否有关联时需要遍历该结点的单链表，没有邻接矩阵方便\n\n## 邻接表的实现\n\n### 定义邻接表\n\n```c++\ntypedef int ElemType;\ntypedef struct ArcNode{\n\tElemType vertvex;\n\tArcNode *next;\n}ArcNode,*Arc;//创建结点存储链表结构\ntypedef struct {\n\tElemType adjvex;\n\tArcNode *firstarc;\n}VexNode;//结点类型\ntypedef struct {\n\tint vn,en;\n\tVexNode vex[MAXIN];\n}ALGraph;//创建邻接表存储结构 \n```\n\n### 创建邻接表\n\n```c++\nint CreateGraph(ALGraph &a){\n\t cout<<\"请输入有向图的结点数与弧数\"<<endl;\n\t cin>>a.en>>a.vn;\n\t cout<<\"请输入结点信息\"<<endl;\n\t for(int i=0;i<a.vn;i++){\n\t \tcin>>a.vex[i].adjvex;\n\t \ta.vex[i].firstarc = NULL;\n\t }\n\t cout<<\"请输入结点关系\"<<endl;\n\t int f,l;\n\t for(int i=0;i<a.en;i++){\n\t \tcin>>f>>l;\n\t \tArc p = (ArcNode *)malloc(sizeof(ArcNode));\n\t \tp->vertvex = l;\n\t \tp->next = a.vex[f].firstarc;\n\t \ta.vex[f].firstarc = p;\n\t }\n\t cout<<\"创建成功\"<<endl;\n}//创建邻接表 \n```\n\n### 完整代码\n\n```c++\n#include<bits/stdc++.h>\n//邻接表存储结构的有向图 \nusing namespace std;\n\n#define MAXIN 20\n\ntypedef int ElemType;\ntypedef struct ArcNode{\n\tElemType vertvex;\n\tArcNode *next;\n}ArcNode,*Arc;//创建结点存储链表结构\ntypedef struct {\n\tElemType adjvex;\n\tArcNode *firstarc;\n}VexNode;//结点类型\ntypedef struct {\n\tint vn,en;\n\tVexNode vex[MAXIN];\n}ALGraph;//创建邻接表存储结构 \n\nint CreateGraph(ALGraph &a){\n\t cout<<\"请输入有向图的结点数与弧数\"<<endl;\n\t cin>>a.en>>a.vn;\n\t cout<<\"请输入结点信息\"<<endl;\n\t for(int i=0;i<a.vn;i++){\n\t \tcin>>a.vex[i].adjvex;\n\t \ta.vex[i].firstarc = NULL;\n\t }\n\t cout<<\"请输入结点关系\"<<endl;\n\t int f,l;\n\t for(int i=0;i<a.en;i++){\n\t \tcin>>f>>l;\n\t \tArc p = (ArcNode *)malloc(sizeof(ArcNode));\n\t \tp->vertvex = l;\n\t \tp->next = a.vex[f].firstarc;\n\t \ta.vex[f].firstarc = p;\n\t }\n\t cout<<\"创建成功\"<<endl;\n}//创建邻接表 \n\nint main(){\n\tALGraph a;\n\tCreateGraph(a);\n}\n```\n\n------\n\n谢谢阅读！\n<!--more-->"},{"title":"顺序栈","url":"/2022/08/20/顺序栈/","content":"\n\n# 顺序栈\n\n## 什么是顺序栈\n\n顺序栈是指利用顺序存储结构实现的栈，即利用一组地址连续的存储单元依次存放自栈底到栈顶的数据元素，同时附设指针top指示栈顶元素在顺序栈中的位置。\n\n<!--more-->\n\n## 顺序栈的定义\n\n栈需要一个bottom指针做栈底，需要一个top指针做栈顶,需要一个size来做栈的长。\n\n```c++\ntypedef struct LStack{\n\tint size;\n\tint *top;\n\tint *bottom;\n}LStack;//定义栈 \n```\n\n## 顺序栈的初始化\n\n*注：本博客的top总是指向下一个空栈，所有的访问栈顶都需要指针下移一位\n\n栈的初始化需要将栈顶与栈底指针放在一起，当压栈的时候指针再向下走一位，size为栈的长度，不是栈底到栈顶的长度\n\n```c++\nint initStack(LStack &s){\n\ts.bottom = (int *)malloc(MAXIN*sizeof(int));\n\tif(!s.bottom){\n\t\tcout<<\"地址分配失败\"<<endl;\n\t\treturn 0;\n\t}\n\ts.top = s.bottom;\n\ts.size = MAXIN;\n\tcout<<\"初始化成功\"<<endl;\n\treturn 0;\n}//初始化栈 \n```\n\n栈的地址依然用动态地址分配\n\n## 顺序栈的压入\n\n顺序栈的压入需要将栈顶指针向上移动，这个时候需要先判断栈顶指针是否到达最远，及top指针是否为空（前面定义栈时已经给了栈的大小size。栈顶指针在赋值后要继续指向下一位。\n\n```c++\nint Push(LStack &s,ElemType e){\n\tif(!s.top){\n\t\tcout<<\"栈满\"<<endl;\n\t\treturn 0;\n\t}\n\t*(s.top)=e;\n\ts.top++;\n//\tcout<<\"压栈成功\"<<endl;\n\treturn 0;\n}//压栈 \n```\n\n## 顺序栈的弹出\n\n弹出时依然需要做判空处理，即判断是否top==bottom——栈空，同时也用来判断栈顶指针是否需要继续下移一位。\n\n```c++\nint Pop(LStack &s){\n\tif(s.top==s.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0;\n\t}\n\ts.top--;\n\tcout<<\"弹出成功\"<<endl;\n\treturn 0; \n}//弹栈\n```\n\n## 顺序栈取顶\n\n取栈顶元素是比较重要的操作，可以方便我们判断操作是否正确执行，或者程序是否按我们的想法在运行。\n\n```c++\nElemType GetTop(LStack s){\n\tElemType e;\n\tif(s.top==s.bottom){\n\t\tcout<<\"栈已空\"<<endl;\n\t\treturn 0;\n\t}\n\te = *(s.top-1);\n\tcout<<\"现在的栈顶元素为：\"<<e<<endl;\n\treturn e;\n}//获得栈顶元素 \n```\n\n## 完整代码演示\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXIN 20\n\ntypedef int ElemType;\ntypedef struct LinkStack{\n\tint *top;\n\tint *bottom;\n\tint size;\n}LinkStack;//定义链式栈 \n\nint InitStack(LinkStack &s){\n\ts.bottom = (int *)malloc(MAXIN*sizeof(int));\n\tif(!s.bottom){\n\t\tcout<<\"地址分配失败\"<<endl;\n\t\treturn 0;\n\t}\n\ts.top = s.bottom;\n\ts.size = MAXIN;\n\tcout<<\"初始化成功\"<<endl;\n\treturn 0;\n}//初始化链式栈 \n\nint Push(LinkStack &s,ElemType e){\n\tif(!s.top){\n\t\tcout<<\"栈满\"<<endl;\n\t\treturn 0;\n\t}\n\t*s.top = e;\n\ts.top++;\n\tcout<<\"压入成功\"<<endl;\n\treturn 0;\n}//压入 \n\nint Pop(LinkStack &s){\n\tif(s.top == s.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0; \n\t}\n\ts.top--;\n\tcout<<\"弹出成功\"<<endl;\n\treturn 0;\n}//弹出\n \nElemType GetStack(LinkStack s){\n\tif(s.top==s.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<\"栈顶元素为：\"<<*(s.top-1)<<endl;\n\treturn *(s.top-1); \n}//取栈顶元素 \n\nint main(){\n\tLinkStack s;\n\tInitStack(s);\n\tElemType e;\n\tcout<<\"请输入要压入的栈元素\"<<endl;\n\tfor(int i=0;i<5;i++){\n\t\tcin>>e;\n\t\tPush(s,e);\n\t}\n\tcout<<\"现在的栈顶元素为：\"<<endl;\n\tGetStack(s);\n\tcout<<\"弹出一个栈顶元素\"<<endl;\n\tPop(s);\n\tcout<<\"现在的栈顶元素为：\"<<endl; \n\tGetStack(s);\n} \n```\n\n------\n\n谢谢阅读！\n\n接下来可能会写一些用栈解决的算法问题，感兴趣的小伙伴可以继续关注！！！\n<!--more-->"},{"title":"顺序链表","url":"/2022/08/20/顺序链表/","content":"\n\n# 顺序表\n\n## 什么是顺序表？\n\n顺序表是用来储存数据的一种结构，它会获取计算机一段连续等长的存储空间来存储数据，数组便是最常见也最方便的使用方法\n\n<!--more-->\n\n顺序表由于存储位置连续，有容易浪费存储空间的缺点，但是顺序表在查询存储位置的时候非常的方便，只要输入位置信息（头地址，存储的位置），就能很快地找到数据。\n\n## 顺序表的基本操作\n\n顺序表完全可以使用数组来直接构造，其定义代码如下：\n\n```c++\n#define MAXIN 20//初定义\n\ntypedef int ELemType;\ntypedef struct{\n    ElemType *data[MAXIN];//数据存放的数组\n    int len;\n}SqList;\n```\n\n但是顺序表的缺点在于储存的浪费，所以还是建议使用动态分配的方法来建立顺序表（但是在最后要注意将分配地址释放，避免数据溢出），下面是利用动态分配的方法构造的顺序表：\n\n```c++\n#define MAXIN 20\n#define ADD 20//分配地址不够用时方便添加\ntypedef int ElemType ;//初定义\n\ntypedef struct {\n\tElemType *head;//头指针用来确定顺序表的位置\n\tint len;//顺序表储存数据的长度\n\tint size;//顺序表的长度\n}SqList;//定义顺序表 \n```\n\n接下来就是顺序表的基本操作了，最后会附上包括验证的完整的代码，定义部分与上文相同：\n\n### 初始化顺序表：\n\n```c++\nint InitList(SqList &L){\n\tL.head = (int *)malloc(MAXIN*sizeof(int));//给头指针分配地址\n\tif(!L.head){//确认地址分配成功\n\t\tcout<<\"地址分配失败\"<<endl;\n\t\treturn 0;\n\t}\n\tL.len=0;//初始化顺序表的数据长度，因为没有放数据所以该变量为0\n\tL.size = MAXIN;//初始化表长度，为MAXIN\n\tcout<<\"初始化成功\"<<endl; \n\treturn 0;\n}//初始化顺序表 \n```\n\n### 打印顺序表：\n\n```c++\nvoid Print(SqList L){\n\tcout<<\"当前的顺序表为：\"<<endl;\n\tfor(int i=0;i<L.len;i++){\n\t\tcout<<L.head[i]<<\" \";\n\t}\n\tcout<<endl;\n}//打印 \n```\n\n### 插入数据：\n\n```c++\nint InsertList(SqList &L,int i,ElemType e){\n    //确认插入的位置是否有误\n\tif(i<0||i>L.size){\n\t\tcout<<\"插入位置错误\"<<endl;\n\t\treturn 0;\n\t}\n    //如果插入时存储位置不够则需要再扩增存储空间\n\tif(L.len==L.size){\n\t\tL.head = (int *)malloc((MAXIN+ADD)*sizeof(int));\n\t\tL.size+=ADD;\n\t\tif(!L.head){\n\t\t\tcout<<\"地址分配失败\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n    //将该位置后的数据各向后移动一位\n\tfor(int j = L.len-1 ;j>=i-1;j--){\n\t\tL.head[j+1] = L.head[j];\n\t} \n    //给插入位置赋值\n\tL.head[i-1] = e;\n\tL.len++;//顺序表数据存储长度加一位\n\tcout<<\"插入成功\"<<endl;\n\treturn 0;\n}//插入 \n```\n\n### 删除数据：\n\n```c++\nint DeleteList(SqList &L,int i){\n\tif(i<0||i>L.len){//判断删除位置是否有误\n\t\tcout<<\"删除的位置有误\"<<endl;\t\n\t\treturn 0;\n\t}\n    //将改位置之后的所有数据向前移动一位\n\tfor(int j = i-1;j<L.len;j++){\n\t\tL.head[j] = L.head[j+1];\n\t}\n\tcout<<\"删除成功\"<<endl;\n\treturn 0;\n}//删除 \n\n```\n\n在删除与插入操作中，我们一定记得要确认删除或插入的位置是否符合要求，避免数据溢出。\n\n在插入操作中，插入的位置之后所有的数据都要向后移动。\n\n```c++\nfor(int j = L.len-1 ;j>=i-1;j--){\n\t\tL.head[j+1] = L.head[j];\n\t} \n```\n\n删除时也要进行移位操作，所有该位置之后的数据向前移动一位。\n\n```c++\nfor(int j = i-1;j<L.len;j++){\n\t\tL.head[j] = L.head[j+1];\n\t}\n```\n\n------\n\n### 完整代码：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXIN 20\n#define ADD 20\ntypedef int ElemType ;\n\ntypedef struct {\n\tElemType *head;\n\tint len;\n\tint size;\n}SqList;//定义顺序表 \n\nint InitList(SqList &L){\n\tL.head = (int *)malloc(MAXIN*sizeof(int));\n\tif(!L.head){\n\t\tcout<<\"地址分配失败\"<<endl;\n\t\treturn 0;\n\t}\n\tL.len=0;\n\tL.size = MAXIN;\n\tcout<<\"初始化成功\"<<endl; \n\treturn 0;\n}//初始化顺序表 \n\nint CreateList(SqList &L){\n\tint n,m;\n\tcout<<\"请输入顺序表的长度\"<<endl;\n\tcin>>n;\n\tif(n<0||n>MAXIN){\n\t\tcout<<\"输入的顺序表长度有误\"<<endl;\n\t\treturn 0;\n\t}\n\tcout<<\"请输入顺序表的数据\"<<endl;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>L.head[i];\n\t}\n\tL.len += n;\n\tcout<<\"顺序表创建成功\"<<endl;\n\tfor(int i=0;i<n;i++){\n\t\tcout<<L.head[i]<<\" \";\n\t}\n\tcout<<endl;\n}//创建新的顺序表 \n\nint InsertList(SqList &L,int i,ElemType e){\n\tif(i<0||i>L.size){\n\t\tcout<<\"插入位置错误\"<<endl;\n\t\treturn 0;\n\t}\n\tif(L.len==L.size){\n\t\tL.head = (int *)malloc((MAXIN+ADD)*sizeof(int));\n\t\tL.size+=ADD;\n\t\tif(!L.head){\n\t\t\tcout<<\"地址分配失败\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int j = L.len-1 ;j>=i-1;j--){\n\t\tL.head[j+1] = L.head[j];\n\t} \n\tL.head[i-1] = e;\n\tL.len++;\n\tcout<<\"插入成功\"<<endl;\n\treturn 0;\n}//插入 \n\nint DeleteList(SqList &L,int i){\n\tif(i<0||i>L.len){\n\t\tcout<<\"删除的位置有误\"<<endl;\t\n\t\treturn 0;\n\t}\n\tfor(int j = i-1;j<L.len;j++){\n\t\tL.head[j] = L.head[j+1];\n\t}\n\tcout<<\"删除成功\"<<endl;\n\treturn 0;\n}//删除 \n\nvoid Print(SqList L){\n\tcout<<\"当前的顺序表为：\"<<endl;\n\tfor(int i=0;i<L.len;i++){\n\t\tcout<<L.head[i]<<\" \";\n\t}\n\tcout<<endl;\n}//打印 \n\nint main(){\n\tSqList L;\n\tInitList(L);\n\tCreateList(L);\n\tPrint(L);\n\tint n,i;\n\tcout<<\"请输入你要插入的数，位置\"<<endl;\n\tcin>>n>>i;\n\tInsertList(L,i,n);\n\tPrint(L);\n\tcout<<\"请输入删除的位置\"<<endl; \n\tcin>>i;\n\tDeleteList(L,i);\n\tPrint(L); \n\treturn 0;\n}\n```\n\n------\n\n谢谢阅读！\n<!--more-->"},{"title":"树的存储结构","url":"/2022/08/20/树的存储结构/","content":"# 树的存储结构\n\n有三种常见的树的存储结构，分别是双亲表示法、孩子表示法和孩子兄弟表示法。\n\n<!--more-->\n\n## 双亲表示法\n\n这种结构利用了每个结点只有唯一 双亲的性质，可以快速的在常量时间内找到根结点。但是这种表示法，求结点孩子时需要遍历整个树结构。\n\n```c++\ntypedef char ElemType;\ntypedef struct PTNode{\n\tElemType data;\n\tint parent;\n}PTNode;//定义结点结构 \ntypedef struct PTree{\n\tPTNode nodes[MAXIN];\n\tint r,n;//根的位置和结点数量 \n}PTree;//双亲表示法 \n```\n\n## 孩子表示法\n\n这种表示法与双亲表示法刚好相反，将每个孩子的结点排列起来形成一个线性表，且以单链表为储存结构，则n个孩子有n 个单链表，n个孩子链表的头指针又可以组成一个顺序表，为了方便查找，可以将利用顺序存储结构，定义如下：\n\n```c++\ntypedef char ElemType;\ntypedef struct CTNode{\n\tint child;\n\tCTNode *next;\n}*CPT;//单链表表示的孩子结点\ntypedef struct {\n\tElemType data;\n\tCPT firstchild;//每个链表的第一个孩子 \n}CTBox;\ntypedef struct {\n\tCTBox nodes[MAXIN];\n\tint r,n;//树的根位置，结点数 \n}CTree;//树结构\n```\n\n# 孩子-兄弟表示法\n\n又称二叉树表示法或者二叉链表表示法。以二叉链表作为树的存储结构。链表中结点的两个链域分别是孩子链域与兄弟链域，这个结构可以快速的实现多种操作，比如要想找到x结点的第i个孩子，则只需要在x的结点向下寻找nextsilbing结点i-1次。以下是该种结构树的存储方法。\n\n```c++\ntypedef struct CSNode{\n\tElemType data;\n\tCSNode *firstchild,*nextsibling;//孩子结点与兄弟结点 \n};//孩子-兄弟表示法 \n```\n\n\n<!--more-->"},{"title":"三元组稀疏矩阵","url":"/2022/08/20/三元组稀疏矩阵/","content":"\n\n# 三元组稀疏矩阵\n\n## 三元组稀疏矩阵的定义\n\n<!--more-->\n\n```c++\ntypedef struct Trip{\n\tint row;\n\tint pol;\n\tint item; \n}Trip;//三元表数据的构造 \ntypedef struct TripM{\n\tTrip data[MAXIN];\n\tint num=0;\n\tint rn,ln;\n}TripM;//三元表构造 \n```\n\n## 稀疏矩阵的创建\n\n```c++\nint CreateTrip(TripM &t){\n\tcout<<\"请输入矩阵的行与列\"<<endl;\n\tcin>>t.rn;\n\tcin>>t.ln;\n\tElemType e;\n\tfor(int i=0;i<t.rn;i++){\n\t\tfor(int j=0;j<t.ln;j++){\n\t\t\tcin>>e;\n\t\t\tif(e!=0){\n\t\t\t\tt.data[t.num].item = e;\n\t\t\t\tt.data[t.num].pol = j;\n\t\t\t\tt.data[t.num].row = i;\n\t\t\t\tt.num++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"创建成功\"<<endl;\n}//创建三元表矩阵 \n```\n\n这里是输入整个矩阵（包括零），对于输入可以非常的清晰方便查看输入错误，但是不便于快速输入多零的稀疏矩阵。\n\n## 稀疏矩阵的打印\n\n```c++\nint Print(TripM t){\n\tif(t.num==0){\n\t\tcout<<\"矩阵为0\"<<endl;\n\t\treturn 0; \n\t}\n\tint k=0;\n\tfor(int i=0;i<t.rn;i++){\n\t\tfor(int j=0;j<t.ln;j++){\n\t\t\tif(t.data[k].row==i&&t.data[k].pol==j){\n\t\t\t\tcout<<t.data[k].item<<\" \";\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<0<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}//打印矩阵 \n```\n\n## 稀疏矩阵三元表的打印\n\n```c++\nvoid Print3(TripM t){\n\tcout<<\"三元表格式为\"<<endl; \n\tint k=0;\n\tfor(int i=0;i<t.num;i++){\n\t\tcout<<t.data[k].row<<\" \"<<t.data[k].pol<<\" \"<<t.data[k].item<<endl;\n\t\tk++;\n\t}\n}//打印三元表 \n```\n\n## 稀疏矩阵的转置\n\n```c++\nint nizhi(TripM &t,TripM &t1){\n\tt1.ln = t.rn;\n\tt1.rn = t.ln;\n\tt1.num = t.num;\n\tif(t1.num){\n\t\tint k=0;\n\t\tfor(int i=0;i<t.ln;i++){\n\t\t\tfor(int j=0;j<t.num;j++){\n\t\t\t\tif(i==t.data[j].pol){\n\t\t\t\t\tt1.data[k].row = t.data[j].pol;\n\t\t\t\t\tt1.data[k].pol = t.data[j].row;\n\t\t\t\t\tt1.data[k].item = t.data[j].item;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\tcout<<\"逆置成功\"<<endl;\n}//稀疏矩阵的逆置 \n```\n\n## 完整代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n//三元表表示稀疏矩阵 \n#define MAXIN 100\n\ntypedef int ElemType;\ntypedef struct Trip{\n\tint row;\n\tint pol;\n\tint item; \n}Trip;//三元表数据的构造 \n\ntypedef struct TripM{\n\tTrip data[MAXIN];\n\tint num=0;\n\tint rn,ln;\n}TripM;//三元表构造 \n\nint CreateTrip(TripM &t){\n\tcout<<\"请输入矩阵的行与列\"<<endl;\n\tcin>>t.rn;\n\tcin>>t.ln;\n\tElemType e;\n\tfor(int i=0;i<t.rn;i++){\n\t\tfor(int j=0;j<t.ln;j++){\n\t\t\tcin>>e;\n\t\t\tif(e!=0){\n\t\t\t\tt.data[t.num].item = e;\n\t\t\t\tt.data[t.num].pol = j;\n\t\t\t\tt.data[t.num].row = i;\n\t\t\t\tt.num++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"创建成功\"<<endl;\n}//创建三元表矩阵 \n\nint Print(TripM t){\n\tif(t.num==0){\n\t\tcout<<\"矩阵为0\"<<endl;\n\t\treturn 0; \n\t}\n\tint k=0;\n\tfor(int i=0;i<t.rn;i++){\n\t\tfor(int j=0;j<t.ln;j++){\n\t\t\tif(t.data[k].row==i&&t.data[k].pol==j){\n\t\t\t\tcout<<t.data[k].item<<\" \";\n\t\t\t\tk++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcout<<0<<\" \";\n\t\t\t}\n\t\t}\n\t\tcout<<endl;\n\t}\n}//打印矩阵 \n\nvoid Print3(TripM t){\n\tcout<<\"三元表格式为\"<<endl; \n\tint k=0;\n\tfor(int i=0;i<t.num;i++){\n\t\tcout<<t.data[k].row<<\" \"<<t.data[k].pol<<\" \"<<t.data[k].item<<endl;\n\t\tk++;\n\t}\n}//打印三元表 \n\nint nizhi(TripM &t,TripM &t1){\n\tt1.ln = t.rn;\n\tt1.rn = t.ln;\n\tt1.num = t.num;\n\tif(t1.num){\n\t\tint k=0;\n\t\tfor(int i=0;i<t.ln;i++){\n\t\t\tfor(int j=0;j<t.num;j++){\n\t\t\t\tif(i==t.data[j].pol){\n\t\t\t\t\tt1.data[k].row = t.data[j].pol;\n\t\t\t\t\tt1.data[k].pol = t.data[j].row;\n\t\t\t\t\tt1.data[k].item = t.data[j].item;\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\n\tcout<<\"逆置成功\"<<endl;\n}//稀疏矩阵的逆置 \n\nint main(){\n\tTripM t;\n\tCreateTrip(t);\n\tPrint(t);\n\tPrint3(t);\n\tTripM t1;\n\tcout<<\"逆置\"<<endl;\n\tnizhi(t,t1);\n\tPrint(t1);\n\tPrint3(t1);\n}\n\n/*\n稀疏矩阵的输入实例 \n6 7\n0 0 0 0 0 0 7\n0 0 0 5 0 0 0\n0 0 0 3 0 0 0 \n4 0 0 0 2 0 0 \n0 0 1 0 0 0 1 \n0 0 0 0 0 0 0 \n*/\n```\n\n------\n\n谢谢阅读！\n<!--more-->"},{"title":"汉诺塔的实现","url":"/2022/08/20/汉诺塔的实现/","content":"# 汉诺塔\n\n## 汉诺塔的规则\n\n汉诺游戏规则如下：\n\n1、有三根相邻的柱子，标号为A,B,C。\n\n2、A柱子上从下到上按金字塔状叠放着n个不同大小的圆盘。\n\n3、现在把所有盘子一个一个移动到柱子B上，并且每次移动同一根柱子上都不能出现大盘子在小盘子上方。\n\n<!--more-->\n\n**扩展资料**（百度百科）：\n\n汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。\n\n大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。\n\n并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n\n## 汉诺塔的递归实现\n\n汉诺塔的递归思想：\n\n对于第一次接触的同学来说，递归思想可能会非常的难以理解。但是在思考这一类问题时只要了解递归的两大要素那么应该会更好的解决问题。首先递归有两大要素，一个是递，另一个就是归了。“递”指的是继续下去的操作，“归”指的是终结并向上进行的操作。汉诺塔就是非常典型的递归的例子。\n\n汉诺塔的“递”就是要将圆盘向目标的柱子转移，而\"归\"就是圆盘无法向目标柱子转移时可以选择向之前的柱子转移。而这个递归结束的标志就是最后开始的柱子上的圆盘全部转移到目标柱子上的时侯。\n\n以下是汉诺塔的递归写法\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nmove(char x,char y){\n\tcout<<x<<\"=>\"<<y<<endl;\n}\n\nint hanoi(int n,char a,char b,char c){\n\tif(n==1){\n\t\tmove(a,c);//当柱子上剩下最后一个的时候，将它移动向目标柱子c\n\t}\n\telse{\n\t\thanoi(n-1,a,c,b);//如果不能移动就通过C移动向b\n\t\tmove(a,c);//然后将a上面的圆盘移动向c \n\t\thanoi(n-1,b,a,c);//最后将b柱子上剩下的通过a移动向c \n\t}\n\treturn 0;\n}\n\nint main(){\n\tint n;//有n层圆盘 \n\tcin>>n;\n\tchar a='a',b='b',c='c';//定义三个圆盘 \n\thanoi(n,a,b,c);//汉诺塔最初的放置,n层汉诺塔放在a上,最后将放在c上 \n}\n```\n\n## 汉诺塔的栈实现\n\n汉诺塔与栈的储存结构很像——先进后出的结构，所以可以用栈来模仿汉诺塔的运行。\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define MAXIN 20\n\ntypedef int ElemType;\ntypedef struct LStack{\n\tint size;\n\tint *top;\n\tint *bottom;\n}LStack;//定义栈 \n\nint InitStack(LStack &s){\n\ts.bottom = (int *)malloc(MAXIN*sizeof(int));\n\tif(!s.bottom){\n\t\tcout<<\"分配地址失败\"<<endl;\n\t\treturn 0;\n\t}\n\ts.top= s.bottom;\n\ts.size = MAXIN;\n\tcout<<\"初始化成功\"<<endl;\n\treturn 0; \n}//初始化 \n\nint GetTop(LStack s){\n\tif(s.top == s.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0; \n\t}\n\tElemType e;\n\te = *(s.top-1);\n\tcout<<\"栈顶元素为：\"<<e;\n\treturn *(s.top-1); \n}//取栈顶元素 \n\nint Push(LStack &s,ElemType e){\n\tif(!s.top){\n\t\tcout<<\"栈满\"<<endl;\n\t\treturn 0;\n\t}\n\t*s.top = e;\n\ts.top++;\n\tGetTop(s);\n//\tcout<<\"压栈成功\"<<endl;\n\treturn 0;\n}//压栈\n\nint Pop(LStack &s,ElemType e){\n\tif(s.top == s.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0;\n\t}\n\t*(s.top-1) = e;\n\ts.top--;\n\tGetTop(s);\n//\tcout<<\"弹栈成功\"<<endl;\n} //弹栈 \n\nint Print(LStack s){\n\tLStack p = s;\n\tif(p.top==p.bottom){\n\t\tcout<<\"栈空\"<<\" \";\n\t\treturn 0;\n\t}\n\twhile(p.top&&p.top!=p.bottom){\n\t\tcout<<*(p.top-1)<<\" \";\n\t\tp.top--;\n\t}\n\tcout<<endl;\n}//打印汉诺塔 \n\nint move(LStack &s1,LStack &s2,LStack &s3){\n\tif(s1.top==s1.bottom){\n\t\tcout<<\"栈空\"<<endl;\n\t\treturn 0; \n\t}\n\tElemType x;\n\tPop(s1,x);\n\tPush(s2,x);\n\tcout<<\"移动成功\"<<endl;\n}//移动圆盘 \n\nint Put(int n,LStack &s){\n\tfor(int i=n;i>=1;i--){\n\t\tPush(s,i);\n\t}\n\tcout<<\"汉诺塔创建成功\"<<endl; \n\treturn 0;\n}//创建汉诺塔 \n\nint hanoi(int n,LStack &s1,LStack &s2,LStack &s3){\n\tif(n==1){\n\t\tmove(s1,s3,s2);\n\t}\n\telse{\n\t\thanoi(n-1,s1,s3,s2);\n\t\tmove(s1,s3,s2);\n\t\thanoi(n-1,s2,s1,s3);\n\t}\n\treturn 0;\n} //汉诺塔\n\nint main(){\n\tLStack s1,s2,s3;\n\tInitStack(s1);\n\tInitStack(s2);\n\tInitStack(s3);\n\tint n;\n\tcout<<\"请输入圆盘的数量:\"<<endl;\n\tcin>>n;\n\tPut(n,s1);//按逆序将圆盘放入 \n\tPrint(s1);//打印圆盘查看放入情况 \n\thanoi(n,s1,s2,s3);\n\treturn 0;\n}\n```\n\n\n<!--more-->"},{"title":"二叉树的层序遍历","url":"/2022/08/20/二叉树的层序遍历/","content":"# 二叉树的静态实现\n\n二叉树可以使用静态方式建立来避免使用指针\n\n<!--more-->\n\n## 静态二叉链表\n\n静态二叉链表是指，结点的左右指针域使用int 型代替，用来表示左右子树的根节点在数组中的下标。为此要建立一个大小为结点上限个数的node数组，所有动态生成的结点都直接使用数组中的结点，所有对指针的操作都改为对数组的下标的操作。\n\n## 二叉树的静态定义\n\n于是，二叉树的定义如下：\n\n```cpp\ntypedef struct Node{//二叉树的静态定义 \n\tElemType data;\n\tint rchlid;\n\tint lchlid;\n}Node[maxn];\n```\n\n## 建立新的结点\n\n在建立新的结点的时候我们只需要一个全域的int型index来记录Node结点的个数，而只他的子结点的初始化只需要将rchlid与lchlid赋值为-1或者maxn(数组的存储范围是1~maxn-1)\n\n```cpp\nint index = 0;\nint newNode(int v){//创建新的结点 \n\tNode[index].data = v;\n\tNode[index].lchlid = -1;\n\tNode[index].rchlid = -1;\n\treturn index++;\n}\n```\n\n## 查找\n\n**root是查找时的下标**\n\n```cpp\nvoid search(int root,int x,int newData){\n\tif(root == -1){\n\t\treturn ;\n\t}\n\tif(Node[root].data==x){\n\t\tNode[root].data = newData;\n\t\treturn ;\n\t}\n\tsearch(Node[root].lchlid,x,newData);\n\tsearch(Node[root].rchlid,x,newData);\n}\n```\n\n## 插入\n\n```cpp\nint insert(int &root,int x){//插入 \n\tif(root == -1){\n\t\troot = newNode(x);\n\t\treturn 0;\n\t}\n\tif(Node[root].lchlid>=0) insert(Node[index].lchlid,x);\n\telse insert(Node[index].rchlid,x);\n}\n```\n\n## 创建\n\n```cpp\nint Creat(int data[],int n){\n\tint root = -1;\n\tfor(int i = 0;i <n;i++){\n\t\tinsert(root,data[i]);//将data[0]-data[n-1]插入二叉树中 \n\t}\n\treturn root;//返回二叉树的根节点下标 \t\n}\n```\n\n## 遍历\n\n先序遍历\n\n```cpp\nvoid preNode(int root){//先序遍历\n    if(root == -1){\n        return ;\n    }\n    cout<<node[root].data<<\" \";\n    preNode(node[root].lchlid);\n    preNode(node[root].rchlid);\n}\n```\n\n中序遍历\n\n```cpp\nvoid inNode(int root){//中序遍历\n    if(root == -1){\n        return ;\n    }\n    inNode(node[root].lchlid);\n    cout<<node[root].data<<\" \";\n    inNode(node[root].rchlid);\n}\n```\n\n后序遍历\n\n```cpp\nvoid postNode(int root){\n    if(root == -1){\n        return ;\n    }\n    postNode(node[root].lchlid);\n    postNode(node[root].rchlid);\n    cout<<node[root].data<<\" \";\n}\n```\n\n层序遍历\n\n```cpp\nvoid layerNode(int root){//层序遍历\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n        int now = q.front();\n        q.pop();\n        cout<<node[now].data<<\" \";\n        if(node[now].lchlid!=-1) q.push(node[now].lchlid);\n        if(node[now].rchlid!=-1) q.push(node[now].rchlid);\n    }\n}\n```\n\n\n\n# 树的遍历\n\n## 树的静态写法\n\n这里讨论的树并非二叉树，这里的树指的是子节点个数不限而且没有先后次序的树。\n\n```cpp\n#define maxn 300\ntypedef int ElemType;\nstruct Node{\n    ElemType data;\n    int child[maxn];\n}Node[maxn];\n```\n\n上述的方法建立树的话，对于每个根节点有多少子节点本身并不确定，只能在每个根节点的子节点的数量开到最大，但是这样的存储空间会很大，这个时候可以使用vector来做长度动态的数组来存放子结点\n\n```cpp\ntypedef struct Node{//树的定义 \n\tElemType data;\n\tvector child; \n}Node[maxn];\n```\n\n在需要建立一个新的结点的时候只需要按顺序在数组中取下一个坐标来\n\n```cpp\nint index = 0;\nvoid newNode(int v){//创建新的结点 \n\tNode[index].data = v;\n\tNode[index].child.clear();\n\treturn index++;\n}\n```\n\n\n<!--more-->"},{"title":"二叉树","url":"/2022/08/20/二叉树/","content":"\n\n# 二叉树\n\n二叉树是数据结构不可或缺的结构，二叉树中又有完全二叉树与满二叉树。学会二叉树，就要先了解二叉树的结构。\n\n<!--more-->\n\n## 结点与叶子 结点\n\n二叉树的每一个数据叫做结点，其中最上方的结点叫做头结点，每个结点有两个分支，分别叫左孩子与右孩子，对于这两个孩子来说，原来的结点就是他们的父结点。有多少个数据就有多少的结点。\n\n但是不是每个结点的孩子结点都是存在的，当两个孩子结点都不存在的时候，这个结点就叫做叶子结点。\n\n## 层数\n\n这个树的层数也可以叫做树的高度，根据名字就可以理解，这个树有多高（或者有几层）就是它的层数。\n\n## 树的结构定义\n\n根据前面对树的结构的分析，树的结构定义可以由如下组成：\n\n1、数据域\n\n2、孩子结点——左孩子结点与右孩子结点\n\n3、由于每个结点结构相同，所以只要每个将左右孩子结点与父结点相同定义即可\n\n下面是树的结构定义\n\n```c++\ntypedef struct TreeNode{\n\tTreeNode *left;//左孩子结点\n\tTreeNode *right;//右孩子结点\n\tElemType data;//数据域\n}TreeNode,*Tree;//二叉树的定义\n```\n\n## 树的遍历方式\n\n树的遍历根据父节点遍历的先后顺序不同而有三种，先序遍历、中序遍历和后序遍历。当父结点先于左孩子与右孩子遍历时叫先序遍历，以此类推。所以最后的遍历有三种不同的结果（也可能三种会相同），因为只提供一种遍历方式的树有不确定性 ，反过来也可以用三种遍历方法中的两种来确定一个准确的树。\n\n### 先序遍历\n\n```c++\nint preOrderTraverse(Tree &t){\n\tif(t){\n\t\tcout<<t->data;\n\t\tpreOrderTraverse(t->left);\n\t\tpreOrderTraverse(t->right);\n\t}\n}//先序打印 \n```\n\n### 中序遍历\n\n```c++\nint inOrderTraverse(Tree &t){\n\tif(t){\n\t\tinOrderTraverse(t->left);\n\t\tcout<<t->data;\n\t\tinOrderTraverse(t->right);\n\t}\n}//中序打印 \n```\n\n### 后序遍历\n\n```c++\nint postOrderTraverse(Tree &t){\n\tif(t){\n\t\tpostOrderTraverse(t->left);\n\t\tpostOrderTraverse(t->right);\n\t\tcout<<t->data;\n\t}\n}//后序打印 \n```\n\n## 创建树\n\n创建时，遇到空的孩子结点用“#”号代替。\n\n### 先序创建树\n\n```c++\nint InitTree(Tree &t){//先序创建二叉树 \n\tchar ch;\n\tcin>>ch;\n\tif(ch=='#'){\n\t\tt = NULL;\n\t}\n\telse{\n\t\tt = new TreeNode;\n\t\tt->data = ch;\n\t\tcout<<t->data;\n\t\tInitTree(t->left);\n\t\tInitTree(t->right);\n\t}\n//\tcout<<\"创建树成功\"<<endl;\n}//创建二叉树 \n```\n\n这里用的是先序遍历的方法来创建树，实际上中序与后序也可以创建\n\n### 中序创建树\n\n```c++\nint InitTree(Tree &t){//先序创建二叉树 \n\tchar ch;\n\tcin>>ch;\n\tif(ch=='#'){\n\t\tt = NULL;\n\t}\n\telse{\n\t\tInitTree(t->left);\n\t\tt = new TreeNode;\n\t\tt->data = ch;\n\t\tcout<<t->data;\n\t\tInitTree(t->right);\n\t}\n//\tcout<<\"创建树成功\"<<endl;\n}//创建二叉树 \n```\n\n### 后序创建树\n\n```c++\nint InitTree(Tree &t){//先序创建二叉树 \n\tchar ch;\n\tcin>>ch;\n\tif(ch=='#'){\n\t\tt = NULL;\n\t}\n\telse{\n\t\tInitTree(t->left);\n\t\tInitTree(t->right);\n\t\tt = new TreeNode;\n\t\tt->data = ch;\n\t\tcout<<t->data;\n\t}\n//\tcout<<\"创建树成功\"<<endl;\n}//创建二叉树 \n```\n\n## 求树的基本参数\n\n### 树的高度\n\n树的高度计算：如果有父结点则返回左孩子与右孩子中高度最大的加1，没有返回0；递归实现上述步骤；\n\n```c++\nint Max(int a,int b){\n\tif(a>b) return a;\n\telse return b;\n}\nint GetHeight(Tree &t){\n\tif(t){\n\t\treturn Max(GetHeight(t->left),GetHeight(t->right))+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的高度 \n```\n\n### 树的结点数\n\n树的结点数计算：如果父结点存在则结点加上该结点左孩子与右孩子的数目，不存在则返回0。\n\n递归以上步骤；\n\n```c++\nint GetNodeNum(Tree &t){\n\tif(t){\n\t\treturn GetNodeNum(t->left)+GetNodeNum(t->right)+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的节点数 \n```\n\n### 树的叶子结点树\n\n树的叶子要判端一个结点是否有左孩子与右孩子，有孩子就不算叶子结点。对于父结点来说，如果父结点不存在则无叶子结点，如果父结点存在但是没有孩子结点则算作一个叶子结点，但是如果父结点有孩子则不能算作叶子结点。\n\n```c++\nint leaveNodeNum(Tree t){\n\tif(t){\n\t\tif(t->left==NULL&&t->right==NULL){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn leaveNodeNum(t->left)+leaveNodeNum(t->right);\n\t\t}\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的叶子结点树\n```\n\n## 完整代码\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n//二叉树 \n\ntypedef char ElemType;\ntypedef struct TreeNode{\n\tTreeNode *left;\n\tTreeNode *right;\n\tElemType data;\n}TreeNode,*Tree;//二叉树的定义\n\nint InitTree(Tree &t){//先序创建二叉树 \n\tchar ch;\n\tcin>>ch;\n\tif(ch=='#'){\n\t\tt = NULL;\n\t}\n\telse{\n\t\tt = new TreeNode;\n\t\tt->data = ch;\n\t\tcout<<t->data;\n\t\tInitTree(t->left);\n\t\tInitTree(t->right);\n\t}\n//\tcout<<\"创建树成功\"<<endl;\n}//创建二叉树 \n\nint preOrderTraverse(Tree &t){\n\tif(t){\n\t\tcout<<t->data;\n\t\tpreOrderTraverse(t->left);\n\t\tpreOrderTraverse(t->right);\n\t}\n}//先序打印 \n\nint inOrderTraverse(Tree &t){\n\tif(t){\n\t\tinOrderTraverse(t->left);\n\t\tcout<<t->data;\n\t\tinOrderTraverse(t->right);\n\t}\n}//中序打印 \n\nint postOrderTraverse(Tree &t){\n\tif(t){\n\t\tpostOrderTraverse(t->left);\n\t\tpostOrderTraverse(t->right);\n\t\tcout<<t->data;\n\t}\n}//后序打印 \n\nint Max(int a,int b){\n\tif(a>b) return a;\n\telse return b;\n}\nint GetHeight(Tree &t){\n\tif(t){\n\t\treturn Max(GetHeight(t->left),GetHeight(t->right))+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的高度 \n\nint GetNodeNum(Tree &t){\n\tif(t){\n\t\treturn GetNodeNum(t->left)+GetNodeNum(t->right)+1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的节点数 \n\nint leaveNodeNum(Tree t){\n\tif(t){\n\t\tif(t->left==NULL&&t->right==NULL){\n\t\t\treturn 1;\n\t\t}\n\t\telse{\n\t\t\treturn leaveNodeNum(t->left)+leaveNodeNum(t->right);\n\t\t}\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}//求树的叶子结点树 \n\nint main(){\n\tcout<<\"请输入树\"<<endl;\n\tTreeNode *t;\n\tInitTree(t); \n\tcout<<\"创建成功\"<<endl;\n\tpreOrderTraverse(t);\n\tcout<<endl;\n\tinOrderTraverse(t);\n\tcout<<endl;\n\tpostOrderTraverse(t);\n\tcout<<endl<<\"树的高度为\";\n\tcout<<endl<<GetHeight(t);\n\tcout<<endl<<\"树的节点数为\";\n\tcout<<endl<<GetNodeNum(t);\n\tcout<<endl<<\"树的叶子节点数为：\"<<endl;\n\tcout<<leaveNodeNum(t);\n}\n\n/*输入示例\nabdh##i##ej##k##cfl###g##\n示例验证\n输入树\nabdh##i##ej##k##cfl###g##\n先序遍历\nabdhiejkcflg\n中序遍历\nhdibjekalfcg\n后序遍历\nhidjkeblfgca\n树的层数4\n树的节点数12\n树的叶子节点树6\n*/\n```\n\n------\n\n谢谢阅读！\n<!--more-->"},{"title":"动态地址分配","url":"/2022/08/20/动态地址分配/","content":"\n\n# 动态地址的分配\n\n对于初学C语言的同学来讲，静态分配数组是最方便最常用的操作，不论什么情况都可以用静态分配来解决。但是静态分配地址有一个比较大的问题没法解决，那就是资源的过度浪费，尤其是对于嵌入式开发来讲，原来我也非常的喜欢使用，但是自从我发现这是一个非常不好的习惯之后，我就决定学习动态分配了。\n\n<!--more-->\n\n相对于静态分配地址来说，动态分配地址更加的灵活，但是动态分配地址也有缺点，那就分配的地址在最后需要程序员自己去释放，如果不能及时释放的话，可能会导致数据的溢出。实际上，动态分配数组在使用后，最后释放地址的时候非常的影响程序的性能，可能会花很久的时间（如果不去释放的话可能化的时间更久）。\n\n\n\n动态分配数组的时候有一个非常重要的规则，**分配地址要由外及里，释放地址时要由里及外**。\n\n## 动态分配一维数组\n\n```c++\n#include<iostream>\n#include<bits/stdc++.h>//万能头，分配地址的头文件包含在里面（偷懒时使用）\n#include<malloc.h>//这是分配地址的头文件\n\nusing namespace std;\n\nint main(){\n    int n,s;\n    int *array;//设置初指针存放数组\n    cout<<\"Please input the number you want\"<<endl;\n    cin>>n;\n    array = (int *)malloc(n*sizeof(int));//为指针分配地址\n    if(!array) {\n        cout<<\"ERROR\"<<endl;\n        return 0;\n    }//判空，防止地址分配失败\n    for(int i=0;i<n;i++){\n        cout<<array[i]<<\" \";\n    }//查看分配结果——主要看输出多少数，和n相等则成功（一般输出为0）\n    cout<<endl;\n    for(int i=1;i<=n;i++){\n        array[i-1] = i;\n        cout<<array[i-1]<<\" \";\n    }//给数组赋值确认\n    free(array);//释放地址，防止数据溢出\n    return 0;\n}\n```\n\n输出结果：\n\n![输出结果](C:\\Users\\渣渣致\\Pictures\\截图\\地址分配1.png)\n\n------\n\n注：判空的操作经常会在链表或堆栈中使用。\n\n## 动态分配二维数组\n\n```c++\n#include<iostream>\n#include<bits/stdc++.h>//万能头文件\n\nusing namespace std;\n\nint main(){\n    int num1,num2;\n    cout<<\"Please input the first number you want\"<<endl;\n    cin>>num1;//输入第一维度的长度\n    cout<<\"Please input the second number you want\"<<endl;\n    cin>>num2;//输入第二维度的长度\n    int **array = (int **)malloc(num1*sizeof(int ));//先分配一次第一维度的地址\n    for(int i=0;i<num1;i++){\n        array[i] = (int *)malloc(num2*sizeof(int));//分配num1次的第二维度的数组\n    }\n    for(int i=0;i<num1;i++){\n        for(int j=0;j<num2;j++){\n            array[i][j] = i*num2+j+1;//按顺序赋值位置的数给数组便于观察实验结果\n        }\n    }\n    for(int i=0;i<num1;i++){\n        for(int j=0;j<num2;j++){\n            cout<<array[i][j]<<\" \";//输出二维数组\n        }\n        cout<<endl;\n    }\n    for(int i=0;i<num1;i++){\n        free(array[i]);\n    }\n    free(array);/*释放空间地址——这个操作可能会很耗时间，\n    在运行这一步之后可能要好久才能结束程序*/\n    return 0;\n}\n```\n\n运行结果：\n\n![](C:\\Users\\渣渣致\\Pictures\\截图\\动态地址分配2.png)\n\n二维数组创建时可以发现，创建时我们严格遵守创建由外及里，释放有里及外的规则。观察代码\n\n创建时：\n\n```c++\n\tint **array = (int **)malloc(num1*sizeof(int ));//先分配一次第一维度的地址\n    for(int i=0;i<num1;i++){\n        array[i] = (int *)malloc(num2*sizeof(int));//分配num1次的第二维度的数组\n    }\n```\n\n先为第一维分配了地址，然后为第二维分配了地址——当然，第二维要分配num1次。\n\n然后是释放时：\n\n```c++\nfor(int i=0;i<num1;i++){\n    free(array[i]);\n}\nfree(array);\n```\n\n先释放了第二维的地址，然后才释放第一维的地址。同时，第二维的地址也要释放num1次。\n\n------\n\n除了二维数组与一维数组，多维数组也可以使用动态地址分配来储存数据。接下来利用三维数组的建立帮大家有更深刻的理解：\n\n```c++\n#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int num1,num2,num3;\n    cout<<\"Please input the first number\"<<endl;\n    cin>>num1;//一维\n    cout<<\"Please input the second number\"<<endl;\n    cin>>num2;//二维\n    cout<<\"Please input the third number\"<<endl;\n    cin>>num3;//三维\n    int*** array = (int ***)malloc(num1*sizeof(int ));//给一维分配储存地址\n    for(int i=0;i<num1;i++){\n        array[i]= (int **)malloc(num2*sizeof(int ));//给二维分配地址\n        for(int j=0;j<num2;j++){\n            array[i][j] = (int *)malloc(num3*sizeof(int));//给三维分配地址\n        }\n    }\n    for(int i=0;i<num1;i++){\n        for(int j=0;j<num2;j++){\n            for(int k=0;k<num3;k++){\n                array[i][j][k] = i+j+k+1;//给每一位赋值数，便于确定实验是否成功\n                cout<<array[i][j][k]<<\" \";\n            }\n            cout<<endl;\n        }\n        cout<<endl;\n    }\n    for(int i=0;i<num1;i++){\n        for(int j=0;j<num2;j++){\n                free(array[i][j]);\n        }\n    }//释放三维地址\n    for(int i=0;i<num1;i++){\n            free(array[i]);\n    }//释放二维地址\n    free(array);//释放最后一维地址\n    return 0;\n}\n```\n\n运行结果：\n\n![](C:\\Users\\渣渣致\\Pictures\\截图\\动态分配地址.png)\n\n\n\n实际上最后释放地址还有更简单更快的方法,这里只展示最后释放部分的代码：\n\n```c++\nfor(int i=0;i<num1;i++){\n        for(int j=0;j<num2;j++){\n                free(array[i][j]);//释放第三维\n        }\n        free(array[i]);//释放第二维\n    }\nfree(array);//释放第一维\n```\n\n------\n\n感谢浏览！\n<!--more-->\n"},{"title":"单链表","url":"/2022/08/20/单链表/","content":"\n\n# 单链表\n\n​\t单链表与顺序表不同，单链表的存储地址不是连续的，单链表的每一个存储空间都存储有下一个储存地址的头指针，如同利用线索走迷宫一样，只有找到线索才能找到下一个目的地，想要找到下一个储存地址，就要查询上一个储存空间储存的指针指向哪里。\n\n所以单链表的数据元素有两部分，一部分来存储数据，叫存储域，另一部分来储存指针，叫指针域。\n\n<!--more-->\n\n​\t单链表的优点是在插入与删除时要比顺序表方便许多，可以节省更多的运行空间与时间。顺序表的删除与插入需要遍历插入点或删除点的后所有储存位置，但是单链表只需要操作几步就可以插入了（这是在指针已经指向插入或删除位置时而言）\n\n​\t单链表的缺点也很明显，那就是不方便遍历所有数据元素，而且单链表首元节点的指针一旦指向后面便不能再找到首元节点，这个时候就需要头节点的帮助来找到首元节点。\n\n## 单链表的构造\n\n```c++\ntypedef struct LinkList{\n\tint data;//单链表的数据域\n\tLinkList *next;//单链表的指针域，使用的定义类型是自定义的结构类型\n}LinkList;//定义单链表 \n```\n\n如代码所示，单链表的数据元素包含两部分，数据域与指针域。\n\n其中指针是用自定义的结构做类型的，因为指针指向下一数据元素也是相同的结构。\n\n## 带有头节点的链表：\n\n带有头节点的链表会在第一个数据元素（首元节点）的之前加入一个指针或者空数据元素，它的作用是方便查找这个链表的首元节点，便于“重头来过”\n\n### 链表的初始化\n\n```c++\nLinkList *InitList(){\n\tLinkList *p = (LinkList *)malloc(sizeof(LinkList));//创建头节点\n\tp->data = 0;//让头节点长得好看点，初始化头节点的数据与指针\n\tp->next = NULL;\n\tLinkList *temp = p;//将头节点赋值给temp\n\tint i;\n\tcout<<\"请输入链表的长度\"<<endl;\n\tcin>>i;\n\tcout<<\"请输入链表的数据\"<<endl;\n\tElemType e;\n\tfor(int j=0;j<i-1;j++){\n\t\tcin>>e;\n\t\tLinkList *a = (LinkList *)malloc(sizeof(LinkList));//创建新的节点便于赋值\n\t\ta->data = e;//给节点赋值\n\t\ta->next = NULL;//指针指向空\n\t\ttemp->next = a;//将新建的节点赋值给temp\n\t\ttemp = temp->next;//temp的指针指向下一个节点，便于下次插入\n\t}\n\tcout<<\"链表创造成功\"<<endl;\n\treturn p;\n}//创建链表 \n```\n\n这是有头节点的链表的创建方法，首先创建好头节点后，所有其他需要用到遍历或者指针会向后指的操作都可以先创建一个新的链表指针并将头指针赋值给它，这样每一次用到这个链表的时都可以马上找到头节点。如代码中的给链表赋值和初始化链表都是先创建一个新的链表再操作的方法。可能有小伙伴有疑问，temp,a,p都是不同的链表，为什么会操作的是同一链表的，实际上，在赋值的时候，都是在赋值指针，这样虽然他们命名不同，但是指向的是同一个链表，操作也是在同一个链表上。\n\n### 链表的打印\n\n```c++\nvoid Print(LinkList *p){\n\tLinkList *temp = p;\n\tcout<<\"现在的链表数据为:\"<<endl;\n\twhile(temp->next){//判断头指针指向的下一节点是否为空，也就是判断首元节点是否为空。\n\t\ttemp = temp->next;//先将指针指向首元节点\n\t\tcout<<temp->data<<\" \";//输出首元节点的数据\n\t}\n\tcout<<endl;\n}//打印 \n```\n\n### 链表的插入\n\n```c++\nint InsertList(LinkList *p,int i,ElemType e){\n\tint j=0;//判断是否超出链表范围时使用\n\tLinkList *temp = p;\n\twhile(j<i-1&&temp->next){\n\t\tj++;\n\t\ttemp=temp->next;\n\t}//将指针移动到插入位置\n\tif(j>i-1||!temp->next){\n\t\tcout<<\"输入的位置有误\"<<endl;\n\t\treturn 0;\n\t}\n\tLinkList *s = (LinkList *)malloc(sizeof(LinkList));\n\ts->data = e;//将插入的值赋值给s\n\ts->next = temp->next;//将s的后继指向temp的后继\n\ttemp->next = s;//将s变为temp的后继\n\tcout<<\"插入成功\"<<endl; \n\treturn 0;\n} //插入 \n```\n\n插入的顺序至关重要，下面的代码中第二以及第三步的位置不可以互换\n\n```c++\ns->data = e;//将插入的值赋值给s --1\ns->next = temp->next;//将s的后继指向temp的后继 --2\ntemp->next = s;//将s变为temp的后继 --3\n```\n\n### 链表的删除\n\n```c++\nint DeleteList(LinkList *p,int i){\n\tLinkList *temp = p;\n\tint j = 0;\n\twhile(j<i-1&&temp->next){\n\t\tj++;\n\t\ttemp = temp->next;\n\t}//指针移动到删除的位置\n\tif(j>i-1||!temp->next){\n\t\tcout<<\"删除的位置有误\"<<endl;\n\t\treturn 0;\n\t}\n\tLinkList *s = (LinkList *)malloc(sizeof(LinkList));\n\ts->data = temp->data;//将需要删除的数据赋值给s\n\ttemp->next = temp->next->next;//最简的删除操作\n\tfree(s);//释放s的空间防止数据溢出\n\tcout<<\"删除成功\"<<endl;\n\treturn 0;\n}//删除 \n```\n\n注：删除时需要释放删除位置的储存空间，防止数据溢出\n\n### 链表的逆置\n\n```c++\nint nizhi(SqList *p){\n\tSqList *q,*s;\n\tq = p->next;\n\tp->next = NULL;\n\t\n\twhile(q){\n\t\ts = q;\n\t\tq = q->next;\n\t\ts->next = p->next;\n\t\tp->next = s;\n\t}\n\tcout<<\"逆置成功\"<<endl;\n\treturn 0;\n}//逆置 \n```\n\n### 完整的链表基本功能代码：\n\n```c++\n#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef int ElemType;//定义数据类型,方便修改。\ntypedef struct LinkList{\n\tElemType data;\n\tLinkList* next;\n}LinkList;\n\nLinkList *InitList(){\n\tLinkList *p =(LinkList *)malloc(sizeof(LinkList));\n\tLinkList *temp = p;\n\tint i;\n\tcout<<\"请输入链表的长度\"<<endl;\n\tcin>>i;\n\tcout<<\"请输入链表的数据\"<<endl;\n\tfor(int j =1;j<=i;j++){\n\t\tElemType e;\n\t\tcin>>e;\n\t\tLinkList *a = (LinkList *)malloc(sizeof(LinkList));\n\t\ta->data = e;\n\t\ta->next = NULL;\n\t\ttemp->next = a;\n\t\ttemp = temp->next;\n\t}\n\tcout<<\"初始化成功\"<<endl;\n\treturn p;\n}//初始化链表 \n\nvoid Print(LinkList *p){\n\tLinkList *temp = p;\n\tcout<<\"现在的链表为：\"<<endl;\n\twhile(temp->next){\n\t\ttemp = temp->next;\n\t\tcout<<temp->data<<\" \";\n\t}\n\tcout<<endl; \n}//打印\n\nint InsertList(LinkList *p,int i,ElemType e){\n\tint j=0;\n\tLinkList *temp = p;\n\twhile(j<i-1&&temp->next){\n\t\tj++;\n\t\ttemp=temp->next;\n\t}\n\tif(j>i-1||!temp->next){\n\t\tcout<<\"输入的位置有误\"<<endl;\n\t\treturn 0;\n\t}\n\tLinkList *s = (LinkList *)malloc(sizeof(LinkList));\n\ts->data = e;\n\ts->next = temp->next;\n\ttemp->next = s;\n\tcout<<\"插入成功\"<<endl; \n\treturn 0;\n} //插入 \n\nint DeleteList(LinkList *p,int i){\n\tLinkList *temp = p;\n\tint j = 0;\n\twhile(j<i-1&&temp->next){\n\t\tj++;\n\t\ttemp = temp->next;\n\t}\n\tif(j>i-1||!temp->next){\n\t\tcout<<\"删除的位置有误\"<<endl;\n\t\treturn 0;\n\t}\n\tLinkList *s = (LinkList *)malloc(sizeof(LinkList));\n\ts->data = temp->data;\n\ttemp->next = temp->next->next;\n\tfree(s);\n\tcout<<\"删除成功\"<<endl;\n\treturn 0;\n}//删除 \n\nint main(){\n\tLinkList *p = NULL;\n\tp = InitList();\n\tPrint(p);\n\tint i;\n\tElemType n;\n\tcout<<\"请输入插入的位置以及数据\"<<endl; \n\tcin>>i>>n;\n\tInsertList(p,i,n); \n\tPrint(p);\n\tcout<<\"请输入删除的位置\"<<endl;\n\tcin>>i;\n\tDeleteList(p,i);\n\tPrint(p);\n} \n```\n\n------\n\n谢谢阅读！"},{"url":"/2022/04/03/test/","content":"# WELCOME\n\n这里是渣渣致7的博客"}]